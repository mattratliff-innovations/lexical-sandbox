{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, $descendantsMatching, $findMatchingParent, removeClassNamesFromElement, objectKlassEquals, isHTMLElement as isHTMLElement$1, $insertFirst as $insertFirst$1, mergeRegister, $insertNodeToNearestRoot, $unwrapAndFilterDescendants } from '@lexical/utils';\nimport { ElementNode, isHTMLElement, $createParagraphNode, $isElementNode, $isLineBreakNode, $isTextNode, $applyNodeReplacement, createCommand, $createTextNode, $getSelection, $isRangeSelection, $createPoint, $isParagraphNode, $normalizeSelection__EXPERIMENTAL, isCurrentlyReadOnlyMode, TEXT_TYPE_TO_FORMAT, $getNodeByKey, $getEditor, $setSelection, SELECTION_CHANGE_COMMAND, getDOMSelection, $createRangeSelection, COMMAND_PRIORITY_HIGH, KEY_ESCAPE_COMMAND, COMMAND_PRIORITY_CRITICAL, CUT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, KEY_TAB_COMMAND, FOCUS_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getPreviousSelection, $getNearestNodeFromDOMNode, $createRangeSelectionFromDom, INSERT_PARAGRAPH_COMMAND, $isRootOrShadowRoot, $isDecoratorNode, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_UP_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, isDOMNode, setDOMUnmanaged, COMMAND_PRIORITY_EDITOR } from 'lexical';\nimport { copyToClipboard, $getClipboardDataFromSelection } from '@lexical/clipboard';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    return new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n  }\n  afterCloneFrom(node) {\n    super.afterCloneFrom(node);\n    this.__rowSpan = node.__rowSpan;\n    this.__backgroundColor = node.__backgroundColor;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableCellNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeaderStyles(serializedNode.headerState).setColSpan(serializedNode.colSpan || 1).setRowSpan(serializedNode.rowSpan || 1).setWidth(serializedNode.width || undefined).setBackgroundColor(serializedNode.backgroundColor || null);\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const output = super.exportDOM(editor);\n    if (isHTMLElement(output.element)) {\n      const element = output.element;\n      element.setAttribute('data-temporary-table-cell-lexical-key', this.getKey());\n      element.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element.rowSpan = this.__rowSpan;\n      }\n      element.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element.style.verticalAlign = 'top';\n      element.style.textAlign = 'start';\n      if (this.__backgroundColor === null && this.hasHeader()) {\n        element.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return output;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.getLatest().__colSpan;\n  }\n  setColSpan(colSpan) {\n    const self = this.getWritable();\n    self.__colSpan = colSpan;\n    return self;\n  }\n  getRowSpan() {\n    return this.getLatest().__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    const self = this.getWritable();\n    self.__rowSpan = rowSpan;\n    return self;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {\n    const self = this.getWritable();\n    self.__headerState = headerState & mask | self.__headerState & ~mask;\n    return self;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return self;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    const self = this.getWritable();\n    self.__backgroundColor = newBackgroundColor;\n    return self;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const style = domNode_.style;\n  const textDecoration = (style && style.textDecoration || '').split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      if (childLexicalNodes.length === 0) {\n        childLexicalNodes.push($createParagraphNode());\n      }\n      return childLexicalNodes;\n    },\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !$isElementNode(lexicalNode)) {\n        const paragraphNode = $createParagraphNode();\n        if ($isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n        if ($isTextNode(lexicalNode)) {\n          if (hasBoldFontWeight) {\n            lexicalNode.toggleFormat('bold');\n          }\n          if (hasLinethroughTextDecoration) {\n            lexicalNode.toggleFormat('strikethrough');\n          }\n          if (hasItalicFontStyle) {\n            lexicalNode.toggleFormat('italic');\n          }\n          if (hasUnderlineTextDecoration) {\n            lexicalNode.toggleFormat('underline');\n          }\n        }\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width) {\n  return $applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = createCommand('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeight(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    const height = this.getHeight();\n    return {\n      ...super.exportJSON(),\n      ...(height === undefined ? undefined : {\n        height\n      })\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return self;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    after: children => $descendantsMatching(children, $isTableCellNode),\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return $applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = $createParagraphNode();\n      paragraphNode.append($createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append($createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\n\n/**\n * Inserts a table row before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  let insertedRow = null;\n  if (insertAfter) {\n    const insertAfterEndRow = Math.max(focusStartRow + focusCell.__rowSpan, anchorStartRow + anchorCell.__rowSpan) - 1;\n    const insertAfterEndRowMap = gridMap[insertAfterEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertAfterEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= insertAfterEndRow) {\n        const currentCell = insertAfterEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertAfterEndRowNode = grid.getChildAtIndex(insertAfterEndRow);\n    if (!$isTableRowNode(insertAfterEndRowNode)) {\n      throw Error(`insertAfterEndRow is not a TableRowNode`);\n    }\n    insertAfterEndRowNode.insertAfter(newRow);\n    insertedRow = newRow;\n  } else {\n    const insertBeforeStartRow = Math.min(focusStartRow, anchorStartRow);\n    const insertBeforeStartRowMap = gridMap[insertBeforeStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertBeforeStartRowMap[i];\n      if (startRow === insertBeforeStartRow) {\n        const currentCell = insertBeforeStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertBeforeStartRowNode = grid.getChildAtIndex(insertBeforeStartRow);\n    if (!$isTableRowNode(insertBeforeStartRowNode)) {\n      throw Error(`insertBeforeStartRow is not a TableRowNode`);\n    }\n    insertBeforeStartRowNode.insertBefore(newRow);\n    insertedRow = newRow;\n  }\n  return insertedRow;\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append($createParagraphNode());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\n\n/**\n * Inserts a column before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append($createParagraphNode());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;\n    const newWidth = newColWidths[columnIndex];\n    newColWidths.splice(columnIndex, 0, newWidth);\n    grid.setColWidths(newColWidths);\n  }\n  return firstInsertedCell;\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const selectedRowCount = anchorCell.__rowSpan;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top have to be trimmed\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        const overflowTop = anchorStartRow - cellStartRow;\n        cell.setRowSpan(cell.__rowSpan - Math.min(selectedRowCount, cell.__rowSpan - overflowTop));\n      }\n      // Rows overflowing bottom have to be trimmed and moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n        let insertAfterCell = null;\n        for (let columnIndex = 0; columnIndex < column; columnIndex++) {\n          const currentCellMap = nextRow[columnIndex];\n          const currentCell = currentCellMap.cell;\n          // Checking the cell having startRow as same as nextRow\n          if (currentCellMap.startRow === row + 1) {\n            insertAfterCell = currentCell;\n          }\n          if (currentCell.__colSpan > 1) {\n            columnIndex += currentCell.__colSpan - 1;\n          }\n        }\n        if (insertAfterCell === null) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          insertAfterCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    newColWidths.splice(startColumn, selectedColumnCount);\n    grid.setColWidths(newColWidths);\n  }\n}\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $unmergeCell() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = $getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan === 1 && rowSpan === 1) {\n    return;\n  }\n  const [map, cellMap] = $computeTableMap(grid, cell, cell);\n  const {\n    startColumn,\n    startRow\n  } = cellMap;\n  // Create a heuristic for what the style of the unmerged cells should be\n  // based on whether every row or column already had that state before the\n  // unmerge.\n  const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;\n  const colStyles = Array.from({\n    length: colSpan\n  }, (_v, i) => {\n    let colStyle = baseColStyle;\n    for (let rowIdx = 0; colStyle !== 0 && rowIdx < map.length; rowIdx++) {\n      colStyle &= map[rowIdx][i + startColumn].cell.__headerState;\n    }\n    return colStyle;\n  });\n  const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;\n  const rowStyles = Array.from({\n    length: rowSpan\n  }, (_v, i) => {\n    let rowStyle = baseRowStyle;\n    for (let colIdx = 0; rowStyle !== 0 && colIdx < map[0].length; colIdx++) {\n      rowStyle &= map[i + startRow][colIdx].cell.__headerState;\n    }\n    return rowStyle;\n  });\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(colStyles[i] | rowStyles[0]).append($createParagraphNode()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          $insertFirst(currentRowNode, $createTableCellNode(colStyles[j] | rowStyles[i]).append($createParagraphNode()));\n        }\n      } else {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          insertAfterCell.insertAfter($createTableCellNode(colStyles[j] | rowStyles[i]).append($createParagraphNode()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(tableNode, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(tableNode, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Table`);\n  }\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Table`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(tableNode, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function getMapRow(i) {\n    let row = tableMap[i];\n    if (row === undefined) {\n      tableMap[i] = row = [];\n    }\n    return row;\n  }\n  const gridChildren = tableNode.getChildren();\n  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {\n    const row = gridChildren[rowIdx];\n    if (!$isTableRowNode(row)) {\n      throw Error(`Expected TableNode children to be TableRowNode`);\n    }\n    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {\n      if (!$isTableCellNode(cell)) {\n        throw Error(`Expected TableRowNode children to be TableCellNode`);\n      } // Skip past any columns that were merged from a higher row\n      const startMapRow = getMapRow(rowIdx);\n      while (startMapRow[colIdx] !== undefined) {\n        colIdx++;\n      }\n      const value = {\n        cell,\n        startColumn: colIdx,\n        startRow: rowIdx\n      };\n      const {\n        __rowSpan: rowSpan,\n        __colSpan: colSpan\n      } = cell;\n      for (let j = 0; j < rowSpan; j++) {\n        if (rowIdx + j >= gridChildren.length) {\n          // The table is non-rectangular with a rowSpan\n          // below the last <tr> in the table.\n          // We should probably handle this with a node transform\n          // to ensure that tables are always rectangular but this\n          // will avoid crashes such as #6584\n          // Note that there are probably still latent bugs\n          // regarding colSpan or general cell count mismatches.\n          break;\n        }\n        const mapRow = getMapRow(rowIdx + j);\n        for (let i = 0; i < colSpan; i++) {\n          mapRow[colIdx + i] = value;\n        }\n      }\n      if (cellA !== null && cellAValue === null && cellA.is(cell)) {\n        cellAValue = value;\n      }\n      if (cellB !== null && cellBValue === null && cellB.is(cell)) {\n        cellBValue = value;\n      }\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = $findMatchingParent(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    throw Error(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    throw Error(`Expected TableRowNode to have a parent TableNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $computeTableCellRectSpans(map, boundary) {\n  const {\n    minColumn,\n    maxColumn,\n    minRow,\n    maxRow\n  } = boundary;\n  let topSpan = 1;\n  let leftSpan = 1;\n  let rightSpan = 1;\n  let bottomSpan = 1;\n  const topRow = map[minRow];\n  const bottomRow = map[maxRow];\n  for (let col = minColumn; col <= maxColumn; col++) {\n    topSpan = Math.max(topSpan, topRow[col].cell.__rowSpan);\n    bottomSpan = Math.max(bottomSpan, bottomRow[col].cell.__rowSpan);\n  }\n  for (let row = minRow; row <= maxRow; row++) {\n    leftSpan = Math.max(leftSpan, map[row][minColumn].cell.__colSpan);\n    rightSpan = Math.max(rightSpan, map[row][maxColumn].cell.__colSpan);\n  }\n  return {\n    bottomSpan,\n    leftSpan,\n    rightSpan,\n    topSpan\n  };\n}\nfunction $computeTableCellRectBoundary(map, cellAMap, cellBMap) {\n  let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n  let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n  let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n  let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n  let exploredMinColumn = minColumn;\n  let exploredMinRow = minRow;\n  let exploredMaxColumn = minColumn;\n  let exploredMaxRow = minRow;\n  function expandBoundary(mapValue) {\n    const {\n      cell,\n      startColumn: cellStartColumn,\n      startRow: cellStartRow\n    } = mapValue;\n    minColumn = Math.min(minColumn, cellStartColumn);\n    minRow = Math.min(minRow, cellStartRow);\n    maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n    maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n  }\n  while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n    if (minColumn < exploredMinColumn) {\n      // Expand on the left\n      const rowDiff = exploredMaxRow - exploredMinRow;\n      const previousColumn = exploredMinColumn - 1;\n      for (let i = 0; i <= rowDiff; i++) {\n        expandBoundary(map[exploredMinRow + i][previousColumn]);\n      }\n      exploredMinColumn = previousColumn;\n    }\n    if (minRow < exploredMinRow) {\n      // Expand on top\n      const columnDiff = exploredMaxColumn - exploredMinColumn;\n      const previousRow = exploredMinRow - 1;\n      for (let i = 0; i <= columnDiff; i++) {\n        expandBoundary(map[previousRow][exploredMinColumn + i]);\n      }\n      exploredMinRow = previousRow;\n    }\n    if (maxColumn > exploredMaxColumn) {\n      // Expand on the right\n      const rowDiff = exploredMaxRow - exploredMinRow;\n      const nextColumn = exploredMaxColumn + 1;\n      for (let i = 0; i <= rowDiff; i++) {\n        expandBoundary(map[exploredMinRow + i][nextColumn]);\n      }\n      exploredMaxColumn = nextColumn;\n    }\n    if (maxRow > exploredMaxRow) {\n      // Expand on the bottom\n      const columnDiff = exploredMaxColumn - exploredMinColumn;\n      const nextRow = exploredMaxRow + 1;\n      for (let i = 0; i <= columnDiff; i++) {\n        expandBoundary(map[nextRow][exploredMinColumn + i]);\n      }\n      exploredMaxRow = nextRow;\n    }\n  }\n  return {\n    maxColumn,\n    maxRow,\n    minColumn,\n    minRow\n  };\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $getCellNodes(tableSelection) {\n  const [[anchorNode, anchorCell, anchorRow, anchorTable], [focusNode, focusCell, focusRow, focusTable]] = ['anchor', 'focus'].map(k => {\n    const node = tableSelection[k].getNode();\n    const cellNode = $findMatchingParent(node, $isTableCellNode);\n    if (!$isTableCellNode(cellNode)) {\n      throw Error(`Expected TableSelection ${k} to be (or a child of) TableCellNode, got key ${node.getKey()} of type ${node.getType()}`);\n    }\n    const rowNode = cellNode.getParent();\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`Expected TableSelection ${k} cell parent to be a TableRowNode`);\n    }\n    const tableNode = rowNode.getParent();\n    if (!$isTableNode(tableNode)) {\n      throw Error(`Expected TableSelection ${k} row parent to be a TableNode`);\n    }\n    return [node, cellNode, rowNode, tableNode];\n  });\n  // TODO: nested tables may violate this\n  if (!anchorTable.is(focusTable)) {\n    throw Error(`Expected TableSelection anchor and focus to be in the same table`);\n  }\n  return {\n    anchorCell,\n    anchorNode,\n    anchorRow,\n    anchorTable,\n    focusCell,\n    focusNode,\n    focusRow,\n    focusTable\n  };\n}\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * {@link $createTableSelection} unfortunately makes it very easy to create\n   * nonsense selections, so we have a method to see if the selection probably\n   * makes sense.\n   *\n   * @returns true if the TableSelection is (probably) valid\n   */\n  isValid() {\n    return this.tableKey !== 'root' && this.anchor.key !== 'root' && this.anchor.type === 'element' && this.focus.key !== 'root' && this.focus.type === 'element';\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    return $isTableSelection(selection) && this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    // note: closure compiler's acorn does not support ||=\n    this.dirty = this.dirty || tableKey !== this.tableKey || anchorCellKey !== this.anchor.key || focusCellKey !== this.focus.key;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, $createPoint(this.anchor.key, this.anchor.offset, this.anchor.type), $createPoint(this.focus.key, this.focus.offset, this.focus.type));\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection.\n   * This will be true if any paragraph in table cells has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    let format = 0;\n    const cellNodes = this.getNodes().filter($isTableCellNode);\n    cellNodes.forEach(cellNode => {\n      const paragraph = cellNode.getFirstChild();\n      if ($isParagraphNode(paragraph)) {\n        format |= paragraph.getTextFormat();\n      }\n    });\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (format & formatFlag) !== 0;\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!$isElementNode(focusNode)) {\n      throw Error(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = $normalizeSelection__EXPERIMENTAL(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const {\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCell);\n    if (!(anchorCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCell);\n    if (!(focusCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    if (!this.isValid()) {\n      return [];\n    }\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const {\n      anchorTable: tableNode,\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          throw Error(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          throw Error(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    const {\n      minColumn,\n      maxColumn,\n      minRow,\n      maxRow\n    } = $computeTableCellRectBoundary(map, cellAMap, cellBMap);\n\n    // We use a Map here because merged cells in the grid would otherwise\n    // show up multiple times in the nodes array\n    const nodeMap = new Map([[tableNode.getKey(), tableNode]]);\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          throw Error(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodeMap.set(currentRow.getKey(), currentRow);\n          lastRow = currentRow;\n        }\n        if (!nodeMap.has(cell.getKey())) {\n          $visitRecursively(cell, childNode => {\n            nodeMap.set(childNode.getKey(), childNode);\n          });\n        }\n      }\n    }\n    const nodes = Array.from(nodeMap.values());\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  // TODO this is a suboptimal design, it doesn't make sense to have\n  // a table selection that isn't associated with a table. This\n  // constructor should have required argumnets and in true we\n  // should check that they point to a table and are element points to\n  // cell nodes of that table.\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $createTableSelectionFrom(tableNode, anchorCell, focusCell) {\n  const tableNodeKey = tableNode.getKey();\n  const anchorCellKey = anchorCell.getKey();\n  const focusCellKey = focusCell.getKey();\n  {\n    if (!tableNode.isAttached()) {\n      throw Error(`$createTableSelectionFrom: tableNode ${tableNodeKey} is not attached`);\n    }\n    if (!tableNode.is($findTableNode(anchorCell))) {\n      throw Error(`$createTableSelectionFrom: anchorCell ${anchorCellKey} is not in table ${tableNodeKey}`);\n    }\n    if (!tableNode.is($findTableNode(focusCell))) {\n      throw Error(`$createTableSelectionFrom: focusCell ${focusCellKey} is not in table ${tableNodeKey}`);\n    } // TODO: Check for rectangular grid\n  }\n  const prevSelection = $getSelection();\n  const nextSelection = $isTableSelection(prevSelection) ? prevSelection.clone() : $createTableSelection();\n  nextSelection.set(tableNode.getKey(), anchorCell.getKey(), focusCell.getKey());\n  return nextSelection;\n}\n\n/**\n * Depth first visitor\n * @param node The starting node\n * @param $visit The function to call for each node. If the function returns false, then children of this node will not be explored\n */\nfunction $visitRecursively(node, $visit) {\n  const stack = [[node]];\n  for (let currentArray = stack.at(-1); currentArray !== undefined && stack.length > 0; currentArray = stack.at(-1)) {\n    const currentNode = currentArray.pop();\n    if (currentNode === undefined) {\n      stack.pop();\n    } else if ($visit(currentNode) !== false && $isElementNode(currentNode)) {\n      stack.push(currentNode.getChildren());\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $getTableAndElementByKey(tableNodeKey, editor = $getEditor()) {\n  const tableNode = $getNodeByKey(tableNodeKey);\n  if (!$isTableNode(tableNode)) {\n    throw Error(`TableObserver: Expected tableNodeKey ${tableNodeKey} to be a TableNode`);\n  }\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNodeKey));\n  if (!(tableElement !== null)) {\n    throw Error(`TableObserver: Expected to find TableElement in DOM for key ${tableNodeKey}`);\n  }\n  return {\n    tableElement,\n    tableNode\n  };\n}\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.isSelecting = false;\n    this.shouldCheckSelection = false;\n    this.abortController = new AbortController();\n    this.listenerOptions = {\n      signal: this.abortController.signal\n    };\n    this.nextFocus = null;\n    this.trackTable();\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    this.abortController.abort('removeListeners');\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n    this.listenersToRemove.clear();\n  }\n  $lookup() {\n    return $getTableAndElementByKey(this.tableNodeKey, this.editor);\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.getEditorState().read(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const {\n          tableNode,\n          tableElement\n        } = this.$lookup();\n        this.table = getTable(tableNode, tableElement);\n      }, {\n        editor: this.editor\n      });\n    });\n    this.editor.getEditorState().read(() => {\n      const {\n        tableNode,\n        tableElement\n      } = this.$lookup();\n      this.table = getTable(tableNode, tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    }, {\n      editor: this.editor\n    });\n  }\n  $clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.$enableHighlightStyle();\n    const {\n      tableNode,\n      tableElement\n    } = this.$lookup();\n    const grid = getTable(tableNode, tableElement);\n    $updateDOMForSelection(editor, grid, null);\n    if ($getSelection() !== null) {\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    }\n  }\n  $enableHighlightStyle() {\n    const editor = this.editor;\n    const {\n      tableElement\n    } = this.$lookup();\n    removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\n    tableElement.classList.remove('disable-selection');\n    this.hasHijackedSelectionStyles = false;\n  }\n  $disableHighlightStyle() {\n    const {\n      tableElement\n    } = this.$lookup();\n    addClassNamesToElement(tableElement, this.editor._config.theme.tableSelection);\n    this.hasHijackedSelectionStyles = true;\n  }\n  $updateTableTableSelection(selection) {\n    if (selection !== null) {\n      if (!(selection.tableKey === this.tableNodeKey)) {\n        throw Error(`TableObserver.$updateTableTableSelection: selection.tableKey !== this.tableNodeKey ('${selection.tableKey}' !== '${this.tableNodeKey}')`);\n      }\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n      this.updateDOMSelection();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else {\n      this.$clearHighlight();\n    }\n  }\n\n  /**\n   * @internal\n   * Firefox has a strange behavior where pressing the down arrow key from\n   * above the table will move the caret after the table and then lexical\n   * will select the last cell instead of the first.\n   * We do still want to let the browser handle caret movement but we will\n   * use this property to \"tag\" the update so that we can recheck the\n   * selection after the event is processed.\n   */\n  setShouldCheckSelection() {\n    this.shouldCheckSelection = true;\n  }\n  /**\n   * @internal\n   */\n  getAndClearShouldCheckSelection() {\n    if (this.shouldCheckSelection) {\n      this.shouldCheckSelection = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @internal\n   * When handling mousemove events we track what the focus cell should be, but\n   * the DOM selection may end up somewhere else entirely. We don't have an elegant\n   * way to handle this after the DOM selection has been resolved in a\n   * SELECTION_CHANGE_COMMAND callback.\n   */\n  setNextFocus(nextFocus) {\n    this.nextFocus = nextFocus;\n  }\n\n  /** @internal */\n  getAndClearNextFocus() {\n    const {\n      nextFocus\n    } = this;\n    if (nextFocus !== null) {\n      this.nextFocus = null;\n    }\n    return nextFocus;\n  }\n\n  /** @internal */\n  updateDOMSelection() {\n    if (this.anchorCell !== null && this.focusCell !== null) {\n      const domSelection = getDOMSelection(this.editor._window);\n      // We are not using a native selection for tables, and if we\n      // set one then the reconciler will undo it.\n      // TODO - it would make sense to have one so that native\n      //        copy/paste worked. Right now we have to emulate with\n      //        keyboard events but it won't fire if trigged from the menu\n      if (domSelection && domSelection.rangeCount > 0) {\n        domSelection.removeAllRanges();\n      }\n    }\n  }\n  $setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    const {\n      tableNode\n    } = this.$lookup();\n    const cellX = cell.x;\n    const cellY = cell.y;\n    this.focusCell = cell;\n    if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n    } else if (cellX === this.focusX && cellY === this.focusY) {\n      return false;\n    }\n    this.focusX = cellX;\n    this.focusY = cellY;\n    if (this.isHighlightingCells) {\n      const focusTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n      if (this.tableSelection != null && this.anchorCellNodeKey != null && focusTableCellNode !== null) {\n        this.focusCellNodeKey = focusTableCellNode.getKey();\n        this.tableSelection = $createTableSelectionFrom(tableNode, this.$getAnchorTableCellOrThrow(), focusTableCellNode);\n        $setSelection(this.tableSelection);\n        editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        $updateDOMForSelection(editor, this.table, this.tableSelection);\n        return true;\n      }\n    }\n    return false;\n  }\n  $getAnchorTableCell() {\n    return this.anchorCellNodeKey ? $getNodeByKey(this.anchorCellNodeKey) : null;\n  }\n  $getAnchorTableCellOrThrow() {\n    const anchorTableCell = this.$getAnchorTableCell();\n    if (!(anchorTableCell !== null)) {\n      throw Error(`TableObserver anchorTableCell is null`);\n    }\n    return anchorTableCell;\n  }\n  $getFocusTableCell() {\n    return this.focusCellNodeKey ? $getNodeByKey(this.focusCellNodeKey) : null;\n  }\n  $getFocusTableCellOrThrow() {\n    const focusTableCell = this.$getFocusTableCell();\n    if (!(focusTableCell !== null)) {\n      throw Error(`TableObserver focusTableCell is null`);\n    }\n    return focusTableCell;\n  }\n  $setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    const {\n      tableNode\n    } = this.$lookup();\n    const anchorTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n    if (anchorTableCellNode !== null) {\n      const anchorNodeKey = anchorTableCellNode.getKey();\n      this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n      this.anchorCellNodeKey = anchorNodeKey;\n    }\n  }\n  $formatCells(type) {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection)) {\n      throw Error(`Expected Table selection`);\n    }\n    const formatSelection = $createRangeSelection();\n    const anchor = formatSelection.anchor;\n    const focus = formatSelection.focus;\n    const cellNodes = selection.getNodes().filter($isTableCellNode);\n    if (!(cellNodes.length > 0)) {\n      throw Error(`No table cells present`);\n    }\n    const paragraph = cellNodes[0].getFirstChild();\n    const alignFormatWith = $isParagraphNode(paragraph) ? paragraph.getFormatFlags(type, null) : null;\n    cellNodes.forEach(cellNode => {\n      anchor.set(cellNode.getKey(), 0, 'element');\n      focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n      formatSelection.formatText(type, alignFormatWith);\n    });\n    $setSelection(selection);\n    this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  $clearText() {\n    const {\n      editor\n    } = this;\n    const tableNode = $getNodeByKey(this.tableNodeKey);\n    if (!$isTableNode(tableNode)) {\n      throw new Error('Expected TableNode.');\n    }\n    const selection = $getSelection();\n    if (!$isTableSelection(selection)) {\n      throw Error(`Expected TableSelection`);\n    }\n    const selectedNodes = selection.getNodes().filter($isTableCellNode);\n    if (selectedNodes.length === this.table.columns * this.table.rows) {\n      tableNode.selectPrevious();\n      // Delete entire table\n      tableNode.remove();\n      return;\n    }\n    selectedNodes.forEach(cellNode => {\n      if ($isElementNode(cellNode)) {\n        const paragraphNode = $createParagraphNode();\n        const textNode = $createTextNode();\n        paragraphNode.append(textNode);\n        cellNode.append(paragraphNode);\n        cellNode.getChildren().forEach(child => {\n          if (child !== paragraphNode) {\n            child.remove();\n          }\n        });\n      }\n    });\n    $updateDOMForSelection(editor, this.table, null);\n    $setSelection(null);\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst isMouseDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction getTableElement(tableNode, dom) {\n  if (!dom) {\n    return dom;\n  }\n  const element = dom.nodeName === 'TABLE' ? dom : tableNode.getDOMSlot(dom).element;\n  if (!(element.nodeName === 'TABLE')) {\n    throw Error(`getTableElement: Expecting table in as DOM node for TableNode, not ${dom.nodeName}`);\n  }\n  return element;\n}\nfunction getEditorWindow(editor) {\n  return editor._window;\n}\nfunction $findParentTableCellNodeInTable(tableNode, node) {\n  for (let currentNode = node, lastTableCellNode = null; currentNode !== null; currentNode = currentNode.getParent()) {\n    if (tableNode.is(currentNode)) {\n      return lastTableCellNode;\n    } else if ($isTableCellNode(currentNode)) {\n      lastTableCellNode = currentNode;\n    }\n  }\n  return null;\n}\nconst ARROW_KEY_COMMANDS_WITH_DIRECTION = [[KEY_ARROW_DOWN_COMMAND, 'down'], [KEY_ARROW_UP_COMMAND, 'up'], [KEY_ARROW_LEFT_COMMAND, 'backward'], [KEY_ARROW_RIGHT_COMMAND, 'forward']];\nconst DELETE_TEXT_COMMANDS = [DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND];\nconst DELETE_KEY_COMMANDS = [KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND];\nfunction applyTableHandlers(tableNode, element, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  const editorWindow = getEditorWindow(editor);\n  if (!(rootElement !== null && editorWindow !== null)) {\n    throw Error(`applyTableHandlers: editor has no root element set`);\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const tableElement = getTableElement(tableNode, element);\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  tableObserver.listenersToRemove.add(() => detatchTableObserverFromTableElement(tableElement, tableObserver));\n  const createMouseHandlers = () => {\n    if (tableObserver.isSelecting) {\n      return;\n    }\n    const onMouseUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('mouseup', onMouseUp);\n      editorWindow.removeEventListener('mousemove', onMouseMove);\n    };\n    const onMouseMove = moveEvent => {\n      if (!isDOMNode(moveEvent.target)) {\n        return;\n      }\n      if (!isMouseDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n        tableObserver.isSelecting = false;\n        editorWindow.removeEventListener('mouseup', onMouseUp);\n        editorWindow.removeEventListener('mousemove', onMouseMove);\n        return;\n      }\n      const override = !tableElement.contains(moveEvent.target);\n      let focusCell = null;\n      if (!override) {\n        focusCell = getDOMCellFromTarget(moveEvent.target);\n      } else {\n        for (const el of document.elementsFromPoint(moveEvent.clientX, moveEvent.clientY)) {\n          focusCell = tableElement.contains(el) ? getDOMCellFromTarget(el) : null;\n          if (focusCell) {\n            break;\n          }\n        }\n      }\n      if (focusCell && (tableObserver.focusCell === null || focusCell.elem !== tableObserver.focusCell.elem)) {\n        tableObserver.setNextFocus({\n          focusCell,\n          override\n        });\n        editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n      }\n    };\n    tableObserver.isSelecting = true;\n    editorWindow.addEventListener('mouseup', onMouseUp, tableObserver.listenerOptions);\n    editorWindow.addEventListener('mousemove', onMouseMove, tableObserver.listenerOptions);\n  };\n  const onMouseDown = event => {\n    if (event.button !== 0 || !isDOMNode(event.target) || !editorWindow) {\n      return;\n    }\n    const targetCell = getDOMCellFromTarget(event.target);\n    if (targetCell !== null) {\n      editor.update(() => {\n        const prevSelection = $getPreviousSelection();\n        // We can't trust Firefox to do the right thing with the selection and\n        // we don't have a proper state machine to do this \"correctly\" but\n        // if we go ahead and make the table selection now it will work\n        if (IS_FIREFOX && event.shiftKey && $isSelectionInTable(prevSelection, tableNode) && ($isRangeSelection(prevSelection) || $isTableSelection(prevSelection))) {\n          const prevAnchorNode = prevSelection.anchor.getNode();\n          const prevAnchorCell = $findParentTableCellNodeInTable(tableNode, prevSelection.anchor.getNode());\n          if (prevAnchorCell) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCell));\n            tableObserver.$setFocusCellForSelection(targetCell);\n            stopEvent(event);\n          } else {\n            const newSelection = tableNode.isBefore(prevAnchorNode) ? tableNode.selectStart() : tableNode.selectEnd();\n            newSelection.anchor.set(prevSelection.anchor.key, prevSelection.anchor.offset, prevSelection.anchor.type);\n          }\n        } else {\n          tableObserver.$setAnchorCellForSelection(targetCell);\n        }\n      });\n    }\n    createMouseHandlers();\n  };\n  tableElement.addEventListener('mousedown', onMouseDown, tableObserver.listenerOptions);\n\n  // Clear selection when clicking outside of dom.\n  const mouseDownCallback = event => {\n    const target = event.target;\n    if (event.button !== 0 || !isDOMNode(target)) {\n      return;\n    }\n    editor.update(() => {\n      const selection = $getSelection();\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.$clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('mousedown', mouseDownCallback, tableObserver.listenerOptions);\n  for (const [command, direction] of ARROW_KEY_COMMANDS_WITH_DIRECTION) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, event => $handleArrowKey(editor, event, direction, tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ESCAPE_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = $findParentTableCellNodeInTable(tableNode, selection.focus.getNode());\n      if (focusCellNode !== null) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearText();\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findParentTableCellNodeInTable(tableNode, selection.anchor.getNode());\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.$clearText();\n        return true;\n      }\n      const nearestElementNode = $findMatchingParent(selection.anchor.getNode(), n => $isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && $findMatchingParent(nearestElementNode, n => $isElementNode(n) && $isTableCellNode(n.getParent()));\n      if (!$isElementNode(topLevelCellElementNode) || !$isElementNode(nearestElementNode)) {\n        return false;\n      }\n      if (command === DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  for (const command of DELETE_TEXT_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), COMMAND_PRIORITY_CRITICAL));\n  }\n  const $deleteCellHandler = event => {\n    const selection = $getSelection();\n    if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n      return false;\n    }\n\n    // If the selection is inside the table but should remove the whole table\n    // we expand the selection so that both the anchor and focus are outside\n    // the table and the editor's command listener will handle the delete\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    if (isAnchorInside !== isFocusInside) {\n      const tablePoint = isAnchorInside ? 'anchor' : 'focus';\n      const outerPoint = isAnchorInside ? 'focus' : 'anchor';\n      // Preserve the outer point\n      const {\n        key,\n        offset,\n        type\n      } = selection[outerPoint];\n      // Expand the selection around the table\n      const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? 'selectPrevious' : 'selectNext']();\n      // Restore the outer point of the selection\n      newSelection[outerPoint].set(key, offset, type);\n      // Let the base implementation handle the rest\n      return false;\n    }\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.$clearText();\n      return true;\n    }\n    return false;\n  };\n  for (const command of DELETE_KEY_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, $deleteCellHandler, COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(CUT_COMMAND, event => {\n    const selection = $getSelection();\n    if (selection) {\n      if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null, $getClipboardDataFromSelection(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ($isRangeSelection(selection)) {\n        selection.removeText();\n        return true;\n      }\n      return intercepted;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_TEXT_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$formatCells(payload);\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow + anchorCell.cell.__rowSpan - 1, focusCell.startRow + focusCell.cell.__rowSpan - 1);\n    const maxColumn = Math.max(anchorCell.startColumn + anchorCell.cell.__colSpan - 1, focusCell.startColumn + focusCell.cell.__colSpan - 1);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    const visited = new Set();\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        if (visited.has(cell)) {\n          continue;\n        }\n        visited.add(cell);\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ($isElementNode(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearHighlight();\n      return false;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [$createTextNode(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(KEY_TAB_COMMAND, event => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null || !tableNode.is($findTableNode(tableCellNode))) {\n        return false;\n      }\n      stopEvent(event);\n      $selectAdjacentCell(tableCellNode, event.shiftKey ? 'previous' : 'next');\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, selectionPayload => {\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = $isRangeSelection(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && $findMatchingParent(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor] = anchorAndFocus;\n    const newGrid = nodes[0];\n    const newGridRows = newGrid.getChildren();\n    const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n    const newRowCount = newGrid.getChildrenSize();\n    const gridCellNode = $findMatchingParent(anchor.getNode(), n => $isTableCellNode(n));\n    const gridRowNode = gridCellNode && $findMatchingParent(gridCellNode, n => $isTableRowNode(n));\n    const gridNode = gridRowNode && $findMatchingParent(gridRowNode, n => $isTableNode(n));\n    if (!$isTableCellNode(gridCellNode) || !$isTableRowNode(gridRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const startY = gridRowNode.getIndexWithinParent();\n    const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n    const startX = gridCellNode.getIndexWithinParent();\n    const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n    const fromX = Math.min(startX, stopX);\n    const fromY = Math.min(startY, stopY);\n    const toX = Math.max(startX, stopX);\n    const toY = Math.max(startY, stopY);\n    const gridRowNodes = gridNode.getChildren();\n    let newRowIdx = 0;\n    for (let r = fromY; r <= toY; r++) {\n      const currentGridRowNode = gridRowNodes[r];\n      if (!$isTableRowNode(currentGridRowNode)) {\n        return false;\n      }\n      const newGridRowNode = newGridRows[newRowIdx];\n      if (!$isTableRowNode(newGridRowNode)) {\n        return false;\n      }\n      const gridCellNodes = currentGridRowNode.getChildren();\n      const newGridCellNodes = newGridRowNode.getChildren();\n      let newColumnIdx = 0;\n      for (let c = fromX; c <= toX; c++) {\n        const currentGridCellNode = gridCellNodes[c];\n        if (!$isTableCellNode(currentGridCellNode)) {\n          return false;\n        }\n        const newGridCellNode = newGridCellNodes[newColumnIdx];\n        if (!$isTableCellNode(newGridCellNode)) {\n          return false;\n        }\n        const originalChildren = currentGridCellNode.getChildren();\n        newGridCellNode.getChildren().forEach(child => {\n          if ($isTextNode(child)) {\n            const paragraphNode = $createParagraphNode();\n            paragraphNode.append(child);\n            currentGridCellNode.append(child);\n          } else {\n            currentGridCellNode.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n        newColumnIdx++;\n      }\n      newRowIdx++;\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_CHANGE_COMMAND, () => {\n    const selection = $getSelection();\n    const prevSelection = $getPreviousSelection();\n    const nextFocus = tableObserver.getAndClearNextFocus();\n    if (nextFocus !== null) {\n      const {\n        focusCell\n      } = nextFocus;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        if (focusCell.x === tableObserver.focusX && focusCell.y === tableObserver.focusY) {\n          // The selection is already the correct table selection\n          return false;\n        } else {\n          tableObserver.$setFocusCellForSelection(focusCell);\n          return true;\n        }\n      } else if (focusCell !== tableObserver.anchorCell && $isSelectionInTable(selection, tableNode)) {\n        // The selection has crossed cells\n        tableObserver.$setFocusCellForSelection(focusCell);\n        return true;\n      }\n    }\n    const shouldCheckSelection = tableObserver.getAndClearShouldCheckSelection();\n    // If they pressed the down arrow with the selection outside of the\n    // table, and then the selection ends up in the table but not in the\n    // first cell, then move the selection to the first cell.\n    if (shouldCheckSelection && $isRangeSelection(prevSelection) && $isRangeSelection(selection) && selection.isCollapsed()) {\n      const anchor = selection.anchor.getNode();\n      const firstRow = tableNode.getFirstChild();\n      const anchorCell = $findCellNode(anchor);\n      if (anchorCell !== null && $isTableRowNode(firstRow)) {\n        const firstCell = firstRow.getFirstChild();\n        if ($isTableCellNode(firstCell) && tableNode.is($findMatchingParent(anchorCell, node => node.is(tableNode) || node.is(firstCell)))) {\n          // The selection moved to the table, but not in the first cell\n          firstCell.selectStart();\n          return true;\n        }\n      }\n    }\n    if ($isRangeSelection(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartiallyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartiallyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        } else if (isAnchorInside) {\n          const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          /**\n           * If isBackward, set the anchor to be at the end of the table so that when the cursor moves outside of\n           * the table in the backward direction, the entire table will be selected from its end.\n           * Otherwise, if forward, set the anchor to be at the start of the table so that when the focus is dragged\n           * outside th end of the table, it will start from the beginning of the table.\n           */\n          newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, 'element');\n        }\n        $setSelection(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into table selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, anchorCellNode));\n          tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = getDOMSelection(editorWindow);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = $getNearestNodeFromDOMNode(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.isParentOf(focusNode);\n        const anchorNode = $getNearestNodeFromDOMNode(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.isParentOf(anchorNode);\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = $createRangeSelectionFromDom(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction detatchTableObserverFromTableElement(tableElement, tableObserver) {\n  if (getTableObserverFromTableElement(tableElement) === tableObserver) {\n    delete tableElement[LEXICAL_ELEMENT_KEY];\n  }\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  if (!(getTableObserverFromTableElement(tableElement) === null)) {\n    throw Error(`tableElement already has an attached TableObserver`);\n  }\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY] || null;\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getTable(tableNode, dom) {\n  const tableElement = getTableElement(tableNode, dom);\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.querySelector('tr');\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = $getNearestNodeFromDOMNode(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.$disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.$enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nfunction $selectAdjacentCell(tableCellNode, direction) {\n  const siblingMethod = direction === 'next' ? 'getNextSibling' : 'getPreviousSibling';\n  const childMethod = direction === 'next' ? 'getFirstChild' : 'getLastChild';\n  const sibling = tableCellNode[siblingMethod]();\n  if ($isElementNode(sibling)) {\n    return sibling.selectEnd();\n  }\n  const parentRow = $findMatchingParent(tableCellNode, $isTableRowNode);\n  if (!(parentRow !== null)) {\n    throw Error(`selectAdjacentCell: Cell not in table row`);\n  }\n  for (let nextRow = parentRow[siblingMethod](); $isTableRowNode(nextRow); nextRow = nextRow[siblingMethod]()) {\n    const child = nextRow[childMethod]();\n    if ($isElementNode(child)) {\n      return child.selectEnd();\n    }\n  }\n  const parentTable = $findMatchingParent(parentRow, $isTableNode);\n  if (!(parentTable !== null)) {\n    throw Error(`selectAdjacentCell: Row not in table`);\n  }\n  return direction === 'next' ? parentTable.selectNext() : parentTable.selectPrevious();\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nfunction getCorner(rect, cellValue) {\n  let colName;\n  let rowName;\n  if (cellValue.startColumn === rect.minColumn) {\n    colName = 'minColumn';\n  } else if (cellValue.startColumn + cellValue.cell.__colSpan - 1 === rect.maxColumn) {\n    colName = 'maxColumn';\n  } else {\n    return null;\n  }\n  if (cellValue.startRow === rect.minRow) {\n    rowName = 'minRow';\n  } else if (cellValue.startRow + cellValue.cell.__rowSpan - 1 === rect.maxRow) {\n    rowName = 'maxRow';\n  } else {\n    return null;\n  }\n  return [colName, rowName];\n}\nfunction getCornerOrThrow(rect, cellValue) {\n  const corner = getCorner(rect, cellValue);\n  if (!(corner !== null)) {\n    throw Error(`getCornerOrThrow: cell ${cellValue.cell.getKey()} is not at a corner of rect`);\n  }\n  return corner;\n}\nfunction oppositeCorner([colName, rowName]) {\n  return [colName === 'minColumn' ? 'maxColumn' : 'minColumn', rowName === 'minRow' ? 'maxRow' : 'minRow'];\n}\nfunction cellAtCornerOrThrow(tableMap, rect, [colName, rowName]) {\n  const rowNum = rect[rowName];\n  const rowMap = tableMap[rowNum];\n  if (!(rowMap !== undefined)) {\n    throw Error(`cellAtCornerOrThrow: ${rowName} = ${String(rowNum)} missing in tableMap`);\n  }\n  const colNum = rect[colName];\n  const cell = rowMap[colNum];\n  if (!(cell !== undefined)) {\n    throw Error(`cellAtCornerOrThrow: ${colName} = ${String(colNum)} missing in tableMap`);\n  }\n  return cell;\n}\nfunction $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue) {\n  // We are sure that the focus now either contracts or expands the rect\n  // but both the anchor and focus might be moved to ensure a rectangle\n  // given a potentially ragged merge shape\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorCorner = getCorner(rect, anchorCellValue);\n  if (anchorCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, anchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(anchorCorner))];\n  }\n  const newFocusCorner = getCorner(rect, newFocusCellValue);\n  if (newFocusCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newFocusCorner)), cellAtCornerOrThrow(tableMap, rect, newFocusCorner)];\n  }\n  // TODO this doesn't have to be arbitrary, use the closest corner instead\n  const newAnchorCorner = ['minColumn', 'minRow'];\n  return [cellAtCornerOrThrow(tableMap, rect, newAnchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newAnchorCorner))];\n}\nfunction $adjustFocusInDirection(tableObserver, tableMap, anchorCellValue, focusCellValue, direction) {\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, focusCellValue);\n  const spans = $computeTableCellRectSpans(tableMap, rect);\n  const {\n    topSpan,\n    leftSpan,\n    bottomSpan,\n    rightSpan\n  } = spans;\n  const anchorCorner = getCornerOrThrow(rect, anchorCellValue);\n  const [focusColumn, focusRow] = oppositeCorner(anchorCorner);\n  let fCol = rect[focusColumn];\n  let fRow = rect[focusRow];\n  if (direction === 'forward') {\n    fCol += focusColumn === 'maxColumn' ? 1 : leftSpan;\n  } else if (direction === 'backward') {\n    fCol -= focusColumn === 'minColumn' ? 1 : rightSpan;\n  } else if (direction === 'down') {\n    fRow += focusRow === 'maxRow' ? 1 : topSpan;\n  } else if (direction === 'up') {\n    fRow -= focusRow === 'minRow' ? 1 : bottomSpan;\n  }\n  const targetRowMap = tableMap[fRow];\n  if (targetRowMap === undefined) {\n    return false;\n  }\n  const newFocusCellValue = targetRowMap[fCol];\n  if (newFocusCellValue === undefined) {\n    return false;\n  }\n  // We can be certain that anchorCellValue and newFocusCellValue are\n  // contained within the desired selection, but we are not certain if\n  // they need to be expanded or not to maintain a rectangular shape\n  const [finalAnchorCell, finalFocusCell] = $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalAnchorCell.cell);\n  const focusDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalFocusCell.cell);\n  tableObserver.$setAnchorCellForSelection(anchorDOM);\n  tableObserver.$setFocusCellForSelection(focusDOM, true);\n  return true;\n}\nfunction $isSelectionInTable(selection, tableNode) {\n  if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const editorThemeClasses = editor._config.theme;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  addClassNamesToElement(element, editorThemeClasses.tableCellSelected);\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const editorThemeClasses = editor._config.theme;\n  removeClassNamesFromElement(element, editorThemeClasses.tableCellSelected);\n}\nfunction $findCellNode(node) {\n  const cellNode = $findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = $findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $getBlockParentIfFirstNode(node) {\n  for (let prevNode = node, currentNode = node; currentNode !== null; prevNode = currentNode, currentNode = currentNode.getParent()) {\n    if ($isElementNode(currentNode)) {\n      if (currentNode !== prevNode && currentNode.getFirstChild() !== prevNode) {\n        // Not the first child or the initial node\n        return null;\n      } else if (!currentNode.isInline()) {\n        return currentNode;\n      }\n    }\n  }\n  return null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = $getSelection();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ($isRangeSelection(selection)) {\n      if (direction === 'backward') {\n        if (selection.focus.offset > 0) {\n          return false;\n        }\n        const parentNode = $getBlockParentIfFirstNode(selection.focus.getNode());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        if (event.shiftKey) {\n          selection.focus.set(siblingNode.getParentOrThrow().getKey(), siblingNode.getIndexWithinParent(), 'element');\n        } else {\n          siblingNode.selectEnd();\n        }\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        const isTableUnselect = !selection.isCollapsed() && (direction === 'up' && !selection.isBackward() || direction === 'down' && selection.isBackward());\n        if (isTableUnselect) {\n          let focusParentNode = $findMatchingParent(focusNode, n => $isTableNode(n));\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = $findMatchingParent(focusParentNode, $isTableNode);\n          }\n          if (focusParentNode !== tableNode) {\n            return false;\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if (!sibling) {\n            return false;\n          }\n          let newOffset = 0;\n          if (direction === 'up') {\n            if ($isElementNode(sibling)) {\n              newOffset = sibling.getChildrenSize();\n            }\n          }\n          let newFocusNode = sibling;\n          if (direction === 'up') {\n            if ($isElementNode(sibling)) {\n              const lastCell = sibling.getLastChild();\n              newFocusNode = lastCell ? lastCell : sibling;\n              newOffset = $isTextNode(newFocusNode) ? newFocusNode.getTextContentSize() : 0;\n            }\n          }\n          const newSelection = selection.clone();\n          newSelection.focus.set(newFocusNode.getKey(), newOffset, $isTextNode(newFocusNode) ? 'text' : 'element');\n          $setSelection(newSelection);\n          stopEvent(event);\n          return true;\n        } else if ($isRootOrShadowRoot(focusNode)) {\n          const selectedNode = direction === 'up' ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = $findParentTableCellNodeInTable(tableNode, selectedNode);\n            if (tableCellNode !== null) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.$setAnchorCellForSelection(firstCellDOM);\n              tableObserver.$setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          let focusParentNode = $findMatchingParent(focusNode, n => $isElementNode(n) && !n.isInline());\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = $findMatchingParent(focusParentNode, $isTableNode);\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            stopEvent(event);\n            $setSelection(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    if (direction === 'down' && $isScrollableTablesActive(editor)) {\n      // Enable Firefox workaround\n      tableObserver.setShouldCheckSelection();\n    }\n    return false;\n  }\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n    const anchorCellTable = $findTableNode(anchorCellNode);\n    if (anchorCellTable !== tableNode && anchorCellTable != null) {\n      const anchorCellTableElement = getTableElement(anchorCellTable, editor.getElementByKey(anchorCellTable.getKey()));\n      if (anchorCellTableElement != null) {\n        tableObserver.table = getTable(anchorCellTable, anchorCellTableElement);\n        return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n      }\n    }\n    if (direction === 'backward' || direction === 'forward') {\n      const anchorType = anchor.type;\n      const anchorOffset = anchor.offset;\n      const anchorNode = anchor.getNode();\n      if (!anchorNode) {\n        return false;\n      }\n      const selectedNodes = selection.getNodes();\n      if (selectedNodes.length === 1 && $isDecoratorNode(selectedNodes[0])) {\n        return false;\n      }\n      if (isExitingTableAnchor(anchorType, anchorOffset, anchorNode, direction)) {\n        return $handleTableExit(event, anchorNode, anchorCellNode, tableNode, direction);\n      }\n      return false;\n    }\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n    let edgeSelectionRect;\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = getDOMSelection(getEditorWindow(editor));\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n    if (edgeChild == null) {\n      return false;\n    }\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n    if (edgeChildDOM == null) {\n      return false;\n    }\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n      if (event.shiftKey) {\n        const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n        tableObserver.$setAnchorCellForSelection(cell);\n        tableObserver.$setFocusCellForSelection(cell, true);\n      } else {\n        return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n      }\n      return true;\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    if (!$isTableNode(tableNodeFromSelection)) {\n      throw Error(`$handleArrowKey: TableSelection.getNodes()[0] expected to be TableNode`);\n    }\n    const tableElement = getTableElement(tableNodeFromSelection, editor.getElementByKey(tableNodeFromSelection.getKey()));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.$updateTableTableSelection(selection);\n    const grid = getTable(tableNodeFromSelection, tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.$setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const [tableMap, anchorValue, focusValue] = $computeTableMap(tableNode, anchorCellNode, focusCellNode);\n      return $adjustFocusInDirection(tableObserver, tableMap, anchorValue, focusValue, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction isExitingTableAnchor(type, offset, anchorNode, direction) {\n  return isExitingTableElementAnchor(type, anchorNode, direction) || $isExitingTableTextAnchor(type, offset, anchorNode, direction);\n}\nfunction isExitingTableElementAnchor(type, anchorNode, direction) {\n  return type === 'element' && (direction === 'backward' ? anchorNode.getPreviousSibling() === null : anchorNode.getNextSibling() === null);\n}\nfunction $isExitingTableTextAnchor(type, offset, anchorNode, direction) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return false;\n  }\n  const hasValidOffset = direction === 'backward' ? offset === 0 : offset === anchorNode.getTextContentSize();\n  return type === 'text' && hasValidOffset && (direction === 'backward' ? parentNode.getPreviousSibling() === null : parentNode.getNextSibling() === null);\n}\nfunction $handleTableExit(event, anchorNode, anchorCellNode, tableNode, direction) {\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  if (!isExitingCell(tableMap, cellValue, direction)) {\n    return false;\n  }\n  const toNode = $getExitingToNode(anchorNode, direction, tableNode);\n  if (!toNode || $isTableNode(toNode)) {\n    return false;\n  }\n  stopEvent(event);\n  if (direction === 'backward') {\n    toNode.selectEnd();\n  } else {\n    toNode.selectStart();\n  }\n  return true;\n}\nfunction isExitingCell(tableMap, cellValue, direction) {\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startColumn,\n    startRow\n  } = cellValue;\n  return direction === 'backward' ? startColumn === firstCell.startColumn && startRow === firstCell.startRow : startColumn === lastCell.startColumn && startRow === lastCell.startRow;\n}\nfunction $getExitingToNode(anchorNode, direction, tableNode) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return undefined;\n  }\n  const anchorSibling = direction === 'backward' ? parentNode.getPreviousSibling() : parentNode.getNextSibling();\n  return anchorSibling && $isTableNode(anchorSibling) ? anchorSibling : direction === 'backward' ? tableNode.getPreviousSibling() : tableNode.getNextSibling();\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = $createParagraphNode();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = getDOMSelection(getEditorWindow(editor));\n  if (!domSelection) {\n    return undefined;\n  }\n  const domAnchorNode = domSelection.anchorNode;\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()));\n  // We are only interested in the scenario where the\n  // native selection anchor is:\n  // - at or inside the table's parent DOM\n  // - and NOT at or inside the table DOM\n  // It may be adjacent to the table DOM (e.g. in a wrapper)\n  if (!domAnchorNode || !tableNodeParentDOM || !tableElement || !tableNodeParentDOM.contains(domAnchorNode) || tableElement.contains(domAnchorNode)) {\n    return undefined;\n  }\n  const anchorCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = $findMatchingParent(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\nfunction $getObserverCellFromCellNodeOrThrow(tableObserver, tableCellNode) {\n  const {\n    tableNode\n  } = tableObserver.$lookup();\n  const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n  return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n}\nfunction $getNearestTableCellInTableFromDOMNode(tableNode, startingDOM, editorState) {\n  return $findParentTableCellNodeInTable(tableNode, $getNearestNodeFromDOMNode(startingDOM, editorState));\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction updateColgroup(dom, config, colCount, colWidths) {\n  const colGroup = dom.querySelector('colgroup');\n  if (!colGroup) {\n    return;\n  }\n  const cols = [];\n  for (let i = 0; i < colCount; i++) {\n    const col = document.createElement('col');\n    const width = colWidths && colWidths[i];\n    if (width) {\n      col.style.width = `${width}px`;\n    }\n    cols.push(col);\n  }\n  colGroup.replaceChildren(...cols);\n}\nfunction setRowStriping(dom, config, rowStriping) {\n  if (rowStriping) {\n    addClassNamesToElement(dom, config.theme.tableRowStriping);\n    dom.setAttribute('data-lexical-row-striping', 'true');\n  } else {\n    removeClassNamesFromElement(dom, config.theme.tableRowStriping);\n    dom.removeAttribute('data-lexical-row-striping');\n  }\n}\nconst scrollableEditors = new WeakSet();\nfunction $isScrollableTablesActive(editor = $getEditor()) {\n  return scrollableEditors.has(editor);\n}\nfunction setScrollableTablesActive(editor, active) {\n  if (active) {\n    if (!editor._config.theme.tableScrollableWrapper) {\n      console.warn('TableNode: hasHorizontalScroll is active but theme.tableScrollableWrapper is not defined.');\n    }\n    scrollableEditors.add(editor);\n  } else {\n    scrollableEditors.delete(editor);\n  }\n}\n\n/** @noInheritDoc */\nclass TableNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'table';\n  }\n  getColWidths() {\n    const self = this.getLatest();\n    return self.__colWidths;\n  }\n  setColWidths(colWidths) {\n    const self = this.getWritable();\n    // NOTE: Node properties should be immutable. Freeze to prevent accidental mutation.\n    self.__colWidths = colWidths !== undefined && true ? Object.freeze(colWidths) : colWidths;\n    return self;\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__colWidths = prevNode.__colWidths;\n    this.__rowStriping = prevNode.__rowStriping;\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setRowStriping(serializedNode.rowStriping || false).setColWidths(serializedNode.colWidths);\n  }\n  constructor(key) {\n    super(key);\n    this.__rowStriping = false;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colWidths: this.getColWidths(),\n      rowStriping: this.__rowStriping ? this.__rowStriping : undefined\n    };\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  getDOMSlot(element) {\n    const tableElement = element.nodeName !== 'TABLE' && element.querySelector('table') || element;\n    if (!(tableElement.nodeName === 'TABLE')) {\n      throw Error(`TableNode.getDOMSlot: createDOM() did not return a table`);\n    }\n    return super.getDOMSlot(tableElement).withAfter(tableElement.querySelector('colgroup'));\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    const colGroup = document.createElement('colgroup');\n    tableElement.appendChild(colGroup);\n    updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());\n    setDOMUnmanaged(colGroup);\n    addClassNamesToElement(tableElement, config.theme.table);\n    if (this.__rowStriping) {\n      setRowStriping(tableElement, config, true);\n    }\n    if ($isScrollableTablesActive(editor)) {\n      const wrapperElement = document.createElement('div');\n      const classes = config.theme.tableScrollableWrapper;\n      if (classes) {\n        addClassNamesToElement(wrapperElement, classes);\n      } else {\n        wrapperElement.style.cssText = 'overflow-x: auto;';\n      }\n      wrapperElement.appendChild(tableElement);\n      return wrapperElement;\n    }\n    return tableElement;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__rowStriping !== this.__rowStriping) {\n      setRowStriping(dom, config, this.__rowStriping);\n    }\n    updateColgroup(dom, config, this.getColumnCount(), this.getColWidths());\n    return false;\n  }\n  exportDOM(editor) {\n    const superExport = super.exportDOM(editor);\n    const {\n      element\n    } = superExport;\n    return {\n      after: tableElement => {\n        if (superExport.after) {\n          tableElement = superExport.after(tableElement);\n        }\n        if (isHTMLElement$1(tableElement) && tableElement.nodeName !== 'TABLE') {\n          tableElement = tableElement.querySelector('table');\n        }\n        if (!isHTMLElement$1(tableElement)) {\n          return null;\n        }\n\n        // Scan the table map to build a map of table cell key to the columns it needs\n        const [tableMap] = $computeTableMapSkipCellCheck(this, null, null);\n        const cellValues = new Map();\n        for (const mapRow of tableMap) {\n          for (const mapValue of mapRow) {\n            const key = mapValue.cell.getKey();\n            if (!cellValues.has(key)) {\n              cellValues.set(key, {\n                colSpan: mapValue.cell.getColSpan(),\n                startColumn: mapValue.startColumn\n              });\n            }\n          }\n        }\n\n        // scan the DOM to find the table cell keys that were used and mark those columns\n        const knownColumns = new Set();\n        for (const cellDOM of tableElement.querySelectorAll(':scope > tr > [data-temporary-table-cell-lexical-key]')) {\n          const key = cellDOM.getAttribute('data-temporary-table-cell-lexical-key');\n          if (key) {\n            const cellSpan = cellValues.get(key);\n            cellDOM.removeAttribute('data-temporary-table-cell-lexical-key');\n            if (cellSpan) {\n              cellValues.delete(key);\n              for (let i = 0; i < cellSpan.colSpan; i++) {\n                knownColumns.add(i + cellSpan.startColumn);\n              }\n            }\n          }\n        }\n\n        // Compute the colgroup and columns in the export\n        const colGroup = tableElement.querySelector(':scope > colgroup');\n        if (colGroup) {\n          // Only include the <col /> for rows that are in the output\n          const cols = Array.from(tableElement.querySelectorAll(':scope > colgroup > col')).filter((dom, i) => knownColumns.has(i));\n          colGroup.replaceChildren(...cols);\n        }\n\n        // Wrap direct descendant rows in a tbody for export\n        const rows = tableElement.querySelectorAll(':scope > tr');\n        if (rows.length > 0) {\n          const tBody = document.createElement('tbody');\n          for (const row of rows) {\n            tBody.appendChild(row);\n          }\n          tableElement.append(tBody);\n        }\n        return tableElement;\n      },\n      element: isHTMLElement$1(element) && element.nodeName !== 'TABLE' ? element.querySelector('table') : element\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      for (let x = 0; x < row.length; x++) {\n        const cell = row[x];\n        if (cell == null) {\n          continue;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = $getNearestTableCellInTableFromDOMNode(this, elem);\n        if (cellNode !== null && tableCellNode.is(cellNode)) {\n          return {\n            x,\n            y\n          };\n        }\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = $getNearestNodeFromDOMNode(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  getRowStriping() {\n    return Boolean(this.getLatest().__rowStriping);\n  }\n  setRowStriping(newRowStriping) {\n    const self = this.getWritable();\n    self.__rowStriping = newRowStriping;\n    return self;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n  getColumnCount() {\n    const firstRow = this.getFirstChild();\n    if (!firstRow) {\n      return 0;\n    }\n    let columnCount = 0;\n    firstRow.getChildren().forEach(cell => {\n      if ($isTableCellNode(cell)) {\n        columnCount += cell.getColSpan();\n      }\n    });\n    return columnCount;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (!(tableElement !== null)) {\n    throw Error(`$getElementForTableNode: Table Element Not Found`);\n  }\n  return getTable(tableNode, tableElement);\n}\nfunction $convertTableElement(domNode) {\n  const tableNode = $createTableNode();\n  if (domNode.hasAttribute('data-lexical-row-striping')) {\n    tableNode.setRowStriping(true);\n  }\n  const colGroup = domNode.querySelector(':scope > colgroup');\n  if (colGroup) {\n    let columns = [];\n    for (const col of colGroup.querySelectorAll(':scope > col')) {\n      let width = col.style.width || '';\n      if (!PIXEL_VALUE_REG_EXP.test(width)) {\n        // Also support deprecated width attribute for google docs\n        width = col.getAttribute('width') || '';\n        if (!/^\\d+$/.test(width)) {\n          columns = undefined;\n          break;\n        }\n      }\n      columns.push(parseFloat(width));\n    }\n    if (columns) {\n      tableNode.setColWidths(columns);\n    }\n  }\n  return {\n    after: children => $descendantsMatching(children, $isTableRowNode),\n    node: tableNode\n  };\n}\nfunction $createTableNode() {\n  return $applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $insertTableCommandListener({\n  rows,\n  columns,\n  includeHeaders\n}) {\n  const tableNode = $createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);\n  $insertNodeToNearestRoot(tableNode);\n  const firstDescendant = tableNode.getFirstDescendant();\n  if ($isTextNode(firstDescendant)) {\n    firstDescendant.select();\n  }\n  return true;\n}\nfunction $tableCellTransform(node) {\n  if (!$isTableRowNode(node.getParent())) {\n    // TableCellNode must be a child of TableRowNode.\n    node.remove();\n  } else if (node.isEmpty()) {\n    // TableCellNode should never be empty\n    node.append($createParagraphNode());\n  }\n}\nfunction $tableRowTransform(node) {\n  if (!$isTableNode(node.getParent())) {\n    // TableRowNode must be a child of TableNode.\n    // TODO: Future support of tbody/thead/tfoot may change this\n    node.remove();\n  } else {\n    $unwrapAndFilterDescendants(node, $isTableCellNode);\n  }\n}\nfunction $tableTransform(node) {\n  // TableRowNode is the only valid child for TableNode\n  // TODO: Future support of tbody/thead/tfoot/caption may change this\n  $unwrapAndFilterDescendants(node, $isTableRowNode);\n  const [gridMap] = $computeTableMapSkipCellCheck(node, null, null);\n  const maxRowLength = gridMap.reduce((curLength, row) => {\n    return Math.max(curLength, row.length);\n  }, 0);\n  const rowNodes = node.getChildren();\n  for (let i = 0; i < gridMap.length; ++i) {\n    const rowNode = rowNodes[i];\n    if (!rowNode) {\n      continue;\n    }\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`TablePlugin: Expecting all children of TableNode to be TableRowNode, found ${rowNode.constructor.name} (type ${rowNode.getType()})`);\n    }\n    const rowLength = gridMap[i].reduce((acc, cell) => cell ? 1 + acc : acc, 0);\n    if (rowLength === maxRowLength) {\n      continue;\n    }\n    for (let j = rowLength; j < maxRowLength; ++j) {\n      // TODO: inherit header state from another header or body\n      const newCell = $createTableCellNode();\n      newCell.append($createParagraphNode());\n      rowNode.append(newCell);\n    }\n  }\n}\n\n/**\n * Register a transform to ensure that all TableCellNode have a colSpan and rowSpan of 1.\n * This should only be registered when you do not want to support merged cells.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTableCellUnmergeTransform(editor) {\n  return editor.registerNodeTransform(TableCellNode, node => {\n    if (node.getColSpan() > 1 || node.getRowSpan() > 1) {\n      // When we have rowSpan we have to map the entire Table to understand where the new Cells\n      // fit best; let's analyze all Cells at once to save us from further transform iterations\n      const [,, gridNode] = $getNodeTriplet(node);\n      const [gridMap] = $computeTableMap(gridNode, node, node);\n      // TODO this function expects Tables to be normalized. Look into this once it exists\n      const rowsCount = gridMap.length;\n      const columnsCount = gridMap[0].length;\n      let row = gridNode.getFirstChild();\n      if (!$isTableRowNode(row)) {\n        throw Error(`Expected TableNode first child to be a RowNode`);\n      }\n      const unmerged = [];\n      for (let i = 0; i < rowsCount; i++) {\n        if (i !== 0) {\n          row = row.getNextSibling();\n          if (!$isTableRowNode(row)) {\n            throw Error(`Expected TableNode first child to be a RowNode`);\n          }\n        }\n        let lastRowCell = null;\n        for (let j = 0; j < columnsCount; j++) {\n          const cellMap = gridMap[i][j];\n          const cell = cellMap.cell;\n          if (cellMap.startRow === i && cellMap.startColumn === j) {\n            lastRowCell = cell;\n            unmerged.push(cell);\n          } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {\n            if (!$isTableCellNode(cell)) {\n              throw Error(`Expected TableNode cell to be a TableCellNode`);\n            }\n            const newCell = $createTableCellNode(cell.__headerState);\n            if (lastRowCell !== null) {\n              lastRowCell.insertAfter(newCell);\n            } else {\n              $insertFirst$1(row, newCell);\n            }\n          }\n        }\n      }\n      for (const cell of unmerged) {\n        cell.setColSpan(1);\n        cell.setRowSpan(1);\n      }\n    }\n  });\n}\nfunction registerTableSelectionObserver(editor, hasTabHandler = true) {\n  const tableSelections = new Map();\n  const initializeTableNode = (tableNode, nodeKey, dom) => {\n    const tableElement = getTableElement(tableNode, dom);\n    const tableSelection = applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);\n    tableSelections.set(nodeKey, [tableSelection, tableElement]);\n  };\n  const unregisterMutationListener = editor.registerMutationListener(TableNode, nodeMutations => {\n    editor.getEditorState().read(() => {\n      for (const [nodeKey, mutation] of nodeMutations) {\n        const tableSelection = tableSelections.get(nodeKey);\n        if (mutation === 'created' || mutation === 'updated') {\n          const {\n            tableNode,\n            tableElement\n          } = $getTableAndElementByKey(nodeKey);\n          if (tableSelection === undefined) {\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          } else if (tableElement !== tableSelection[1]) {\n            // The update created a new DOM node, destroy the existing TableObserver\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          }\n        } else if (mutation === 'destroyed') {\n          if (tableSelection !== undefined) {\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n          }\n        }\n      }\n    }, {\n      editor\n    });\n  }, {\n    skipInitialization: false\n  });\n  return () => {\n    unregisterMutationListener();\n    // Hook might be called multiple times so cleaning up tables listeners as well,\n    // as it'll be reinitialized during recurring call\n    for (const [, [tableSelection]] of tableSelections) {\n      tableSelection.removeListeners();\n    }\n  };\n}\n\n/**\n * Register the INSERT_TABLE_COMMAND listener and the table integrity transforms. The\n * table selection observer should be registered separately after this with\n * {@link registerTableSelectionObserver}.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTablePlugin(editor) {\n  if (!editor.hasNodes([TableNode])) {\n    {\n      throw Error(`TablePlugin: TableNode is not registered on editor`);\n    }\n  }\n  return mergeRegister(editor.registerCommand(INSERT_TABLE_COMMAND, $insertTableCommandListener, COMMAND_PRIORITY_EDITOR), editor.registerNodeTransform(TableNode, $tableTransform), editor.registerNodeTransform(TableRowNode, $tableRowTransform), editor.registerNodeTransform(TableCellNode, $tableCellTransform));\n}\nexport { $computeTableMap, $computeTableMapSkipCellCheck, $createTableCellNode, $createTableNode, $createTableNodeWithDimensions, $createTableRowNode, $createTableSelection, $deleteTableColumn, $deleteTableColumn__EXPERIMENTAL, $deleteTableRow__EXPERIMENTAL, $findCellNode, $findTableNode, $getElementForTableNode, $getNodeTriplet, $getTableAndElementByKey, $getTableCellNodeFromLexicalNode, $getTableCellNodeRect, $getTableColumnIndexFromTableCellNode, $getTableNodeFromLexicalNodeOrThrow, $getTableRowIndexFromTableCellNode, $getTableRowNodeFromTableCellNodeOrThrow, $insertTableColumn, $insertTableColumn__EXPERIMENTAL, $insertTableRow, $insertTableRow__EXPERIMENTAL, $isScrollableTablesActive, $isTableCellNode, $isTableNode, $isTableRowNode, $isTableSelection, $removeTableRowAtIndex, $unmergeCell, INSERT_TABLE_COMMAND, TableCellHeaderStates, TableCellNode, TableNode, TableObserver, TableRowNode, applyTableHandlers, getDOMCellFromTarget, getTableElement, getTableObserverFromTableElement, registerTableCellUnmergeTransform, registerTablePlugin, registerTableSelectionObserver, setScrollableTablesActive };","map":{"version":3,"names":["addClassNamesToElement","$descendantsMatching","$findMatchingParent","removeClassNamesFromElement","objectKlassEquals","isHTMLElement","isHTMLElement$1","$insertFirst","$insertFirst$1","mergeRegister","$insertNodeToNearestRoot","$unwrapAndFilterDescendants","ElementNode","$createParagraphNode","$isElementNode","$isLineBreakNode","$isTextNode","$applyNodeReplacement","createCommand","$createTextNode","$getSelection","$isRangeSelection","$createPoint","$isParagraphNode","$normalizeSelection__EXPERIMENTAL","isCurrentlyReadOnlyMode","TEXT_TYPE_TO_FORMAT","$getNodeByKey","$getEditor","$setSelection","SELECTION_CHANGE_COMMAND","getDOMSelection","$createRangeSelection","COMMAND_PRIORITY_HIGH","KEY_ESCAPE_COMMAND","COMMAND_PRIORITY_CRITICAL","CUT_COMMAND","FORMAT_TEXT_COMMAND","FORMAT_ELEMENT_COMMAND","CONTROLLED_TEXT_INSERTION_COMMAND","KEY_TAB_COMMAND","FOCUS_COMMAND","SELECTION_INSERT_CLIPBOARD_NODES_COMMAND","$getPreviousSelection","$getNearestNodeFromDOMNode","$createRangeSelectionFromDom","INSERT_PARAGRAPH_COMMAND","$isRootOrShadowRoot","$isDecoratorNode","KEY_ARROW_DOWN_COMMAND","KEY_ARROW_UP_COMMAND","KEY_ARROW_LEFT_COMMAND","KEY_ARROW_RIGHT_COMMAND","DELETE_WORD_COMMAND","DELETE_LINE_COMMAND","DELETE_CHARACTER_COMMAND","KEY_BACKSPACE_COMMAND","KEY_DELETE_COMMAND","isDOMNode","setDOMUnmanaged","COMMAND_PRIORITY_EDITOR","copyToClipboard","$getClipboardDataFromSelection","PIXEL_VALUE_REG_EXP","COLUMN_WIDTH","TableCellHeaderStates","BOTH","COLUMN","NO_STATUS","ROW","TableCellNode","getType","clone","node","__headerState","__colSpan","__width","__key","afterCloneFrom","__rowSpan","__backgroundColor","importDOM","td","conversion","$convertTableCellNodeElement","priority","th","importJSON","serializedNode","$createTableCellNode","updateFromJSON","setHeaderStyles","headerState","setColSpan","colSpan","setRowSpan","rowSpan","setWidth","width","undefined","setBackgroundColor","backgroundColor","constructor","key","createDOM","config","element","document","createElement","getTag","style","theme","tableCell","hasHeader","tableCellHeader","exportDOM","editor","output","setAttribute","getKey","border","getWidth","verticalAlign","textAlign","exportJSON","getBackgroundColor","getColSpan","getLatest","self","getWritable","getRowSpan","mask","getHeaderStyles","newBackgroundColor","toggleHeaderStyle","headerStateToToggle","hasHeaderState","updateDOM","prevNode","isShadowRoot","collapseAtStart","canBeEmpty","canIndent","domNode","domNode_","nodeName","toLowerCase","test","parseFloat","tableCellNode","textDecoration","split","hasBoldFontWeight","fontWeight","hasLinethroughTextDecoration","includes","hasItalicFontStyle","fontStyle","hasUnderlineTextDecoration","after","childLexicalNodes","length","push","forChild","lexicalNode","parentLexicalNode","$isTableCellNode","paragraphNode","getTextContent","toggleFormat","append","INSERT_TABLE_COMMAND","TableRowNode","__height","tr","$convertTableRowElement","$createTableRowNode","setHeight","height","getHeight","tableRow","extractWithChild","child","selection","destination","children","$isTableRowNode","CAN_USE_DOM","window","documentMode","IS_FIREFOX","navigator","userAgent","InputEvent","$createTableNodeWithDimensions","rowCount","columnCount","includeHeaders","tableNode","$createTableNode","iRow","tableRowNode","iColumn","rows","columns","$getTableCellNodeFromLexicalNode","startingNode","n","$getTableRowNodeFromTableCellNodeOrThrow","Error","$getTableNodeFromLexicalNodeOrThrow","$isTableNode","$getTableRowIndexFromTableCellNode","getChildren","findIndex","is","$getTableColumnIndexFromTableCellNode","$getTableCellSiblingsFromTableCellNode","table","x","y","getCordsFromCellNode","above","getCellNodeFromCords","below","left","right","$removeTableRowAtIndex","indexToDelete","tableRows","targetRowNode","remove","$insertTableRow","targetIndex","shouldInsertAfter","r","tableRowCells","tableColumnCount","newTableRowNode","c","tableCellFromTargetRow","insertAfter","insertBefore","getHeaderState","currentState","possibleState","$insertTableRow__EXPERIMENTAL","$isTableSelection","anchor","getNode","focus","anchorCell","$getNodeTriplet","focusCell","grid","gridMap","focusCellMap","anchorCellMap","$computeTableMap","startRow","anchorStartRow","focusStartRow","insertedRow","insertAfterEndRow","Math","max","insertAfterEndRowMap","newRow","i","cell","currentCell","currentCellHeaderState","insertAfterEndRowNode","getChildAtIndex","insertBeforeStartRow","min","insertBeforeStartRowMap","insertBeforeStartRowNode","$insertTableColumn","tableCellsToBeInserted","currentTableRowNode","tableRowChildren","targetCell","newTableCell","forEach","$insertTableColumn__EXPERIMENTAL","startColumn","insertAfterColumn","gridFirstChild","getFirstChild","firstInsertedCell","$createTableCellNodeForInsertTableColumn","loopRow","rowLoop","currentRow","getNextSibling","rowMap","currentStartColumn","currentStartRow","insertAfterCell","insertAfterCellRowStart","prevCellIndex","cell_","startRow_","$moveSelectionToCell","colWidths","getColWidths","newColWidths","columnIndex","newWidth","splice","setColWidths","$deleteTableColumn","$deleteTableRow__EXPERIMENTAL","isBackward","focusEndRow","selectedRowCount","nextRow","nextRowNode","row","column","cellStartRow","cellStartColumn","overflowTop","currentCellMap","rowNode","String","previousRow","$deleteTableColumn__EXPERIMENTAL","anchorStartColumn","focusStartColumn","endColumn","selectedColumnCount","selectPrevious","overflowLeft","inSelectedArea","focusRowMap","nextColumn","firstDescendant","getFirstDescendant","selectStart","getParentOrThrow","parent","firstChild","$unmergeCell","map","cellMap","baseColStyle","colStyles","Array","from","_v","colStyle","rowIdx","baseRowStyle","rowStyles","rowStyle","colIdx","currentRowNode","currentRowMap","j","cellA","cellB","tableMap","cellAValue","cellBValue","$computeTableMapSkipCellCheck","getMapRow","gridChildren","startMapRow","value","mapRow","source","getParent","$computeTableCellRectSpans","boundary","minColumn","maxColumn","minRow","maxRow","topSpan","leftSpan","rightSpan","bottomSpan","topRow","bottomRow","col","$computeTableCellRectBoundary","cellAMap","cellBMap","exploredMinColumn","exploredMinRow","exploredMaxColumn","exploredMaxRow","expandBoundary","mapValue","rowDiff","previousColumn","columnDiff","$getTableCellNodeRect","cellNode","gridNode","cellMatrix","rowIndex","cells","cellIndex","$getCellNodes","tableSelection","anchorNode","anchorRow","anchorTable","focusNode","focusRow","focusTable","k","TableSelection","tableKey","_selection","_cachedNodes","dirty","getStartEndPoints","isValid","type","isBefore","getCachedNodes","setCachedNodes","nodes","set","anchorCellKey","focusCellKey","offset","isCollapsed","extract","getNodes","insertRawText","text","insertText","hasFormat","format","cellNodes","filter","paragraph","getTextFormat","formatFlag","insertNodes","select","getChildrenSize","getShape","anchorCellNodeRect","focusCellNodeRect","startX","stopX","startY","stopY","fromX","fromY","toX","toY","cachedNodes","focusCellGrid","getParents","isParentOf","gridParent","focusCellParent","nodeMap","Map","lastRow","has","$visitRecursively","childNode","values","textContent","__parent","$createTableSelection","$createTableSelectionFrom","tableNodeKey","isAttached","$findTableNode","prevSelection","nextSelection","$visit","stack","currentArray","at","currentNode","pop","$getTableAndElementByKey","tableElement","getTableElement","getElementByKey","TableObserver","isHighlightingCells","anchorX","anchorY","focusX","focusY","listenersToRemove","Set","domRows","anchorCellNodeKey","focusCellNodeKey","hasHijackedSelectionStyles","isSelecting","shouldCheckSelection","abortController","AbortController","listenerOptions","signal","nextFocus","trackTable","getTable","removeListeners","abort","removeListener","clear","$lookup","observer","MutationObserver","records","getEditorState","read","gridNeedsRedraw","record","target","observe","attributes","childList","subtree","$clearHighlight","$enableHighlightStyle","$updateDOMForSelection","dispatchCommand","_config","classList","$disableHighlightStyle","$updateTableTableSelection","updateDOMSelection","setShouldCheckSelection","getAndClearShouldCheckSelection","setNextFocus","getAndClearNextFocus","domSelection","_window","rangeCount","removeAllRanges","$setFocusCellForSelection","ignoreStart","cellX","cellY","focusTableCellNode","$getNearestTableCellInTableFromDOMNode","elem","$getAnchorTableCellOrThrow","$getAnchorTableCell","anchorTableCell","$getFocusTableCell","$getFocusTableCellOrThrow","focusTableCell","$setAnchorCellForSelection","anchorTableCellNode","anchorNodeKey","$formatCells","formatSelection","alignFormatWith","getFormatFlags","formatText","$clearText","selectedNodes","textNode","LEXICAL_ELEMENT_KEY","isMouseDownOnEvent","event","buttons","dom","getDOMSlot","getEditorWindow","$findParentTableCellNodeInTable","lastTableCellNode","ARROW_KEY_COMMANDS_WITH_DIRECTION","DELETE_TEXT_COMMANDS","DELETE_KEY_COMMANDS","applyTableHandlers","hasTabHandler","rootElement","getRootElement","editorWindow","tableObserver","attachTableObserverToTableElement","add","detatchTableObserverFromTableElement","createMouseHandlers","onMouseUp","removeEventListener","onMouseMove","moveEvent","override","contains","getDOMCellFromTarget","el","elementsFromPoint","clientX","clientY","addEventListener","onMouseDown","button","update","shiftKey","$isSelectionInTable","prevAnchorNode","prevAnchorCell","$getObserverCellFromCellNodeOrThrow","stopEvent","newSelection","selectEnd","mouseDownCallback","command","direction","registerCommand","$handleArrowKey","focusCellNode","deleteTextHandler","isAnchorInside","isFocusInside","selectionContainsPartialTable","nearestElementNode","topLevelCellElementNode","getPreviousSibling","$deleteCellHandler","tablePoint","outerPoint","preventDefault","stopPropagation","ClipboardEvent","intercepted","removeText","payload","formatType","visited","setFormat","cellChildren","isInline","edgePosition","$getTableEdgeCursorPosition","$insertParagraphAtTableEdge","$findCellNode","$selectAdjacentCell","isSelected","selectionPayload","anchorAndFocus","isTableSelection","isRangeSelection","isSelectionInsideOfGrid","newGrid","newGridRows","newColumnCount","getFirstChildOrThrow","newRowCount","gridCellNode","gridRowNode","getIndexWithinParent","gridRowNodes","newRowIdx","currentGridRowNode","newGridRowNode","gridCellNodes","newGridCellNodes","newColumnIdx","currentGridCellNode","newGridCellNode","originalChildren","firstRow","firstCell","anchorCellNode","isPartiallyWithinTable","isWithinTable","lastCell","$addHighlightStyleToTable","isFocusOutside","$removeHighlightStyleToTable","getTableObserverFromTableElement","_cell","parentNode","querySelector","nodeMame","hasBackgroundColor","highlighted","sibling","nextSibling","parentSibling","selectedCellNodes","$forEachTableCell","$addHighlightToDOM","$removeHighlightFromDOM","getAttribute","removeAttribute","cb","siblingMethod","childMethod","parentRow","parentTable","selectNext","selectTableNodeInDirection","isForward","selectTableCellNode","getCellNodeFromCordsOrThrow","getCorner","rect","cellValue","colName","rowName","getCornerOrThrow","corner","oppositeCorner","cellAtCornerOrThrow","rowNum","colNum","$extractRectCorners","anchorCellValue","newFocusCellValue","anchorCorner","newFocusCorner","newAnchorCorner","$adjustFocusInDirection","focusCellValue","spans","focusColumn","fCol","fRow","targetRowMap","finalAnchorCell","finalFocusCell","anchorDOM","focusDOM","fromStart","editorThemeClasses","tableCellSelected","$getBlockParentIfFirstNode","isTypeaheadMenuInView","siblingNode","isTableUnselect","focusParentNode","newOffset","newFocusNode","getLastChild","getTextContentSize","selectedNode","lastDescendant","getLastDescendant","firstCellNode","lastCellNode","firstCellCoords","lastCellCoords","firstCellDOM","getDOMCellFromCordsOrThrow","lastCellDOM","$isScrollableTablesActive","anchorCellTable","anchorCellTableElement","anchorType","anchorOffset","isExitingTableAnchor","$handleTableExit","anchorCellDom","edgeSelectionRect","getBoundingClientRect","range","getRangeAt","edgeChild","edgeChildDOM","edgeRect","isExiting","top","bottom","cords","tableNodeFromSelection","cordsAnchor","anchorValue","focusValue","stopImmediatePropagation","root","hasAttribute","isExitingTableElementAnchor","$isExitingTableTextAnchor","hasValidOffset","isExitingCell","toNode","$getExitingToNode","anchorSibling","tableNodeParent","domAnchorNode","tableNodeParentDOM","isAtFirstCell","isAtLastCell","currentCords","startingDOM","editorState","updateColgroup","colCount","colGroup","cols","replaceChildren","setRowStriping","rowStriping","tableRowStriping","scrollableEditors","WeakSet","setScrollableTablesActive","active","tableScrollableWrapper","console","warn","delete","TableNode","__colWidths","Object","freeze","__rowStriping","_node","$convertTableElement","withAfter","appendChild","getColumnCount","wrapperElement","classes","cssText","superExport","cellValues","knownColumns","cellDOM","querySelectorAll","cellSpan","get","tBody","getDOMCellFromCords","index","getRowStriping","Boolean","newRowStriping","canSelectBefore","$getElementForTableNode","$insertTableCommandListener","Number","$tableCellTransform","isEmpty","$tableRowTransform","$tableTransform","maxRowLength","reduce","curLength","rowNodes","name","rowLength","acc","newCell","registerTableCellUnmergeTransform","registerNodeTransform","rowsCount","columnsCount","unmerged","lastRowCell","registerTableSelectionObserver","tableSelections","initializeTableNode","nodeKey","unregisterMutationListener","registerMutationListener","nodeMutations","mutation","skipInitialization","registerTablePlugin","hasNodes"],"sources":["/Users/Matt.Ratliff/Development/lexical-sandbox/node_modules/@lexical/table/LexicalTable.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { addClassNamesToElement, $descendantsMatching, $findMatchingParent, removeClassNamesFromElement, objectKlassEquals, isHTMLElement as isHTMLElement$1, $insertFirst as $insertFirst$1, mergeRegister, $insertNodeToNearestRoot, $unwrapAndFilterDescendants } from '@lexical/utils';\nimport { ElementNode, isHTMLElement, $createParagraphNode, $isElementNode, $isLineBreakNode, $isTextNode, $applyNodeReplacement, createCommand, $createTextNode, $getSelection, $isRangeSelection, $createPoint, $isParagraphNode, $normalizeSelection__EXPERIMENTAL, isCurrentlyReadOnlyMode, TEXT_TYPE_TO_FORMAT, $getNodeByKey, $getEditor, $setSelection, SELECTION_CHANGE_COMMAND, getDOMSelection, $createRangeSelection, COMMAND_PRIORITY_HIGH, KEY_ESCAPE_COMMAND, COMMAND_PRIORITY_CRITICAL, CUT_COMMAND, FORMAT_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, CONTROLLED_TEXT_INSERTION_COMMAND, KEY_TAB_COMMAND, FOCUS_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getPreviousSelection, $getNearestNodeFromDOMNode, $createRangeSelectionFromDom, INSERT_PARAGRAPH_COMMAND, $isRootOrShadowRoot, $isDecoratorNode, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_UP_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, isDOMNode, setDOMUnmanaged, COMMAND_PRIORITY_EDITOR } from 'lexical';\nimport { copyToClipboard, $getClipboardDataFromSelection } from '@lexical/clipboard';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    return new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n  }\n  afterCloneFrom(node) {\n    super.afterCloneFrom(node);\n    this.__rowSpan = node.__rowSpan;\n    this.__backgroundColor = node.__backgroundColor;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableCellNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeaderStyles(serializedNode.headerState).setColSpan(serializedNode.colSpan || 1).setRowSpan(serializedNode.rowSpan || 1).setWidth(serializedNode.width || undefined).setBackgroundColor(serializedNode.backgroundColor || null);\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    addClassNamesToElement(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const output = super.exportDOM(editor);\n    if (isHTMLElement(output.element)) {\n      const element = output.element;\n      element.setAttribute('data-temporary-table-cell-lexical-key', this.getKey());\n      element.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element.rowSpan = this.__rowSpan;\n      }\n      element.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element.style.verticalAlign = 'top';\n      element.style.textAlign = 'start';\n      if (this.__backgroundColor === null && this.hasHeader()) {\n        element.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return output;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.getLatest().__colSpan;\n  }\n  setColSpan(colSpan) {\n    const self = this.getWritable();\n    self.__colSpan = colSpan;\n    return self;\n  }\n  getRowSpan() {\n    return this.getLatest().__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    const self = this.getWritable();\n    self.__rowSpan = rowSpan;\n    return self;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {\n    const self = this.getWritable();\n    self.__headerState = headerState & mask | self.__headerState & ~mask;\n    return self;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return self;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    const self = this.getWritable();\n    self.__backgroundColor = newBackgroundColor;\n    return self;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const style = domNode_.style;\n  const textDecoration = (style && style.textDecoration || '').split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      if (childLexicalNodes.length === 0) {\n        childLexicalNodes.push($createParagraphNode());\n      }\n      return childLexicalNodes;\n    },\n    forChild: (lexicalNode, parentLexicalNode) => {\n      if ($isTableCellNode(parentLexicalNode) && !$isElementNode(lexicalNode)) {\n        const paragraphNode = $createParagraphNode();\n        if ($isLineBreakNode(lexicalNode) && lexicalNode.getTextContent() === '\\n') {\n          return null;\n        }\n        if ($isTextNode(lexicalNode)) {\n          if (hasBoldFontWeight) {\n            lexicalNode.toggleFormat('bold');\n          }\n          if (hasLinethroughTextDecoration) {\n            lexicalNode.toggleFormat('strikethrough');\n          }\n          if (hasItalicFontStyle) {\n            lexicalNode.toggleFormat('italic');\n          }\n          if (hasUnderlineTextDecoration) {\n            lexicalNode.toggleFormat('underline');\n          }\n        }\n        paragraphNode.append(lexicalNode);\n        return paragraphNode;\n      }\n      return lexicalNode;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width) {\n  return $applyNodeReplacement(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = createCommand('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeight(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    const height = this.getHeight();\n    return {\n      ...super.exportJSON(),\n      ...(height === undefined ? undefined : {\n        height\n      })\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    addClassNamesToElement(element, config.theme.tableRow);\n    return element;\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return self;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    after: children => $descendantsMatching(children, $isTableCellNode),\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return $applyNodeReplacement(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = $createParagraphNode();\n      paragraphNode.append($createTextNode());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = $findMatchingParent(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append($createParagraphNode());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\n\n/**\n * Inserts a table row before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRow__EXPERIMENTAL(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  let insertedRow = null;\n  if (insertAfter) {\n    const insertAfterEndRow = Math.max(focusStartRow + focusCell.__rowSpan, anchorStartRow + anchorCell.__rowSpan) - 1;\n    const insertAfterEndRowMap = gridMap[insertAfterEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertAfterEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= insertAfterEndRow) {\n        const currentCell = insertAfterEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertAfterEndRowNode = grid.getChildAtIndex(insertAfterEndRow);\n    if (!$isTableRowNode(insertAfterEndRowNode)) {\n      throw Error(`insertAfterEndRow is not a TableRowNode`);\n    }\n    insertAfterEndRowNode.insertAfter(newRow);\n    insertedRow = newRow;\n  } else {\n    const insertBeforeStartRow = Math.min(focusStartRow, anchorStartRow);\n    const insertBeforeStartRowMap = gridMap[insertBeforeStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertBeforeStartRowMap[i];\n      if (startRow === insertBeforeStartRow) {\n        const currentCell = insertBeforeStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append($createParagraphNode()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertBeforeStartRowNode = grid.getChildAtIndex(insertBeforeStartRow);\n    if (!$isTableRowNode(insertBeforeStartRowNode)) {\n      throw Error(`insertBeforeStartRow is not a TableRowNode`);\n    }\n    insertBeforeStartRowNode.insertBefore(newRow);\n    insertedRow = newRow;\n  }\n  return insertedRow;\n}\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          throw Error(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append($createParagraphNode());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\n\n/**\n * Inserts a column before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumn__EXPERIMENTAL(insertAfter = true) {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [gridMap, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const rowCount = gridMap.length;\n  const startColumn = insertAfter ? Math.max(focusCellMap.startColumn, anchorCellMap.startColumn) : Math.min(focusCellMap.startColumn, anchorCellMap.startColumn);\n  const insertAfterColumn = insertAfter ? startColumn + focusCell.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    throw Error(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append($createParagraphNode());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        throw Error(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;\n    const newWidth = newColWidths[columnIndex];\n    newColWidths.splice(columnIndex, 0, newWidth);\n    grid.setColWidths(newColWidths);\n  }\n  return firstInsertedCell;\n}\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRow__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const selectedRowCount = anchorCell.__rowSpan;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top have to be trimmed\n      if (row === anchorStartRow && cellStartRow < anchorStartRow) {\n        const overflowTop = anchorStartRow - cellStartRow;\n        cell.setRowSpan(cell.__rowSpan - Math.min(selectedRowCount, cell.__rowSpan - overflowTop));\n      }\n      // Rows overflowing bottom have to be trimmed and moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        cell.setRowSpan(cell.__rowSpan - (focusEndRow - cellStartRow + 1));\n        if (!(nextRowNode !== null)) {\n          throw Error(`Expected nextRowNode not to be null`);\n        }\n        let insertAfterCell = null;\n        for (let columnIndex = 0; columnIndex < column; columnIndex++) {\n          const currentCellMap = nextRow[columnIndex];\n          const currentCell = currentCellMap.cell;\n          // Checking the cell having startRow as same as nextRow\n          if (currentCellMap.startRow === row + 1) {\n            insertAfterCell = currentCell;\n          }\n          if (currentCell.__colSpan > 1) {\n            columnIndex += currentCell.__colSpan - 1;\n          }\n        }\n        if (insertAfterCell === null) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          insertAfterCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\nfunction $deleteTableColumn__EXPERIMENTAL() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    newColWidths.splice(startColumn, selectedColumnCount);\n    grid.setColWidths(newColWidths);\n  }\n}\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $unmergeCell() {\n  const selection = $getSelection();\n  if (!($isRangeSelection(selection) || $isTableSelection(selection))) {\n    throw Error(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const [cell, row, grid] = $getNodeTriplet(anchor);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan === 1 && rowSpan === 1) {\n    return;\n  }\n  const [map, cellMap] = $computeTableMap(grid, cell, cell);\n  const {\n    startColumn,\n    startRow\n  } = cellMap;\n  // Create a heuristic for what the style of the unmerged cells should be\n  // based on whether every row or column already had that state before the\n  // unmerge.\n  const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;\n  const colStyles = Array.from({\n    length: colSpan\n  }, (_v, i) => {\n    let colStyle = baseColStyle;\n    for (let rowIdx = 0; colStyle !== 0 && rowIdx < map.length; rowIdx++) {\n      colStyle &= map[rowIdx][i + startColumn].cell.__headerState;\n    }\n    return colStyle;\n  });\n  const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;\n  const rowStyles = Array.from({\n    length: rowSpan\n  }, (_v, i) => {\n    let rowStyle = baseRowStyle;\n    for (let colIdx = 0; rowStyle !== 0 && colIdx < map[0].length; colIdx++) {\n      rowStyle &= map[i + startRow][colIdx].cell.__headerState;\n    }\n    return rowStyle;\n  });\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(colStyles[i] | rowStyles[0]).append($createParagraphNode()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        throw Error(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          $insertFirst(currentRowNode, $createTableCellNode(colStyles[j] | rowStyles[i]).append($createParagraphNode()));\n        }\n      } else {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          insertAfterCell.insertAfter($createTableCellNode(colStyles[j] | rowStyles[i]).append($createParagraphNode()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(tableNode, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(tableNode, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Table`);\n  }\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Table`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(tableNode, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function getMapRow(i) {\n    let row = tableMap[i];\n    if (row === undefined) {\n      tableMap[i] = row = [];\n    }\n    return row;\n  }\n  const gridChildren = tableNode.getChildren();\n  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {\n    const row = gridChildren[rowIdx];\n    if (!$isTableRowNode(row)) {\n      throw Error(`Expected TableNode children to be TableRowNode`);\n    }\n    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {\n      if (!$isTableCellNode(cell)) {\n        throw Error(`Expected TableRowNode children to be TableCellNode`);\n      } // Skip past any columns that were merged from a higher row\n      const startMapRow = getMapRow(rowIdx);\n      while (startMapRow[colIdx] !== undefined) {\n        colIdx++;\n      }\n      const value = {\n        cell,\n        startColumn: colIdx,\n        startRow: rowIdx\n      };\n      const {\n        __rowSpan: rowSpan,\n        __colSpan: colSpan\n      } = cell;\n      for (let j = 0; j < rowSpan; j++) {\n        if (rowIdx + j >= gridChildren.length) {\n          // The table is non-rectangular with a rowSpan\n          // below the last <tr> in the table.\n          // We should probably handle this with a node transform\n          // to ensure that tables are always rectangular but this\n          // will avoid crashes such as #6584\n          // Note that there are probably still latent bugs\n          // regarding colSpan or general cell count mismatches.\n          break;\n        }\n        const mapRow = getMapRow(rowIdx + j);\n        for (let i = 0; i < colSpan; i++) {\n          mapRow[colIdx + i] = value;\n        }\n      }\n      if (cellA !== null && cellAValue === null && cellA.is(cell)) {\n        cellAValue = value;\n      }\n      if (cellB !== null && cellBValue === null && cellB.is(cell)) {\n        cellBValue = value;\n      }\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = $findMatchingParent(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      throw Error(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    throw Error(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    throw Error(`Expected TableRowNode to have a parent TableNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $computeTableCellRectSpans(map, boundary) {\n  const {\n    minColumn,\n    maxColumn,\n    minRow,\n    maxRow\n  } = boundary;\n  let topSpan = 1;\n  let leftSpan = 1;\n  let rightSpan = 1;\n  let bottomSpan = 1;\n  const topRow = map[minRow];\n  const bottomRow = map[maxRow];\n  for (let col = minColumn; col <= maxColumn; col++) {\n    topSpan = Math.max(topSpan, topRow[col].cell.__rowSpan);\n    bottomSpan = Math.max(bottomSpan, bottomRow[col].cell.__rowSpan);\n  }\n  for (let row = minRow; row <= maxRow; row++) {\n    leftSpan = Math.max(leftSpan, map[row][minColumn].cell.__colSpan);\n    rightSpan = Math.max(rightSpan, map[row][maxColumn].cell.__colSpan);\n  }\n  return {\n    bottomSpan,\n    leftSpan,\n    rightSpan,\n    topSpan\n  };\n}\nfunction $computeTableCellRectBoundary(map, cellAMap, cellBMap) {\n  let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n  let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n  let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n  let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n  let exploredMinColumn = minColumn;\n  let exploredMinRow = minRow;\n  let exploredMaxColumn = minColumn;\n  let exploredMaxRow = minRow;\n  function expandBoundary(mapValue) {\n    const {\n      cell,\n      startColumn: cellStartColumn,\n      startRow: cellStartRow\n    } = mapValue;\n    minColumn = Math.min(minColumn, cellStartColumn);\n    minRow = Math.min(minRow, cellStartRow);\n    maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n    maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n  }\n  while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n    if (minColumn < exploredMinColumn) {\n      // Expand on the left\n      const rowDiff = exploredMaxRow - exploredMinRow;\n      const previousColumn = exploredMinColumn - 1;\n      for (let i = 0; i <= rowDiff; i++) {\n        expandBoundary(map[exploredMinRow + i][previousColumn]);\n      }\n      exploredMinColumn = previousColumn;\n    }\n    if (minRow < exploredMinRow) {\n      // Expand on top\n      const columnDiff = exploredMaxColumn - exploredMinColumn;\n      const previousRow = exploredMinRow - 1;\n      for (let i = 0; i <= columnDiff; i++) {\n        expandBoundary(map[previousRow][exploredMinColumn + i]);\n      }\n      exploredMinRow = previousRow;\n    }\n    if (maxColumn > exploredMaxColumn) {\n      // Expand on the right\n      const rowDiff = exploredMaxRow - exploredMinRow;\n      const nextColumn = exploredMaxColumn + 1;\n      for (let i = 0; i <= rowDiff; i++) {\n        expandBoundary(map[exploredMinRow + i][nextColumn]);\n      }\n      exploredMaxColumn = nextColumn;\n    }\n    if (maxRow > exploredMaxRow) {\n      // Expand on the bottom\n      const columnDiff = exploredMaxColumn - exploredMinColumn;\n      const nextRow = exploredMaxRow + 1;\n      for (let i = 0; i <= columnDiff; i++) {\n        expandBoundary(map[nextRow][exploredMinColumn + i]);\n      }\n      exploredMaxRow = nextRow;\n    }\n  }\n  return {\n    maxColumn,\n    maxRow,\n    minColumn,\n    minRow\n  };\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $getCellNodes(tableSelection) {\n  const [[anchorNode, anchorCell, anchorRow, anchorTable], [focusNode, focusCell, focusRow, focusTable]] = ['anchor', 'focus'].map(k => {\n    const node = tableSelection[k].getNode();\n    const cellNode = $findMatchingParent(node, $isTableCellNode);\n    if (!$isTableCellNode(cellNode)) {\n      throw Error(`Expected TableSelection ${k} to be (or a child of) TableCellNode, got key ${node.getKey()} of type ${node.getType()}`);\n    }\n    const rowNode = cellNode.getParent();\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`Expected TableSelection ${k} cell parent to be a TableRowNode`);\n    }\n    const tableNode = rowNode.getParent();\n    if (!$isTableNode(tableNode)) {\n      throw Error(`Expected TableSelection ${k} row parent to be a TableNode`);\n    }\n    return [node, cellNode, rowNode, tableNode];\n  });\n  // TODO: nested tables may violate this\n  if (!anchorTable.is(focusTable)) {\n    throw Error(`Expected TableSelection anchor and focus to be in the same table`);\n  }\n  return {\n    anchorCell,\n    anchorNode,\n    anchorRow,\n    anchorTable,\n    focusCell,\n    focusNode,\n    focusRow,\n    focusTable\n  };\n}\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * {@link $createTableSelection} unfortunately makes it very easy to create\n   * nonsense selections, so we have a method to see if the selection probably\n   * makes sense.\n   *\n   * @returns true if the TableSelection is (probably) valid\n   */\n  isValid() {\n    return this.tableKey !== 'root' && this.anchor.key !== 'root' && this.anchor.type === 'element' && this.focus.key !== 'root' && this.focus.type === 'element';\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    return $isTableSelection(selection) && this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    // note: closure compiler's acorn does not support ||=\n    this.dirty = this.dirty || tableKey !== this.tableKey || anchorCellKey !== this.anchor.key || focusCellKey !== this.focus.key;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, $createPoint(this.anchor.key, this.anchor.offset, this.anchor.type), $createPoint(this.focus.key, this.focus.offset, this.focus.type));\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection.\n   * This will be true if any paragraph in table cells has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    let format = 0;\n    const cellNodes = this.getNodes().filter($isTableCellNode);\n    cellNodes.forEach(cellNode => {\n      const paragraph = cellNode.getFirstChild();\n      if ($isParagraphNode(paragraph)) {\n        format |= paragraph.getTextFormat();\n      }\n    });\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (format & formatFlag) !== 0;\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!$isElementNode(focusNode)) {\n      throw Error(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = $normalizeSelection__EXPERIMENTAL(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const {\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCell);\n    if (!(anchorCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCell);\n    if (!(focusCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    if (!this.isValid()) {\n      return [];\n    }\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const {\n      anchorTable: tableNode,\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          throw Error(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          throw Error(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    const {\n      minColumn,\n      maxColumn,\n      minRow,\n      maxRow\n    } = $computeTableCellRectBoundary(map, cellAMap, cellBMap);\n\n    // We use a Map here because merged cells in the grid would otherwise\n    // show up multiple times in the nodes array\n    const nodeMap = new Map([[tableNode.getKey(), tableNode]]);\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          throw Error(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodeMap.set(currentRow.getKey(), currentRow);\n          lastRow = currentRow;\n        }\n        if (!nodeMap.has(cell.getKey())) {\n          $visitRecursively(cell, childNode => {\n            nodeMap.set(childNode.getKey(), childNode);\n          });\n        }\n      }\n    }\n    const nodes = Array.from(nodeMap.values());\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  // TODO this is a suboptimal design, it doesn't make sense to have\n  // a table selection that isn't associated with a table. This\n  // constructor should have required argumnets and in true we\n  // should check that they point to a table and are element points to\n  // cell nodes of that table.\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $createTableSelectionFrom(tableNode, anchorCell, focusCell) {\n  const tableNodeKey = tableNode.getKey();\n  const anchorCellKey = anchorCell.getKey();\n  const focusCellKey = focusCell.getKey();\n  {\n    if (!tableNode.isAttached()) {\n      throw Error(`$createTableSelectionFrom: tableNode ${tableNodeKey} is not attached`);\n    }\n    if (!tableNode.is($findTableNode(anchorCell))) {\n      throw Error(`$createTableSelectionFrom: anchorCell ${anchorCellKey} is not in table ${tableNodeKey}`);\n    }\n    if (!tableNode.is($findTableNode(focusCell))) {\n      throw Error(`$createTableSelectionFrom: focusCell ${focusCellKey} is not in table ${tableNodeKey}`);\n    } // TODO: Check for rectangular grid\n  }\n  const prevSelection = $getSelection();\n  const nextSelection = $isTableSelection(prevSelection) ? prevSelection.clone() : $createTableSelection();\n  nextSelection.set(tableNode.getKey(), anchorCell.getKey(), focusCell.getKey());\n  return nextSelection;\n}\n\n/**\n * Depth first visitor\n * @param node The starting node\n * @param $visit The function to call for each node. If the function returns false, then children of this node will not be explored\n */\nfunction $visitRecursively(node, $visit) {\n  const stack = [[node]];\n  for (let currentArray = stack.at(-1); currentArray !== undefined && stack.length > 0; currentArray = stack.at(-1)) {\n    const currentNode = currentArray.pop();\n    if (currentNode === undefined) {\n      stack.pop();\n    } else if ($visit(currentNode) !== false && $isElementNode(currentNode)) {\n      stack.push(currentNode.getChildren());\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $getTableAndElementByKey(tableNodeKey, editor = $getEditor()) {\n  const tableNode = $getNodeByKey(tableNodeKey);\n  if (!$isTableNode(tableNode)) {\n    throw Error(`TableObserver: Expected tableNodeKey ${tableNodeKey} to be a TableNode`);\n  }\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNodeKey));\n  if (!(tableElement !== null)) {\n    throw Error(`TableObserver: Expected to find TableElement in DOM for key ${tableNodeKey}`);\n  }\n  return {\n    tableElement,\n    tableNode\n  };\n}\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.isSelecting = false;\n    this.shouldCheckSelection = false;\n    this.abortController = new AbortController();\n    this.listenerOptions = {\n      signal: this.abortController.signal\n    };\n    this.nextFocus = null;\n    this.trackTable();\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    this.abortController.abort('removeListeners');\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n    this.listenersToRemove.clear();\n  }\n  $lookup() {\n    return $getTableAndElementByKey(this.tableNodeKey, this.editor);\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.getEditorState().read(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const {\n          tableNode,\n          tableElement\n        } = this.$lookup();\n        this.table = getTable(tableNode, tableElement);\n      }, {\n        editor: this.editor\n      });\n    });\n    this.editor.getEditorState().read(() => {\n      const {\n        tableNode,\n        tableElement\n      } = this.$lookup();\n      this.table = getTable(tableNode, tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    }, {\n      editor: this.editor\n    });\n  }\n  $clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.$enableHighlightStyle();\n    const {\n      tableNode,\n      tableElement\n    } = this.$lookup();\n    const grid = getTable(tableNode, tableElement);\n    $updateDOMForSelection(editor, grid, null);\n    if ($getSelection() !== null) {\n      $setSelection(null);\n      editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n    }\n  }\n  $enableHighlightStyle() {\n    const editor = this.editor;\n    const {\n      tableElement\n    } = this.$lookup();\n    removeClassNamesFromElement(tableElement, editor._config.theme.tableSelection);\n    tableElement.classList.remove('disable-selection');\n    this.hasHijackedSelectionStyles = false;\n  }\n  $disableHighlightStyle() {\n    const {\n      tableElement\n    } = this.$lookup();\n    addClassNamesToElement(tableElement, this.editor._config.theme.tableSelection);\n    this.hasHijackedSelectionStyles = true;\n  }\n  $updateTableTableSelection(selection) {\n    if (selection !== null) {\n      if (!(selection.tableKey === this.tableNodeKey)) {\n        throw Error(`TableObserver.$updateTableTableSelection: selection.tableKey !== this.tableNodeKey ('${selection.tableKey}' !== '${this.tableNodeKey}')`);\n      }\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n      this.updateDOMSelection();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else {\n      this.$clearHighlight();\n    }\n  }\n\n  /**\n   * @internal\n   * Firefox has a strange behavior where pressing the down arrow key from\n   * above the table will move the caret after the table and then lexical\n   * will select the last cell instead of the first.\n   * We do still want to let the browser handle caret movement but we will\n   * use this property to \"tag\" the update so that we can recheck the\n   * selection after the event is processed.\n   */\n  setShouldCheckSelection() {\n    this.shouldCheckSelection = true;\n  }\n  /**\n   * @internal\n   */\n  getAndClearShouldCheckSelection() {\n    if (this.shouldCheckSelection) {\n      this.shouldCheckSelection = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @internal\n   * When handling mousemove events we track what the focus cell should be, but\n   * the DOM selection may end up somewhere else entirely. We don't have an elegant\n   * way to handle this after the DOM selection has been resolved in a\n   * SELECTION_CHANGE_COMMAND callback.\n   */\n  setNextFocus(nextFocus) {\n    this.nextFocus = nextFocus;\n  }\n\n  /** @internal */\n  getAndClearNextFocus() {\n    const {\n      nextFocus\n    } = this;\n    if (nextFocus !== null) {\n      this.nextFocus = null;\n    }\n    return nextFocus;\n  }\n\n  /** @internal */\n  updateDOMSelection() {\n    if (this.anchorCell !== null && this.focusCell !== null) {\n      const domSelection = getDOMSelection(this.editor._window);\n      // We are not using a native selection for tables, and if we\n      // set one then the reconciler will undo it.\n      // TODO - it would make sense to have one so that native\n      //        copy/paste worked. Right now we have to emulate with\n      //        keyboard events but it won't fire if trigged from the menu\n      if (domSelection && domSelection.rangeCount > 0) {\n        domSelection.removeAllRanges();\n      }\n    }\n  }\n  $setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    const {\n      tableNode\n    } = this.$lookup();\n    const cellX = cell.x;\n    const cellY = cell.y;\n    this.focusCell = cell;\n    if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n    } else if (cellX === this.focusX && cellY === this.focusY) {\n      return false;\n    }\n    this.focusX = cellX;\n    this.focusY = cellY;\n    if (this.isHighlightingCells) {\n      const focusTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n      if (this.tableSelection != null && this.anchorCellNodeKey != null && focusTableCellNode !== null) {\n        this.focusCellNodeKey = focusTableCellNode.getKey();\n        this.tableSelection = $createTableSelectionFrom(tableNode, this.$getAnchorTableCellOrThrow(), focusTableCellNode);\n        $setSelection(this.tableSelection);\n        editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        $updateDOMForSelection(editor, this.table, this.tableSelection);\n        return true;\n      }\n    }\n    return false;\n  }\n  $getAnchorTableCell() {\n    return this.anchorCellNodeKey ? $getNodeByKey(this.anchorCellNodeKey) : null;\n  }\n  $getAnchorTableCellOrThrow() {\n    const anchorTableCell = this.$getAnchorTableCell();\n    if (!(anchorTableCell !== null)) {\n      throw Error(`TableObserver anchorTableCell is null`);\n    }\n    return anchorTableCell;\n  }\n  $getFocusTableCell() {\n    return this.focusCellNodeKey ? $getNodeByKey(this.focusCellNodeKey) : null;\n  }\n  $getFocusTableCellOrThrow() {\n    const focusTableCell = this.$getFocusTableCell();\n    if (!(focusTableCell !== null)) {\n      throw Error(`TableObserver focusTableCell is null`);\n    }\n    return focusTableCell;\n  }\n  $setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    const {\n      tableNode\n    } = this.$lookup();\n    const anchorTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n    if (anchorTableCellNode !== null) {\n      const anchorNodeKey = anchorTableCellNode.getKey();\n      this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n      this.anchorCellNodeKey = anchorNodeKey;\n    }\n  }\n  $formatCells(type) {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection)) {\n      throw Error(`Expected Table selection`);\n    }\n    const formatSelection = $createRangeSelection();\n    const anchor = formatSelection.anchor;\n    const focus = formatSelection.focus;\n    const cellNodes = selection.getNodes().filter($isTableCellNode);\n    if (!(cellNodes.length > 0)) {\n      throw Error(`No table cells present`);\n    }\n    const paragraph = cellNodes[0].getFirstChild();\n    const alignFormatWith = $isParagraphNode(paragraph) ? paragraph.getFormatFlags(type, null) : null;\n    cellNodes.forEach(cellNode => {\n      anchor.set(cellNode.getKey(), 0, 'element');\n      focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n      formatSelection.formatText(type, alignFormatWith);\n    });\n    $setSelection(selection);\n    this.editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  $clearText() {\n    const {\n      editor\n    } = this;\n    const tableNode = $getNodeByKey(this.tableNodeKey);\n    if (!$isTableNode(tableNode)) {\n      throw new Error('Expected TableNode.');\n    }\n    const selection = $getSelection();\n    if (!$isTableSelection(selection)) {\n      throw Error(`Expected TableSelection`);\n    }\n    const selectedNodes = selection.getNodes().filter($isTableCellNode);\n    if (selectedNodes.length === this.table.columns * this.table.rows) {\n      tableNode.selectPrevious();\n      // Delete entire table\n      tableNode.remove();\n      return;\n    }\n    selectedNodes.forEach(cellNode => {\n      if ($isElementNode(cellNode)) {\n        const paragraphNode = $createParagraphNode();\n        const textNode = $createTextNode();\n        paragraphNode.append(textNode);\n        cellNode.append(paragraphNode);\n        cellNode.getChildren().forEach(child => {\n          if (child !== paragraphNode) {\n            child.remove();\n          }\n        });\n      }\n    });\n    $updateDOMForSelection(editor, this.table, null);\n    $setSelection(null);\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst isMouseDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction getTableElement(tableNode, dom) {\n  if (!dom) {\n    return dom;\n  }\n  const element = dom.nodeName === 'TABLE' ? dom : tableNode.getDOMSlot(dom).element;\n  if (!(element.nodeName === 'TABLE')) {\n    throw Error(`getTableElement: Expecting table in as DOM node for TableNode, not ${dom.nodeName}`);\n  }\n  return element;\n}\nfunction getEditorWindow(editor) {\n  return editor._window;\n}\nfunction $findParentTableCellNodeInTable(tableNode, node) {\n  for (let currentNode = node, lastTableCellNode = null; currentNode !== null; currentNode = currentNode.getParent()) {\n    if (tableNode.is(currentNode)) {\n      return lastTableCellNode;\n    } else if ($isTableCellNode(currentNode)) {\n      lastTableCellNode = currentNode;\n    }\n  }\n  return null;\n}\nconst ARROW_KEY_COMMANDS_WITH_DIRECTION = [[KEY_ARROW_DOWN_COMMAND, 'down'], [KEY_ARROW_UP_COMMAND, 'up'], [KEY_ARROW_LEFT_COMMAND, 'backward'], [KEY_ARROW_RIGHT_COMMAND, 'forward']];\nconst DELETE_TEXT_COMMANDS = [DELETE_WORD_COMMAND, DELETE_LINE_COMMAND, DELETE_CHARACTER_COMMAND];\nconst DELETE_KEY_COMMANDS = [KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND];\nfunction applyTableHandlers(tableNode, element, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  const editorWindow = getEditorWindow(editor);\n  if (!(rootElement !== null && editorWindow !== null)) {\n    throw Error(`applyTableHandlers: editor has no root element set`);\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const tableElement = getTableElement(tableNode, element);\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  tableObserver.listenersToRemove.add(() => detatchTableObserverFromTableElement(tableElement, tableObserver));\n  const createMouseHandlers = () => {\n    if (tableObserver.isSelecting) {\n      return;\n    }\n    const onMouseUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('mouseup', onMouseUp);\n      editorWindow.removeEventListener('mousemove', onMouseMove);\n    };\n    const onMouseMove = moveEvent => {\n      if (!isDOMNode(moveEvent.target)) {\n        return;\n      }\n      if (!isMouseDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n        tableObserver.isSelecting = false;\n        editorWindow.removeEventListener('mouseup', onMouseUp);\n        editorWindow.removeEventListener('mousemove', onMouseMove);\n        return;\n      }\n      const override = !tableElement.contains(moveEvent.target);\n      let focusCell = null;\n      if (!override) {\n        focusCell = getDOMCellFromTarget(moveEvent.target);\n      } else {\n        for (const el of document.elementsFromPoint(moveEvent.clientX, moveEvent.clientY)) {\n          focusCell = tableElement.contains(el) ? getDOMCellFromTarget(el) : null;\n          if (focusCell) {\n            break;\n          }\n        }\n      }\n      if (focusCell && (tableObserver.focusCell === null || focusCell.elem !== tableObserver.focusCell.elem)) {\n        tableObserver.setNextFocus({\n          focusCell,\n          override\n        });\n        editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n      }\n    };\n    tableObserver.isSelecting = true;\n    editorWindow.addEventListener('mouseup', onMouseUp, tableObserver.listenerOptions);\n    editorWindow.addEventListener('mousemove', onMouseMove, tableObserver.listenerOptions);\n  };\n  const onMouseDown = event => {\n    if (event.button !== 0 || !isDOMNode(event.target) || !editorWindow) {\n      return;\n    }\n    const targetCell = getDOMCellFromTarget(event.target);\n    if (targetCell !== null) {\n      editor.update(() => {\n        const prevSelection = $getPreviousSelection();\n        // We can't trust Firefox to do the right thing with the selection and\n        // we don't have a proper state machine to do this \"correctly\" but\n        // if we go ahead and make the table selection now it will work\n        if (IS_FIREFOX && event.shiftKey && $isSelectionInTable(prevSelection, tableNode) && ($isRangeSelection(prevSelection) || $isTableSelection(prevSelection))) {\n          const prevAnchorNode = prevSelection.anchor.getNode();\n          const prevAnchorCell = $findParentTableCellNodeInTable(tableNode, prevSelection.anchor.getNode());\n          if (prevAnchorCell) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCell));\n            tableObserver.$setFocusCellForSelection(targetCell);\n            stopEvent(event);\n          } else {\n            const newSelection = tableNode.isBefore(prevAnchorNode) ? tableNode.selectStart() : tableNode.selectEnd();\n            newSelection.anchor.set(prevSelection.anchor.key, prevSelection.anchor.offset, prevSelection.anchor.type);\n          }\n        } else {\n          tableObserver.$setAnchorCellForSelection(targetCell);\n        }\n      });\n    }\n    createMouseHandlers();\n  };\n  tableElement.addEventListener('mousedown', onMouseDown, tableObserver.listenerOptions);\n\n  // Clear selection when clicking outside of dom.\n  const mouseDownCallback = event => {\n    const target = event.target;\n    if (event.button !== 0 || !isDOMNode(target)) {\n      return;\n    }\n    editor.update(() => {\n      const selection = $getSelection();\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.$clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('mousedown', mouseDownCallback, tableObserver.listenerOptions);\n  for (const [command, direction] of ARROW_KEY_COMMANDS_WITH_DIRECTION) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, event => $handleArrowKey(editor, event, direction, tableNode, tableObserver), COMMAND_PRIORITY_HIGH));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(KEY_ESCAPE_COMMAND, event => {\n    const selection = $getSelection();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = $findParentTableCellNodeInTable(tableNode, selection.focus.getNode());\n      if (focusCellNode !== null) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearText();\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findParentTableCellNodeInTable(tableNode, selection.anchor.getNode());\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.$clearText();\n        return true;\n      }\n      const nearestElementNode = $findMatchingParent(selection.anchor.getNode(), n => $isElementNode(n));\n      const topLevelCellElementNode = nearestElementNode && $findMatchingParent(nearestElementNode, n => $isElementNode(n) && $isTableCellNode(n.getParent()));\n      if (!$isElementNode(topLevelCellElementNode) || !$isElementNode(nearestElementNode)) {\n        return false;\n      }\n      if (command === DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  for (const command of DELETE_TEXT_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), COMMAND_PRIORITY_CRITICAL));\n  }\n  const $deleteCellHandler = event => {\n    const selection = $getSelection();\n    if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n      return false;\n    }\n\n    // If the selection is inside the table but should remove the whole table\n    // we expand the selection so that both the anchor and focus are outside\n    // the table and the editor's command listener will handle the delete\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    if (isAnchorInside !== isFocusInside) {\n      const tablePoint = isAnchorInside ? 'anchor' : 'focus';\n      const outerPoint = isAnchorInside ? 'focus' : 'anchor';\n      // Preserve the outer point\n      const {\n        key,\n        offset,\n        type\n      } = selection[outerPoint];\n      // Expand the selection around the table\n      const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? 'selectPrevious' : 'selectNext']();\n      // Restore the outer point of the selection\n      newSelection[outerPoint].set(key, offset, type);\n      // Let the base implementation handle the rest\n      return false;\n    }\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.$clearText();\n      return true;\n    }\n    return false;\n  };\n  for (const command of DELETE_KEY_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, $deleteCellHandler, COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(CUT_COMMAND, event => {\n    const selection = $getSelection();\n    if (selection) {\n      if (!($isTableSelection(selection) || $isRangeSelection(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void copyToClipboard(editor, objectKlassEquals(event, ClipboardEvent) ? event : null, $getClipboardDataFromSelection(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ($isRangeSelection(selection)) {\n        selection.removeText();\n        return true;\n      }\n      return intercepted;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_TEXT_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$formatCells(payload);\n      return true;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = $getSelection();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow + anchorCell.cell.__rowSpan - 1, focusCell.startRow + focusCell.cell.__rowSpan - 1);\n    const maxColumn = Math.max(anchorCell.startColumn + anchorCell.cell.__colSpan - 1, focusCell.startColumn + focusCell.cell.__colSpan - 1);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    const visited = new Set();\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        if (visited.has(cell)) {\n          continue;\n        }\n        visited.add(cell);\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ($isElementNode(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = $getSelection();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearHighlight();\n      return false;\n    } else if ($isRangeSelection(selection)) {\n      const tableCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [$createTextNode(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(KEY_TAB_COMMAND, event => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null || !tableNode.is($findTableNode(tableCellNode))) {\n        return false;\n      }\n      stopEvent(event);\n      $selectAdjacentCell(tableCellNode, event.shiftKey ? 'previous' : 'next');\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, selectionPayload => {\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = $isRangeSelection(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && $findMatchingParent(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor] = anchorAndFocus;\n    const newGrid = nodes[0];\n    const newGridRows = newGrid.getChildren();\n    const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n    const newRowCount = newGrid.getChildrenSize();\n    const gridCellNode = $findMatchingParent(anchor.getNode(), n => $isTableCellNode(n));\n    const gridRowNode = gridCellNode && $findMatchingParent(gridCellNode, n => $isTableRowNode(n));\n    const gridNode = gridRowNode && $findMatchingParent(gridRowNode, n => $isTableNode(n));\n    if (!$isTableCellNode(gridCellNode) || !$isTableRowNode(gridRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const startY = gridRowNode.getIndexWithinParent();\n    const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n    const startX = gridCellNode.getIndexWithinParent();\n    const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n    const fromX = Math.min(startX, stopX);\n    const fromY = Math.min(startY, stopY);\n    const toX = Math.max(startX, stopX);\n    const toY = Math.max(startY, stopY);\n    const gridRowNodes = gridNode.getChildren();\n    let newRowIdx = 0;\n    for (let r = fromY; r <= toY; r++) {\n      const currentGridRowNode = gridRowNodes[r];\n      if (!$isTableRowNode(currentGridRowNode)) {\n        return false;\n      }\n      const newGridRowNode = newGridRows[newRowIdx];\n      if (!$isTableRowNode(newGridRowNode)) {\n        return false;\n      }\n      const gridCellNodes = currentGridRowNode.getChildren();\n      const newGridCellNodes = newGridRowNode.getChildren();\n      let newColumnIdx = 0;\n      for (let c = fromX; c <= toX; c++) {\n        const currentGridCellNode = gridCellNodes[c];\n        if (!$isTableCellNode(currentGridCellNode)) {\n          return false;\n        }\n        const newGridCellNode = newGridCellNodes[newColumnIdx];\n        if (!$isTableCellNode(newGridCellNode)) {\n          return false;\n        }\n        const originalChildren = currentGridCellNode.getChildren();\n        newGridCellNode.getChildren().forEach(child => {\n          if ($isTextNode(child)) {\n            const paragraphNode = $createParagraphNode();\n            paragraphNode.append(child);\n            currentGridCellNode.append(child);\n          } else {\n            currentGridCellNode.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n        newColumnIdx++;\n      }\n      newRowIdx++;\n    }\n    return true;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(SELECTION_CHANGE_COMMAND, () => {\n    const selection = $getSelection();\n    const prevSelection = $getPreviousSelection();\n    const nextFocus = tableObserver.getAndClearNextFocus();\n    if (nextFocus !== null) {\n      const {\n        focusCell\n      } = nextFocus;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        if (focusCell.x === tableObserver.focusX && focusCell.y === tableObserver.focusY) {\n          // The selection is already the correct table selection\n          return false;\n        } else {\n          tableObserver.$setFocusCellForSelection(focusCell);\n          return true;\n        }\n      } else if (focusCell !== tableObserver.anchorCell && $isSelectionInTable(selection, tableNode)) {\n        // The selection has crossed cells\n        tableObserver.$setFocusCellForSelection(focusCell);\n        return true;\n      }\n    }\n    const shouldCheckSelection = tableObserver.getAndClearShouldCheckSelection();\n    // If they pressed the down arrow with the selection outside of the\n    // table, and then the selection ends up in the table but not in the\n    // first cell, then move the selection to the first cell.\n    if (shouldCheckSelection && $isRangeSelection(prevSelection) && $isRangeSelection(selection) && selection.isCollapsed()) {\n      const anchor = selection.anchor.getNode();\n      const firstRow = tableNode.getFirstChild();\n      const anchorCell = $findCellNode(anchor);\n      if (anchorCell !== null && $isTableRowNode(firstRow)) {\n        const firstCell = firstRow.getFirstChild();\n        if ($isTableCellNode(firstCell) && tableNode.is($findMatchingParent(anchorCell, node => node.is(tableNode) || node.is(firstCell)))) {\n          // The selection moved to the table, but not in the first cell\n          firstCell.selectStart();\n          return true;\n        }\n      }\n    }\n    if ($isRangeSelection(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartiallyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartiallyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        } else if (isAnchorInside) {\n          const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          /**\n           * If isBackward, set the anchor to be at the end of the table so that when the cursor moves outside of\n           * the table in the backward direction, the entire table will be selected from its end.\n           * Otherwise, if forward, set the anchor to be at the start of the table so that when the focus is dragged\n           * outside th end of the table, it will start from the beginning of the table.\n           */\n          newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, 'element');\n        }\n        $setSelection(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into table selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, anchorCellNode));\n          tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = getDOMSelection(editorWindow);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = $getNearestNodeFromDOMNode(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.isParentOf(focusNode);\n        const anchorNode = $getNearestNodeFromDOMNode(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.isParentOf(anchorNode);\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = $createRangeSelectionFromDom(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = $getSelection();\n    if (!$isRangeSelection(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction detatchTableObserverFromTableElement(tableElement, tableObserver) {\n  if (getTableObserverFromTableElement(tableElement) === tableObserver) {\n    delete tableElement[LEXICAL_ELEMENT_KEY];\n  }\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  if (!(getTableObserverFromTableElement(tableElement) === null)) {\n    throw Error(`tableElement already has an attached TableObserver`);\n  }\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY] || null;\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getTable(tableNode, dom) {\n  const tableElement = getTableElement(tableNode, dom);\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.querySelector('tr');\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = $getNearestNodeFromDOMNode(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.$disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.$enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nfunction $selectAdjacentCell(tableCellNode, direction) {\n  const siblingMethod = direction === 'next' ? 'getNextSibling' : 'getPreviousSibling';\n  const childMethod = direction === 'next' ? 'getFirstChild' : 'getLastChild';\n  const sibling = tableCellNode[siblingMethod]();\n  if ($isElementNode(sibling)) {\n    return sibling.selectEnd();\n  }\n  const parentRow = $findMatchingParent(tableCellNode, $isTableRowNode);\n  if (!(parentRow !== null)) {\n    throw Error(`selectAdjacentCell: Cell not in table row`);\n  }\n  for (let nextRow = parentRow[siblingMethod](); $isTableRowNode(nextRow); nextRow = nextRow[siblingMethod]()) {\n    const child = nextRow[childMethod]();\n    if ($isElementNode(child)) {\n      return child.selectEnd();\n    }\n  }\n  const parentTable = $findMatchingParent(parentRow, $isTableNode);\n  if (!(parentTable !== null)) {\n    throw Error(`selectAdjacentCell: Row not in table`);\n  }\n  return direction === 'next' ? parentTable.selectNext() : parentTable.selectPrevious();\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nfunction getCorner(rect, cellValue) {\n  let colName;\n  let rowName;\n  if (cellValue.startColumn === rect.minColumn) {\n    colName = 'minColumn';\n  } else if (cellValue.startColumn + cellValue.cell.__colSpan - 1 === rect.maxColumn) {\n    colName = 'maxColumn';\n  } else {\n    return null;\n  }\n  if (cellValue.startRow === rect.minRow) {\n    rowName = 'minRow';\n  } else if (cellValue.startRow + cellValue.cell.__rowSpan - 1 === rect.maxRow) {\n    rowName = 'maxRow';\n  } else {\n    return null;\n  }\n  return [colName, rowName];\n}\nfunction getCornerOrThrow(rect, cellValue) {\n  const corner = getCorner(rect, cellValue);\n  if (!(corner !== null)) {\n    throw Error(`getCornerOrThrow: cell ${cellValue.cell.getKey()} is not at a corner of rect`);\n  }\n  return corner;\n}\nfunction oppositeCorner([colName, rowName]) {\n  return [colName === 'minColumn' ? 'maxColumn' : 'minColumn', rowName === 'minRow' ? 'maxRow' : 'minRow'];\n}\nfunction cellAtCornerOrThrow(tableMap, rect, [colName, rowName]) {\n  const rowNum = rect[rowName];\n  const rowMap = tableMap[rowNum];\n  if (!(rowMap !== undefined)) {\n    throw Error(`cellAtCornerOrThrow: ${rowName} = ${String(rowNum)} missing in tableMap`);\n  }\n  const colNum = rect[colName];\n  const cell = rowMap[colNum];\n  if (!(cell !== undefined)) {\n    throw Error(`cellAtCornerOrThrow: ${colName} = ${String(colNum)} missing in tableMap`);\n  }\n  return cell;\n}\nfunction $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue) {\n  // We are sure that the focus now either contracts or expands the rect\n  // but both the anchor and focus might be moved to ensure a rectangle\n  // given a potentially ragged merge shape\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorCorner = getCorner(rect, anchorCellValue);\n  if (anchorCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, anchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(anchorCorner))];\n  }\n  const newFocusCorner = getCorner(rect, newFocusCellValue);\n  if (newFocusCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newFocusCorner)), cellAtCornerOrThrow(tableMap, rect, newFocusCorner)];\n  }\n  // TODO this doesn't have to be arbitrary, use the closest corner instead\n  const newAnchorCorner = ['minColumn', 'minRow'];\n  return [cellAtCornerOrThrow(tableMap, rect, newAnchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newAnchorCorner))];\n}\nfunction $adjustFocusInDirection(tableObserver, tableMap, anchorCellValue, focusCellValue, direction) {\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, focusCellValue);\n  const spans = $computeTableCellRectSpans(tableMap, rect);\n  const {\n    topSpan,\n    leftSpan,\n    bottomSpan,\n    rightSpan\n  } = spans;\n  const anchorCorner = getCornerOrThrow(rect, anchorCellValue);\n  const [focusColumn, focusRow] = oppositeCorner(anchorCorner);\n  let fCol = rect[focusColumn];\n  let fRow = rect[focusRow];\n  if (direction === 'forward') {\n    fCol += focusColumn === 'maxColumn' ? 1 : leftSpan;\n  } else if (direction === 'backward') {\n    fCol -= focusColumn === 'minColumn' ? 1 : rightSpan;\n  } else if (direction === 'down') {\n    fRow += focusRow === 'maxRow' ? 1 : topSpan;\n  } else if (direction === 'up') {\n    fRow -= focusRow === 'minRow' ? 1 : bottomSpan;\n  }\n  const targetRowMap = tableMap[fRow];\n  if (targetRowMap === undefined) {\n    return false;\n  }\n  const newFocusCellValue = targetRowMap[fCol];\n  if (newFocusCellValue === undefined) {\n    return false;\n  }\n  // We can be certain that anchorCellValue and newFocusCellValue are\n  // contained within the desired selection, but we are not certain if\n  // they need to be expanded or not to maintain a rectangular shape\n  const [finalAnchorCell, finalFocusCell] = $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalAnchorCell.cell);\n  const focusDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalFocusCell.cell);\n  tableObserver.$setAnchorCellForSelection(anchorDOM);\n  tableObserver.$setFocusCellForSelection(focusDOM, true);\n  return true;\n}\nfunction $isSelectionInTable(selection, tableNode) {\n  if ($isRangeSelection(selection) || $isTableSelection(selection)) {\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const editorThemeClasses = editor._config.theme;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  addClassNamesToElement(element, editorThemeClasses.tableCellSelected);\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = $getNearestNodeFromDOMNode(element);\n  if (!$isTableCellNode(node)) {\n    throw Error(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const editorThemeClasses = editor._config.theme;\n  removeClassNamesFromElement(element, editorThemeClasses.tableCellSelected);\n}\nfunction $findCellNode(node) {\n  const cellNode = $findMatchingParent(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = $findMatchingParent(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $getBlockParentIfFirstNode(node) {\n  for (let prevNode = node, currentNode = node; currentNode !== null; prevNode = currentNode, currentNode = currentNode.getParent()) {\n    if ($isElementNode(currentNode)) {\n      if (currentNode !== prevNode && currentNode.getFirstChild() !== prevNode) {\n        // Not the first child or the initial node\n        return null;\n      } else if (!currentNode.isInline()) {\n        return currentNode;\n      }\n    }\n  }\n  return null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = $getSelection();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ($isRangeSelection(selection)) {\n      if (direction === 'backward') {\n        if (selection.focus.offset > 0) {\n          return false;\n        }\n        const parentNode = $getBlockParentIfFirstNode(selection.focus.getNode());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        if (event.shiftKey) {\n          selection.focus.set(siblingNode.getParentOrThrow().getKey(), siblingNode.getIndexWithinParent(), 'element');\n        } else {\n          siblingNode.selectEnd();\n        }\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        const isTableUnselect = !selection.isCollapsed() && (direction === 'up' && !selection.isBackward() || direction === 'down' && selection.isBackward());\n        if (isTableUnselect) {\n          let focusParentNode = $findMatchingParent(focusNode, n => $isTableNode(n));\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = $findMatchingParent(focusParentNode, $isTableNode);\n          }\n          if (focusParentNode !== tableNode) {\n            return false;\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if (!sibling) {\n            return false;\n          }\n          let newOffset = 0;\n          if (direction === 'up') {\n            if ($isElementNode(sibling)) {\n              newOffset = sibling.getChildrenSize();\n            }\n          }\n          let newFocusNode = sibling;\n          if (direction === 'up') {\n            if ($isElementNode(sibling)) {\n              const lastCell = sibling.getLastChild();\n              newFocusNode = lastCell ? lastCell : sibling;\n              newOffset = $isTextNode(newFocusNode) ? newFocusNode.getTextContentSize() : 0;\n            }\n          }\n          const newSelection = selection.clone();\n          newSelection.focus.set(newFocusNode.getKey(), newOffset, $isTextNode(newFocusNode) ? 'text' : 'element');\n          $setSelection(newSelection);\n          stopEvent(event);\n          return true;\n        } else if ($isRootOrShadowRoot(focusNode)) {\n          const selectedNode = direction === 'up' ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = $findParentTableCellNodeInTable(tableNode, selectedNode);\n            if (tableCellNode !== null) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.$setAnchorCellForSelection(firstCellDOM);\n              tableObserver.$setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          let focusParentNode = $findMatchingParent(focusNode, n => $isElementNode(n) && !n.isInline());\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = $findMatchingParent(focusParentNode, $isTableNode);\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            stopEvent(event);\n            $setSelection(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    if (direction === 'down' && $isScrollableTablesActive(editor)) {\n      // Enable Firefox workaround\n      tableObserver.setShouldCheckSelection();\n    }\n    return false;\n  }\n  if ($isRangeSelection(selection) && selection.isCollapsed()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n      return false;\n    }\n    const anchorCellTable = $findTableNode(anchorCellNode);\n    if (anchorCellTable !== tableNode && anchorCellTable != null) {\n      const anchorCellTableElement = getTableElement(anchorCellTable, editor.getElementByKey(anchorCellTable.getKey()));\n      if (anchorCellTableElement != null) {\n        tableObserver.table = getTable(anchorCellTable, anchorCellTableElement);\n        return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n      }\n    }\n    if (direction === 'backward' || direction === 'forward') {\n      const anchorType = anchor.type;\n      const anchorOffset = anchor.offset;\n      const anchorNode = anchor.getNode();\n      if (!anchorNode) {\n        return false;\n      }\n      const selectedNodes = selection.getNodes();\n      if (selectedNodes.length === 1 && $isDecoratorNode(selectedNodes[0])) {\n        return false;\n      }\n      if (isExitingTableAnchor(anchorType, anchorOffset, anchorNode, direction)) {\n        return $handleTableExit(event, anchorNode, anchorCellNode, tableNode, direction);\n      }\n      return false;\n    }\n    const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n    const anchorDOM = editor.getElementByKey(anchor.key);\n    if (anchorDOM == null || anchorCellDom == null) {\n      return false;\n    }\n    let edgeSelectionRect;\n    if (anchor.type === 'element') {\n      edgeSelectionRect = anchorDOM.getBoundingClientRect();\n    } else {\n      const domSelection = getDOMSelection(getEditorWindow(editor));\n      if (domSelection === null || domSelection.rangeCount === 0) {\n        return false;\n      }\n      const range = domSelection.getRangeAt(0);\n      edgeSelectionRect = range.getBoundingClientRect();\n    }\n    const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n    if (edgeChild == null) {\n      return false;\n    }\n    const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n    if (edgeChildDOM == null) {\n      return false;\n    }\n    const edgeRect = edgeChildDOM.getBoundingClientRect();\n    const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n    if (isExiting) {\n      stopEvent(event);\n      const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n      if (event.shiftKey) {\n        const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n        tableObserver.$setAnchorCellForSelection(cell);\n        tableObserver.$setFocusCellForSelection(cell, true);\n      } else {\n        return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n      }\n      return true;\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = $findMatchingParent(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = $findMatchingParent(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    if (!$isTableNode(tableNodeFromSelection)) {\n      throw Error(`$handleArrowKey: TableSelection.getNodes()[0] expected to be TableNode`);\n    }\n    const tableElement = getTableElement(tableNodeFromSelection, editor.getElementByKey(tableNodeFromSelection.getKey()));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.$updateTableTableSelection(selection);\n    const grid = getTable(tableNodeFromSelection, tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.$setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const [tableMap, anchorValue, focusValue] = $computeTableMap(tableNode, anchorCellNode, focusCellNode);\n      return $adjustFocusInDirection(tableObserver, tableMap, anchorValue, focusValue, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction isExitingTableAnchor(type, offset, anchorNode, direction) {\n  return isExitingTableElementAnchor(type, anchorNode, direction) || $isExitingTableTextAnchor(type, offset, anchorNode, direction);\n}\nfunction isExitingTableElementAnchor(type, anchorNode, direction) {\n  return type === 'element' && (direction === 'backward' ? anchorNode.getPreviousSibling() === null : anchorNode.getNextSibling() === null);\n}\nfunction $isExitingTableTextAnchor(type, offset, anchorNode, direction) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return false;\n  }\n  const hasValidOffset = direction === 'backward' ? offset === 0 : offset === anchorNode.getTextContentSize();\n  return type === 'text' && hasValidOffset && (direction === 'backward' ? parentNode.getPreviousSibling() === null : parentNode.getNextSibling() === null);\n}\nfunction $handleTableExit(event, anchorNode, anchorCellNode, tableNode, direction) {\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  if (!isExitingCell(tableMap, cellValue, direction)) {\n    return false;\n  }\n  const toNode = $getExitingToNode(anchorNode, direction, tableNode);\n  if (!toNode || $isTableNode(toNode)) {\n    return false;\n  }\n  stopEvent(event);\n  if (direction === 'backward') {\n    toNode.selectEnd();\n  } else {\n    toNode.selectStart();\n  }\n  return true;\n}\nfunction isExitingCell(tableMap, cellValue, direction) {\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startColumn,\n    startRow\n  } = cellValue;\n  return direction === 'backward' ? startColumn === firstCell.startColumn && startRow === firstCell.startRow : startColumn === lastCell.startColumn && startRow === lastCell.startRow;\n}\nfunction $getExitingToNode(anchorNode, direction, tableNode) {\n  const parentNode = $findMatchingParent(anchorNode, n => $isElementNode(n) && !n.isInline());\n  if (!parentNode) {\n    return undefined;\n  }\n  const anchorSibling = direction === 'backward' ? parentNode.getPreviousSibling() : parentNode.getNextSibling();\n  return anchorSibling && $isTableNode(anchorSibling) ? anchorSibling : direction === 'backward' ? tableNode.getPreviousSibling() : tableNode.getNextSibling();\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = $createParagraphNode();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = getDOMSelection(getEditorWindow(editor));\n  if (!domSelection) {\n    return undefined;\n  }\n  const domAnchorNode = domSelection.anchorNode;\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()));\n  // We are only interested in the scenario where the\n  // native selection anchor is:\n  // - at or inside the table's parent DOM\n  // - and NOT at or inside the table DOM\n  // It may be adjacent to the table DOM (e.g. in a wrapper)\n  if (!domAnchorNode || !tableNodeParentDOM || !tableElement || !tableNodeParentDOM.contains(domAnchorNode) || tableElement.contains(domAnchorNode)) {\n    return undefined;\n  }\n  const anchorCellNode = $findMatchingParent(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = $findMatchingParent(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\nfunction $getObserverCellFromCellNodeOrThrow(tableObserver, tableCellNode) {\n  const {\n    tableNode\n  } = tableObserver.$lookup();\n  const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n  return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n}\nfunction $getNearestTableCellInTableFromDOMNode(tableNode, startingDOM, editorState) {\n  return $findParentTableCellNodeInTable(tableNode, $getNearestNodeFromDOMNode(startingDOM, editorState));\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction updateColgroup(dom, config, colCount, colWidths) {\n  const colGroup = dom.querySelector('colgroup');\n  if (!colGroup) {\n    return;\n  }\n  const cols = [];\n  for (let i = 0; i < colCount; i++) {\n    const col = document.createElement('col');\n    const width = colWidths && colWidths[i];\n    if (width) {\n      col.style.width = `${width}px`;\n    }\n    cols.push(col);\n  }\n  colGroup.replaceChildren(...cols);\n}\nfunction setRowStriping(dom, config, rowStriping) {\n  if (rowStriping) {\n    addClassNamesToElement(dom, config.theme.tableRowStriping);\n    dom.setAttribute('data-lexical-row-striping', 'true');\n  } else {\n    removeClassNamesFromElement(dom, config.theme.tableRowStriping);\n    dom.removeAttribute('data-lexical-row-striping');\n  }\n}\nconst scrollableEditors = new WeakSet();\nfunction $isScrollableTablesActive(editor = $getEditor()) {\n  return scrollableEditors.has(editor);\n}\nfunction setScrollableTablesActive(editor, active) {\n  if (active) {\n    if (!editor._config.theme.tableScrollableWrapper) {\n      console.warn('TableNode: hasHorizontalScroll is active but theme.tableScrollableWrapper is not defined.');\n    }\n    scrollableEditors.add(editor);\n  } else {\n    scrollableEditors.delete(editor);\n  }\n}\n\n/** @noInheritDoc */\nclass TableNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'table';\n  }\n  getColWidths() {\n    const self = this.getLatest();\n    return self.__colWidths;\n  }\n  setColWidths(colWidths) {\n    const self = this.getWritable();\n    // NOTE: Node properties should be immutable. Freeze to prevent accidental mutation.\n    self.__colWidths = colWidths !== undefined && true ? Object.freeze(colWidths) : colWidths;\n    return self;\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__colWidths = prevNode.__colWidths;\n    this.__rowStriping = prevNode.__rowStriping;\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setRowStriping(serializedNode.rowStriping || false).setColWidths(serializedNode.colWidths);\n  }\n  constructor(key) {\n    super(key);\n    this.__rowStriping = false;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colWidths: this.getColWidths(),\n      rowStriping: this.__rowStriping ? this.__rowStriping : undefined\n    };\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  getDOMSlot(element) {\n    const tableElement = element.nodeName !== 'TABLE' && element.querySelector('table') || element;\n    if (!(tableElement.nodeName === 'TABLE')) {\n      throw Error(`TableNode.getDOMSlot: createDOM() did not return a table`);\n    }\n    return super.getDOMSlot(tableElement).withAfter(tableElement.querySelector('colgroup'));\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    const colGroup = document.createElement('colgroup');\n    tableElement.appendChild(colGroup);\n    updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());\n    setDOMUnmanaged(colGroup);\n    addClassNamesToElement(tableElement, config.theme.table);\n    if (this.__rowStriping) {\n      setRowStriping(tableElement, config, true);\n    }\n    if ($isScrollableTablesActive(editor)) {\n      const wrapperElement = document.createElement('div');\n      const classes = config.theme.tableScrollableWrapper;\n      if (classes) {\n        addClassNamesToElement(wrapperElement, classes);\n      } else {\n        wrapperElement.style.cssText = 'overflow-x: auto;';\n      }\n      wrapperElement.appendChild(tableElement);\n      return wrapperElement;\n    }\n    return tableElement;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__rowStriping !== this.__rowStriping) {\n      setRowStriping(dom, config, this.__rowStriping);\n    }\n    updateColgroup(dom, config, this.getColumnCount(), this.getColWidths());\n    return false;\n  }\n  exportDOM(editor) {\n    const superExport = super.exportDOM(editor);\n    const {\n      element\n    } = superExport;\n    return {\n      after: tableElement => {\n        if (superExport.after) {\n          tableElement = superExport.after(tableElement);\n        }\n        if (isHTMLElement$1(tableElement) && tableElement.nodeName !== 'TABLE') {\n          tableElement = tableElement.querySelector('table');\n        }\n        if (!isHTMLElement$1(tableElement)) {\n          return null;\n        }\n\n        // Scan the table map to build a map of table cell key to the columns it needs\n        const [tableMap] = $computeTableMapSkipCellCheck(this, null, null);\n        const cellValues = new Map();\n        for (const mapRow of tableMap) {\n          for (const mapValue of mapRow) {\n            const key = mapValue.cell.getKey();\n            if (!cellValues.has(key)) {\n              cellValues.set(key, {\n                colSpan: mapValue.cell.getColSpan(),\n                startColumn: mapValue.startColumn\n              });\n            }\n          }\n        }\n\n        // scan the DOM to find the table cell keys that were used and mark those columns\n        const knownColumns = new Set();\n        for (const cellDOM of tableElement.querySelectorAll(':scope > tr > [data-temporary-table-cell-lexical-key]')) {\n          const key = cellDOM.getAttribute('data-temporary-table-cell-lexical-key');\n          if (key) {\n            const cellSpan = cellValues.get(key);\n            cellDOM.removeAttribute('data-temporary-table-cell-lexical-key');\n            if (cellSpan) {\n              cellValues.delete(key);\n              for (let i = 0; i < cellSpan.colSpan; i++) {\n                knownColumns.add(i + cellSpan.startColumn);\n              }\n            }\n          }\n        }\n\n        // Compute the colgroup and columns in the export\n        const colGroup = tableElement.querySelector(':scope > colgroup');\n        if (colGroup) {\n          // Only include the <col /> for rows that are in the output\n          const cols = Array.from(tableElement.querySelectorAll(':scope > colgroup > col')).filter((dom, i) => knownColumns.has(i));\n          colGroup.replaceChildren(...cols);\n        }\n\n        // Wrap direct descendant rows in a tbody for export\n        const rows = tableElement.querySelectorAll(':scope > tr');\n        if (rows.length > 0) {\n          const tBody = document.createElement('tbody');\n          for (const row of rows) {\n            tBody.appendChild(row);\n          }\n          tableElement.append(tBody);\n        }\n        return tableElement;\n      },\n      element: isHTMLElement$1(element) && element.nodeName !== 'TABLE' ? element.querySelector('table') : element\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      for (let x = 0; x < row.length; x++) {\n        const cell = row[x];\n        if (cell == null) {\n          continue;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = $getNearestTableCellInTableFromDOMNode(this, elem);\n        if (cellNode !== null && tableCellNode.is(cellNode)) {\n          return {\n            x,\n            y\n          };\n        }\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = $getNearestNodeFromDOMNode(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  getRowStriping() {\n    return Boolean(this.getLatest().__rowStriping);\n  }\n  setRowStriping(newRowStriping) {\n    const self = this.getWritable();\n    self.__rowStriping = newRowStriping;\n    return self;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n  getColumnCount() {\n    const firstRow = this.getFirstChild();\n    if (!firstRow) {\n      return 0;\n    }\n    let columnCount = 0;\n    firstRow.getChildren().forEach(cell => {\n      if ($isTableCellNode(cell)) {\n        columnCount += cell.getColSpan();\n      }\n    });\n    return columnCount;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (!(tableElement !== null)) {\n    throw Error(`$getElementForTableNode: Table Element Not Found`);\n  }\n  return getTable(tableNode, tableElement);\n}\nfunction $convertTableElement(domNode) {\n  const tableNode = $createTableNode();\n  if (domNode.hasAttribute('data-lexical-row-striping')) {\n    tableNode.setRowStriping(true);\n  }\n  const colGroup = domNode.querySelector(':scope > colgroup');\n  if (colGroup) {\n    let columns = [];\n    for (const col of colGroup.querySelectorAll(':scope > col')) {\n      let width = col.style.width || '';\n      if (!PIXEL_VALUE_REG_EXP.test(width)) {\n        // Also support deprecated width attribute for google docs\n        width = col.getAttribute('width') || '';\n        if (!/^\\d+$/.test(width)) {\n          columns = undefined;\n          break;\n        }\n      }\n      columns.push(parseFloat(width));\n    }\n    if (columns) {\n      tableNode.setColWidths(columns);\n    }\n  }\n  return {\n    after: children => $descendantsMatching(children, $isTableRowNode),\n    node: tableNode\n  };\n}\nfunction $createTableNode() {\n  return $applyNodeReplacement(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $insertTableCommandListener({\n  rows,\n  columns,\n  includeHeaders\n}) {\n  const tableNode = $createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);\n  $insertNodeToNearestRoot(tableNode);\n  const firstDescendant = tableNode.getFirstDescendant();\n  if ($isTextNode(firstDescendant)) {\n    firstDescendant.select();\n  }\n  return true;\n}\nfunction $tableCellTransform(node) {\n  if (!$isTableRowNode(node.getParent())) {\n    // TableCellNode must be a child of TableRowNode.\n    node.remove();\n  } else if (node.isEmpty()) {\n    // TableCellNode should never be empty\n    node.append($createParagraphNode());\n  }\n}\nfunction $tableRowTransform(node) {\n  if (!$isTableNode(node.getParent())) {\n    // TableRowNode must be a child of TableNode.\n    // TODO: Future support of tbody/thead/tfoot may change this\n    node.remove();\n  } else {\n    $unwrapAndFilterDescendants(node, $isTableCellNode);\n  }\n}\nfunction $tableTransform(node) {\n  // TableRowNode is the only valid child for TableNode\n  // TODO: Future support of tbody/thead/tfoot/caption may change this\n  $unwrapAndFilterDescendants(node, $isTableRowNode);\n  const [gridMap] = $computeTableMapSkipCellCheck(node, null, null);\n  const maxRowLength = gridMap.reduce((curLength, row) => {\n    return Math.max(curLength, row.length);\n  }, 0);\n  const rowNodes = node.getChildren();\n  for (let i = 0; i < gridMap.length; ++i) {\n    const rowNode = rowNodes[i];\n    if (!rowNode) {\n      continue;\n    }\n    if (!$isTableRowNode(rowNode)) {\n      throw Error(`TablePlugin: Expecting all children of TableNode to be TableRowNode, found ${rowNode.constructor.name} (type ${rowNode.getType()})`);\n    }\n    const rowLength = gridMap[i].reduce((acc, cell) => cell ? 1 + acc : acc, 0);\n    if (rowLength === maxRowLength) {\n      continue;\n    }\n    for (let j = rowLength; j < maxRowLength; ++j) {\n      // TODO: inherit header state from another header or body\n      const newCell = $createTableCellNode();\n      newCell.append($createParagraphNode());\n      rowNode.append(newCell);\n    }\n  }\n}\n\n/**\n * Register a transform to ensure that all TableCellNode have a colSpan and rowSpan of 1.\n * This should only be registered when you do not want to support merged cells.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTableCellUnmergeTransform(editor) {\n  return editor.registerNodeTransform(TableCellNode, node => {\n    if (node.getColSpan() > 1 || node.getRowSpan() > 1) {\n      // When we have rowSpan we have to map the entire Table to understand where the new Cells\n      // fit best; let's analyze all Cells at once to save us from further transform iterations\n      const [,, gridNode] = $getNodeTriplet(node);\n      const [gridMap] = $computeTableMap(gridNode, node, node);\n      // TODO this function expects Tables to be normalized. Look into this once it exists\n      const rowsCount = gridMap.length;\n      const columnsCount = gridMap[0].length;\n      let row = gridNode.getFirstChild();\n      if (!$isTableRowNode(row)) {\n        throw Error(`Expected TableNode first child to be a RowNode`);\n      }\n      const unmerged = [];\n      for (let i = 0; i < rowsCount; i++) {\n        if (i !== 0) {\n          row = row.getNextSibling();\n          if (!$isTableRowNode(row)) {\n            throw Error(`Expected TableNode first child to be a RowNode`);\n          }\n        }\n        let lastRowCell = null;\n        for (let j = 0; j < columnsCount; j++) {\n          const cellMap = gridMap[i][j];\n          const cell = cellMap.cell;\n          if (cellMap.startRow === i && cellMap.startColumn === j) {\n            lastRowCell = cell;\n            unmerged.push(cell);\n          } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {\n            if (!$isTableCellNode(cell)) {\n              throw Error(`Expected TableNode cell to be a TableCellNode`);\n            }\n            const newCell = $createTableCellNode(cell.__headerState);\n            if (lastRowCell !== null) {\n              lastRowCell.insertAfter(newCell);\n            } else {\n              $insertFirst$1(row, newCell);\n            }\n          }\n        }\n      }\n      for (const cell of unmerged) {\n        cell.setColSpan(1);\n        cell.setRowSpan(1);\n      }\n    }\n  });\n}\nfunction registerTableSelectionObserver(editor, hasTabHandler = true) {\n  const tableSelections = new Map();\n  const initializeTableNode = (tableNode, nodeKey, dom) => {\n    const tableElement = getTableElement(tableNode, dom);\n    const tableSelection = applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);\n    tableSelections.set(nodeKey, [tableSelection, tableElement]);\n  };\n  const unregisterMutationListener = editor.registerMutationListener(TableNode, nodeMutations => {\n    editor.getEditorState().read(() => {\n      for (const [nodeKey, mutation] of nodeMutations) {\n        const tableSelection = tableSelections.get(nodeKey);\n        if (mutation === 'created' || mutation === 'updated') {\n          const {\n            tableNode,\n            tableElement\n          } = $getTableAndElementByKey(nodeKey);\n          if (tableSelection === undefined) {\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          } else if (tableElement !== tableSelection[1]) {\n            // The update created a new DOM node, destroy the existing TableObserver\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          }\n        } else if (mutation === 'destroyed') {\n          if (tableSelection !== undefined) {\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n          }\n        }\n      }\n    }, {\n      editor\n    });\n  }, {\n    skipInitialization: false\n  });\n  return () => {\n    unregisterMutationListener();\n    // Hook might be called multiple times so cleaning up tables listeners as well,\n    // as it'll be reinitialized during recurring call\n    for (const [, [tableSelection]] of tableSelections) {\n      tableSelection.removeListeners();\n    }\n  };\n}\n\n/**\n * Register the INSERT_TABLE_COMMAND listener and the table integrity transforms. The\n * table selection observer should be registered separately after this with\n * {@link registerTableSelectionObserver}.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTablePlugin(editor) {\n  if (!editor.hasNodes([TableNode])) {\n    {\n      throw Error(`TablePlugin: TableNode is not registered on editor`);\n    }\n  }\n  return mergeRegister(editor.registerCommand(INSERT_TABLE_COMMAND, $insertTableCommandListener, COMMAND_PRIORITY_EDITOR), editor.registerNodeTransform(TableNode, $tableTransform), editor.registerNodeTransform(TableRowNode, $tableRowTransform), editor.registerNodeTransform(TableCellNode, $tableCellTransform));\n}\n\nexport { $computeTableMap, $computeTableMapSkipCellCheck, $createTableCellNode, $createTableNode, $createTableNodeWithDimensions, $createTableRowNode, $createTableSelection, $deleteTableColumn, $deleteTableColumn__EXPERIMENTAL, $deleteTableRow__EXPERIMENTAL, $findCellNode, $findTableNode, $getElementForTableNode, $getNodeTriplet, $getTableAndElementByKey, $getTableCellNodeFromLexicalNode, $getTableCellNodeRect, $getTableColumnIndexFromTableCellNode, $getTableNodeFromLexicalNodeOrThrow, $getTableRowIndexFromTableCellNode, $getTableRowNodeFromTableCellNodeOrThrow, $insertTableColumn, $insertTableColumn__EXPERIMENTAL, $insertTableRow, $insertTableRow__EXPERIMENTAL, $isScrollableTablesActive, $isTableCellNode, $isTableNode, $isTableRowNode, $isTableSelection, $removeTableRowAtIndex, $unmergeCell, INSERT_TABLE_COMMAND, TableCellHeaderStates, TableCellNode, TableNode, TableObserver, TableRowNode, applyTableHandlers, getDOMCellFromTarget, getTableElement, getTableObserverFromTableElement, registerTableCellUnmergeTransform, registerTablePlugin, registerTableSelectionObserver, setScrollableTablesActive };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}