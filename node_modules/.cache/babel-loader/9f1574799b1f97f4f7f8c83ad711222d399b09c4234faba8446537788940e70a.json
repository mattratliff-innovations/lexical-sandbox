{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $isRangeSelection, $getSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getRoot, $parseSerializedNode, $isTextNode, getDOMSelection, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $getEditor, $isElementNode, $cloneWithProperties } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(trustHTML(htmlString), 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = $getSelection();\n        if ($isRangeSelection(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([$createTabNode()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction trustHTML(html) {\n  if (window.trustedTypes && window.trustedTypes.createPolicy) {\n    const policy = window.trustedTypes.createPolicy('lexical', {\n      createHTML: input => input\n    });\n    return policy.createHTML(html);\n  }\n  return html;\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ($isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = $getSelection()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = $getEditor();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getClipboardDataFromSelection, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard, setLexicalClipboardDataTransfer };","map":{"version":3,"names":["$generateHtmlFromNodes","$generateNodesFromDOM","$addNodeStyle","$sliceSelectedTextNodeContent","objectKlassEquals","$isRangeSelection","$getSelection","$createTabNode","SELECTION_INSERT_CLIPBOARD_NODES_COMMAND","$getRoot","$parseSerializedNode","$isTextNode","getDOMSelection","COPY_COMMAND","COMMAND_PRIORITY_CRITICAL","isSelectionWithinEditor","$getEditor","$isElementNode","$cloneWithProperties","$getHtmlContent","editor","selection","Error","isCollapsed","getNodes","length","$getLexicalContent","JSON","stringify","$generateJSONFromSelectedNodes","$insertDataTransferForPlainText","dataTransfer","text","getData","insertRawText","$insertDataTransferForRichText","lexicalString","payload","parse","namespace","_config","Array","isArray","nodes","$generateNodesFromSerializedNodes","$insertGeneratedNodes","_unused","htmlString","parser","DOMParser","dom","parseFromString","trustHTML","_unused2","parts","split","pop","i","currentSelection","part","insertParagraph","insertNodes","insertText","html","window","trustedTypes","createPolicy","policy","createHTML","input","dispatchCommand","exportNodeToJSON","node","serializedNode","exportJSON","nodeClass","constructor","type","getType","name","serializedChildren","children","$appendNodesToJSON","currentNode","targetArray","shouldInclude","isSelected","shouldExclude","excludeFromCopy","target","clone","getChildren","__text","childNode","shouldIncludeChild","extractWithChild","push","serializedChildNode","root","topLevelChildren","topLevelNode","serializedNodes","EVENT_LATENCY","clipboardEventTimeout","copyToClipboard","event","data","Promise","resolve","reject","update","$copyToClipboardEvent","rootElement","getRootElement","windowDocument","_window","document","domSelection","element","createElement","style","cssText","append","createTextNode","range","Range","setStart","setEnd","removeAllRanges","addRange","removeListener","registerCommand","secondEvent","ClipboardEvent","clearTimeout","setTimeout","execCommand","remove","undefined","anchorDOM","anchorNode","focusDOM","focusNode","$getClipboardDataFromSelection","preventDefault","clipboardData","setLexicalClipboardDataTransfer","clipboardDataFunctions","getTextContent","mimeType","$editorFn","v","k","setData"],"sources":["/Users/Matt.Ratliff/Development/lexical-sandbox/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $generateHtmlFromNodes, $generateNodesFromDOM } from '@lexical/html';\nimport { $addNodeStyle, $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { objectKlassEquals } from '@lexical/utils';\nimport { $isRangeSelection, $getSelection, $createTabNode, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, $getRoot, $parseSerializedNode, $isTextNode, getDOMSelection, COPY_COMMAND, COMMAND_PRIORITY_CRITICAL, isSelectionWithinEditor, $getEditor, $isElementNode, $cloneWithProperties } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return $generateHtmlFromNodes(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = $getSelection()) {\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ($isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(trustHTML(htmlString), 'text/html');\n      const nodes = $generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ($isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = $getSelection();\n        if ($isRangeSelection(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([$createTabNode()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction trustHTML(html) {\n  if (window.trustedTypes && window.trustedTypes.createPolicy) {\n    const policy = window.trustedTypes.createPolicy('lexical', {\n      createHTML: input => input\n    });\n    return policy.createHTML(html);\n  }\n  return html;\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n  }\n  return;\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ($isTextNode(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = $parseSerializedNode(serializedNode);\n    if ($isTextNode(node)) {\n      $addNodeStyle(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(COPY_COMMAND, secondEvent => {\n      if (objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    const selection = $getSelection();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = $getSelection()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = $getEditor();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\n\nexport { $generateJSONFromSelectedNodes, $generateNodesFromSerializedNodes, $getClipboardDataFromSelection, $getHtmlContent, $getLexicalContent, $insertDataTransferForPlainText, $insertDataTransferForRichText, $insertGeneratedNodes, copyToClipboard, setLexicalClipboardDataTransfer };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}