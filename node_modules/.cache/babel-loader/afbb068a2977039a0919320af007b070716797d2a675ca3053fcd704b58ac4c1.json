{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { isHTMLElement, isBlockDomNode } from '@lexical/utils';\nimport { $getRoot, $isElementNode, $cloneWithProperties, $isTextNode, isDocumentFragment, $isRootOrShadowRoot, $isBlockElementNode, $createLineBreakNode, ArtificialNode__DO_NOT_USE, isInlineDomNode, $createParagraphNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificalNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element) || isDocumentFragment(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        if (isDocumentFragment(element)) {\n          element.replaceChildren(newElement);\n        } else {\n          element.replaceWith(newElement);\n        }\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null ||\n      // Given equal priority, prefer the last registered importer\n      // which is typically an application custom node or HTMLConfig['import']\n      (currentConversion.priority || 0) <= (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (isBlockDomNode(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    if (childLexicalNodes.length > 0) {\n      // If it hasn't been converted to a LexicalNode, we hoist its children\n      // up to the same level as it.\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if (isBlockDomNode(node) && isDomNodeBetweenTwoInlineNodes(node)) {\n        // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes\n        lexicalNodes = lexicalNodes.concat($createLineBreakNode());\n      }\n    }\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isBlockElementNode(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && $isBlockElementNode(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificalNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE) {\n      node.insertAfter($createLineBreakNode());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\nfunction isDomNodeBetweenTwoInlineNodes(node) {\n  if (node.nextSibling == null || node.previousSibling == null) {\n    return false;\n  }\n  return isInlineDomNode(node.nextSibling) && isInlineDomNode(node.previousSibling);\n}\nexport { $generateHtmlFromNodes, $generateNodesFromDOM };","map":{"version":3,"names":["$sliceSelectedTextNodeContent","isHTMLElement","isBlockDomNode","$getRoot","$isElementNode","$cloneWithProperties","$isTextNode","isDocumentFragment","$isRootOrShadowRoot","$isBlockElementNode","$createLineBreakNode","ArtificialNode__DO_NOT_USE","isInlineDomNode","$createParagraphNode","$generateNodesFromDOM","editor","dom","elements","body","childNodes","lexicalNodes","allArtificialNodes","i","length","element","IGNORE_TAGS","has","nodeName","lexicalNode","$createNodesFromDOM","concat","$unwrapArtificalNodes","$generateHtmlFromNodes","selection","document","window","global","Error","container","createElement","root","topLevelChildren","getChildren","topLevelNode","$appendNodesToHTML","innerHTML","currentNode","parentElement","shouldInclude","isSelected","shouldExclude","excludeFromCopy","target","clone","children","registeredNode","_nodes","get","getType","exportOutput","exportDOM","undefined","after","fragment","createDocumentFragment","childNode","shouldIncludeChild","extractWithChild","append","newElement","call","replaceChildren","replaceWith","getConversionFunction","domNode","cachedConversions","_htmlConversions","toLowerCase","currentConversion","cachedConversion","domConversion","priority","conversion","Set","node","hasBlockAncestorLexicalNode","forChildMap","Map","parentLexicalNode","currentLexicalNode","transformFunction","transformOutput","postTransform","transformNodes","Array","isArray","forChildFunction","push","forChild","set","childLexicalNodes","hasBlockAncestorLexicalNodeForChildren","wrapContinuousInlines","artificialNode","isDomNodeBetweenTwoInlineNodes","nodes","createWrapperFn","textAlign","style","out","continuousInlines","getFormat","setFormat","wrapper","getNextSibling","insertAfter","child","insertBefore","remove","nextSibling","previousSibling"],"sources":["/Users/Matt.Ratliff/Development/lexical-sandbox/node_modules/@lexical/html/LexicalHtml.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $sliceSelectedTextNodeContent } from '@lexical/selection';\nimport { isHTMLElement, isBlockDomNode } from '@lexical/utils';\nimport { $getRoot, $isElementNode, $cloneWithProperties, $isTextNode, isDocumentFragment, $isRootOrShadowRoot, $isBlockElementNode, $createLineBreakNode, ArtificialNode__DO_NOT_USE, isInlineDomNode, $createParagraphNode } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificalNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = $getRoot();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = $isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = $cloneWithProperties(currentNode);\n    clone = $isTextNode(clone) && selection !== null ? $sliceSelectedTextNodeContent(selection, clone) : clone;\n    target = clone;\n  }\n  const children = $isElementNode(target) ? target.getChildren() : [];\n  const registeredNode = editor._nodes.get(target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && $isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if (isHTMLElement(element) || isDocumentFragment(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        if (isDocumentFragment(element)) {\n          element.replaceChildren(newElement);\n        } else {\n          element.replaceWith(newElement);\n        }\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null ||\n      // Given equal priority, prefer the last registered importer\n      // which is typically an application custom node or HTMLConfig['import']\n      (currentConversion.priority || 0) <= (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && $isRootOrShadowRoot(currentLexicalNode) ? false : currentLexicalNode != null && $isBlockElementNode(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if (isBlockDomNode(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, $createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    if (childLexicalNodes.length > 0) {\n      // If it hasn't been converted to a LexicalNode, we hoist its children\n      // up to the same level as it.\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if (isBlockDomNode(node) && isDomNodeBetweenTwoInlineNodes(node)) {\n        // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes\n        lexicalNodes = lexicalNodes.concat($createLineBreakNode());\n      }\n    }\n  } else {\n    if ($isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isBlockElementNode(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && $isBlockElementNode(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificalNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof ArtificialNode__DO_NOT_USE) {\n      node.insertAfter($createLineBreakNode());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\nfunction isDomNodeBetweenTwoInlineNodes(node) {\n  if (node.nextSibling == null || node.previousSibling == null) {\n    return false;\n  }\n  return isInlineDomNode(node.nextSibling) && isInlineDomNode(node.previousSibling);\n}\n\nexport { $generateHtmlFromNodes, $generateNodesFromDOM };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}