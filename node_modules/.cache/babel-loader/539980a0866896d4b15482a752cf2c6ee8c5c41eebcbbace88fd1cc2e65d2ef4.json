{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createCommand(type) {\n  return {\n    type\n  };\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand('SELECTION_INSERT_CLIPBOARD_NODES_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3;\nconst DOM_DOCUMENT_TYPE = 9;\nconst DOM_DOCUMENT_FRAGMENT_TYPE = 11;\n\n// Reconciling\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2;\n\n// Text node modes\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_LOWERCASE = 1 << 8;\nconst IS_UPPERCASE = 1 << 9;\nconst IS_CAPITALIZE = 1 << 10;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT | IS_LOWERCASE | IS_UPPERCASE | IS_CAPITALIZE;\n\n// Text node details\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6;\n\n// Reconciliation\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  capitalize: IS_CAPITALIZE,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  lowercase: IS_LOWERCASE,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE,\n  uppercase: IS_UPPERCASE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcessingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  const isBR = dom.nodeName === 'BR';\n  const lexicalLineBreak = target.__lexicalLineBreak;\n  return lexicalLineBreak && (dom === lexicalLineBreak || isBR && dom.previousSibling === lexicalLineBreak) || isBR && getNodeKeyFromDOMNode(dom, editor) !== undefined;\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction $handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return isDOMTextNode(targetDOM) && targetNode.isAttached();\n}\nfunction $getNearestManagedNodePairFromDOMNode(startingDOM, editor, editorState, rootElement) {\n  for (let dom = startingDOM; dom && !isDOMUnmanaged(dom); dom = getParentElement(dom)) {\n    const key = getNodeKeyFromDOMNode(dom, editor);\n    if (key !== undefined) {\n      const node = $getNodeByKey(key, editorState);\n      if (node) {\n        // All decorator nodes are unmanaged\n        return $isDecoratorNode(node) || !isHTMLElement(dom) ? undefined : [dom, node];\n      }\n    } else if (dom === rootElement) {\n      return [rootElement, internalGetRoot(editorState)];\n    }\n  }\n}\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        const pair = $getNearestManagedNodePairFromDOMNode(targetDOM, editor, currentEditorState, rootElement);\n        if (!pair) {\n          continue;\n        }\n        const [nodeDOM, targetNode] = pair;\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && isDOMTextNode(targetDOM) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            $handleTextMutation(targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = $getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && !isManagedLineBreak(addedDOM, parentDOM, editor)) {\n              if (IS_FIREFOX) {\n                const possibleText = (isHTMLElement(addedDOM) ? addedDOM.innerText : null) || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              badDOMTargets.set(nodeDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [nodeDOM, targetNode] of badDOMTargets) {\n          targetNode.reconcileObservedMutation(nodeDOM, editor);\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction $flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet keyCounter = 1;\nfunction resetRandomKey() {\n  keyCounter = 1;\n}\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (!isHTMLElement(activeElement)) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' && getEditorPropertyFromDOMNode(activeElement) == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * @returns true if the given argument is a LexicalEditor instance from this build of Lexical\n */\nfunction isLexicalEditor(editor) {\n  // Check instanceof to prevent issues with multiple embedded Lexical installations\n  return editor instanceof LexicalEditor;\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const editor = getEditorPropertyFromDOMNode(currentNode);\n    if (isLexicalEditor(editor)) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\n\n/** @internal */\nfunction getEditorPropertyFromDOMNode(node) {\n  // @ts-expect-error: internal field\n  return node ? node.__lexicalEditor : null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\n\n/**\n * @param node - The element being tested\n * @returns Returns true if node is an DOM Text node, false otherwise.\n */\nfunction isDOMTextNode(node) {\n  return isDOMNode(node) && node.nodeType === DOM_TEXT_TYPE;\n}\n\n/**\n * @param node - The element being tested\n * @returns Returns true if node is an DOM Document node, false otherwise.\n */\nfunction isDOMDocumentNode(node) {\n  return isDOMNode(node) && node.nodeType === DOM_DOCUMENT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {\n    return format;\n  }\n  let newFormat = format ^ activeFormat;\n  if (type === 'subscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;\n  } else if (type === 'superscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;\n  } else if (type === 'lowercase') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;\n  } else if (type === 'uppercase') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;\n  } else if (type === 'capitalize') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;\n  }\n  return newFormat;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    {\n      errorOnNodeKeyConstructorMismatch(node, existingKey);\n    }\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction errorOnNodeKeyConstructorMismatch(node, existingKey) {\n  const editorState = internalGetActiveEditorState();\n  if (!editorState) {\n    // tests expect to be able to do this kind of clone without an active editor state\n    return;\n  }\n  const existingNode = editorState._nodeMap.get(existingKey);\n  if (existingNode && existingNode.constructor !== node.constructor) {\n    // Lifted condition to if statement because the inverted logic is a bit confusing\n    if (node.constructor.name !== existingNode.constructor.name) {\n      {\n        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with constructor ${existingNode.constructor.name}. Keys must not be re-used when the type is changed.`);\n      }\n    } else {\n      {\n        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.`);\n      }\n    }\n  }\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\n// TODO #6031 this function or their callers have to adjust selection (i.e. insertBefore)\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction $getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor();\n  const key = getNodeKeyFromDOMNode(dom, editor);\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction setNodeKeyOnDOMNode(dom, editor, key) {\n  const prop = `__lexicalKey_${editor._key}`;\n  dom[prop] = key;\n}\nfunction getNodeKeyFromDOMNode(dom, editor) {\n  const prop = `__lexicalKey_${editor._key}`;\n  return dom[prop];\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = $getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markNodesWithTypesAsDirty(editor, types) {\n  // We only need to mark nodes dirty if they were in the previous state.\n  // If they aren't, then they are by definition dirty already.\n  const cachedMap = getCachedTypeToNodeMap(editor.getEditorState());\n  const dirtyNodeMaps = [];\n  for (const type of types) {\n    const nodeMap = cachedMap.get(type);\n    if (nodeMap) {\n      // By construction these are non-empty\n      dirtyNodeMaps.push(nodeMap);\n    }\n  }\n  // Nothing to mark dirty, no update necessary\n  if (dirtyNodeMaps.length === 0) {\n    return;\n  }\n  editor.update(() => {\n    for (const nodeMap of dirtyNodeMaps) {\n      for (const nodeKey of nodeMap.keys()) {\n        // We are only concerned with nodes that are still in the latest NodeMap,\n        // if they no longer exist then markDirty would raise an exception\n        const latest = $getNodeByKey(nodeKey);\n        if (latest) {\n          latest.markDirty();\n        }\n      }\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection.setCachedNodes(null);\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  $flushRootMutations(editor);\n}\nfunction $getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOMTree(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\nfunction getNodeKeyFromDOMTree(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    const key = getNodeKeyFromDOMNode(node, editor);\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  return isDOMTextNode(anchorNode) ? anchorNode.nodeValue : null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() && !node.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() && !node.isComposing() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(key, altKey, ctrlKey, metaKey) {\n  return key === 'Tab' && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'b' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'i' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'u' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(key, shiftKey) {\n  return isReturn(key) && !shiftKey;\n}\nfunction isLineBreak(key, shiftKey) {\n  return isReturn(key) && shiftKey;\n}\n\n// Inserts a new line after the selection\n\nfunction isOpenLineBreak(key, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && key.toLowerCase() === 'o';\n}\nfunction isDeleteWordBackward(key, altKey, ctrlKey) {\n  return isBackspace(key) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(key, altKey, ctrlKey) {\n  return isDelete(key) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(key, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(key);\n}\nfunction isDeleteLineForward(key, metaKey) {\n  return IS_APPLE && metaKey && isDelete(key);\n}\nfunction isDeleteBackward(key, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n    return isBackspace(key) || key.toLowerCase() === 'h' && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isBackspace(key);\n}\nfunction isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n    return isDelete(key) || key.toLowerCase() === 'd' && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isDelete(key);\n}\nfunction isUndo(key, shiftKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'z' && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(key, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return key.toLowerCase() === 'z' && metaKey && shiftKey;\n  }\n  return key.toLowerCase() === 'y' && ctrlKey || key.toLowerCase() === 'z' && ctrlKey && shiftKey;\n}\nfunction isCopy(key, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'c') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isCut(key, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'x') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isArrowLeft(key) {\n  return key === 'ArrowLeft';\n}\nfunction isArrowRight(key) {\n  return key === 'ArrowRight';\n}\nfunction isArrowUp(key) {\n  return key === 'ArrowUp';\n}\nfunction isArrowDown(key) {\n  return key === 'ArrowDown';\n}\nfunction isMoveBackward(key, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(key) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(key, ctrlKey, altKey, metaKey) {\n  return isArrowRight(key) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(key, ctrlKey, metaKey) {\n  return isArrowUp(key) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(key, ctrlKey, metaKey) {\n  return isArrowDown(key) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(key) {\n  return key === ' ';\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\nfunction isReturn(key) {\n  return key === 'Enter';\n}\nfunction isBackspace(key) {\n  return key === 'Backspace';\n}\nfunction isEscape(key) {\n  return key === 'Escape';\n}\nfunction isDelete(key) {\n  return key === 'Delete';\n}\nfunction isSelectAll(key, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'a' && controlOrMeta(metaKey, ctrlKey);\n}\nfunction $selectAll(selection) {\n  const root = $getRoot();\n  if ($isRangeSelection(selection)) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const topParent = anchorNode.getTopLevelElementOrThrow();\n    const rootNode = topParent.getParentOrThrow();\n    anchor.set(rootNode.getKey(), 0, 'element');\n    focus.set(rootNode.getKey(), rootNode.getChildrenSize(), 'element');\n    $normalizeSelection(selection);\n    return selection;\n  } else {\n    // Create a new RangeSelection\n    const newSelection = root.select(0, root.getChildrenSize());\n    $setSelection($normalizeSelection(newSelection));\n    return newSelection;\n  }\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = normalizeClassNames(classNames);\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\n/**\n * @deprecated Use {@link LexicalEditor.registerMutationListener} with `skipInitialization: false` instead.\n */\nfunction $nodesOfType(klass) {\n  const klassType = klass.getType();\n  const editorState = getActiveEditorState();\n  if (editorState._readOnly) {\n    const nodes = getCachedTypeToNodeMap(editorState).get(klassType);\n    return nodes ? Array.from(nodes.values()) : [];\n  }\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && node.isAttached()) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return isDocumentFragment(parentElement) ? parentElement.host : parentElement;\n}\nfunction getDOMOwnerDocument(target) {\n  return isDOMDocumentNode(target) ? target : isHTMLElement(target) ? target.ownerDocument : null;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = getDOMOwnerDocument(rootElement);\n  const defaultView = getDefaultView(doc);\n  if (doc === null || defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\n\n/**\n * Add a function to run after the current update. This will run after any\n * `onUpdate` function already supplied to `editor.update()`, as well as any\n * functions added with previous calls to `$onUpdate`.\n *\n * @param updateFn The function to run after the current update.\n */\nfunction $onUpdate(updateFn) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._deferred.push(updateFn);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = getDOMOwnerDocument(domElem);\n  return ownerDoc ? ownerDoc.defaultView : null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\n\n/**\n * Returns a shallow clone of node with a new key\n *\n * @param node - The node to be copied.\n * @returns The copy of the node.\n */\nfunction $copyNode(node) {\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n  const registeredNode = editor._nodes.get(nodeType);\n  if (!(registeredNode !== undefined)) {\n    throw Error(`$applyNodeReplacement node ${node.constructor.name} with type ${nodeType} must be registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n  }\n  const {\n    replace,\n    replaceWithKlass\n  } = registeredNode;\n  if (replace !== null) {\n    const replacementNode = replace(node);\n    const replacementNodeKlass = replacementNode.constructor;\n    if (replaceWithKlass !== null) {\n      if (!(replacementNode instanceof replaceWithKlass)) {\n        throw Error(`$applyNodeReplacement failed. Expected replacement node to be an instance of ${replaceWithKlass.name} with type ${replaceWithKlass.getType()} but returned ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} from original node ${node.constructor.name} with type ${nodeType}`);\n      }\n    } else {\n      if (!(replacementNode instanceof node.constructor && replacementNodeKlass !== node.constructor)) {\n        throw Error(`$applyNodeReplacement failed. Ensure replacement node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} is a subclass of the original node ${node.constructor.name} with type ${nodeType}.`);\n      }\n    }\n    if (!(replacementNode.__key !== node.__key)) {\n      throw Error(`$applyNodeReplacement failed. Ensure that the key argument is *not* used in your replace function (from node ${node.constructor.name} with type ${nodeType} to node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()}), Node keys must never be re-used except by the static clone method.`);\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction $getNodeByKeyOrThrow(key) {\n  const node = $getNodeByKey(key);\n  if (node === null) {\n    {\n      throw Error(`Expected node with key ${key} to exist but it's not in the nodeMap.`);\n    }\n  }\n  return node;\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = normalizeClassNames(blockCursorTheme);\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (child !== null && needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\n\n/**\n * Returns the selection for the given window, or the global window if null.\n * Will return null if {@link CAN_USE_DOM} is false.\n *\n * @param targetWindow The window to get the selection from\n * @returns a Selection or null\n */\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\n\n/**\n * Returns the selection for the defaultView of the ownerDocument of given EventTarget.\n *\n * @param eventTarget The node to get the selection from\n * @returns a Selection or null\n */\nfunction getDOMSelectionFromTarget(eventTarget) {\n  const defaultView = getDefaultView(eventTarget);\n  return defaultView ? defaultView.getSelection() : null;\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {\n        throw Error(`Children of a root must be ElementNode`);\n      }\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML element, false otherwise.\n */\nfunction isHTMLElement(x) {\n  return isDOMNode(x) && x.nodeType === DOM_ELEMENT_TYPE;\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is a DOM Node, false otherwise.\n */\nfunction isDOMNode(x) {\n  return typeof x === 'object' && x !== null && 'nodeType' in x && typeof x.nodeType === 'number';\n}\n\n/**\n * @param x - The element being testing\n * @returns Returns true if x is a document fragment, false otherwise.\n */\nfunction isDocumentFragment(x) {\n  return isDOMNode(x) && x.nodeType === DOM_DOCUMENT_FRAGMENT_TYPE;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is an inline node\n */\nfunction isInlineDomNode(node) {\n  const inlineNodes = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, 'i');\n  return node.nodeName.match(inlineNodes) !== null;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is a block node\n */\nfunction isBlockDomNode(node) {\n  const blockNodes = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, 'i');\n  return node.nodeName.match(blockNodes) !== null;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isDecoratorNode(node) && !node.isInline()) {\n    return true;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Utility function for accessing current active editor instance.\n * @returns Current active editor\n */\nfunction $getEditor() {\n  return getActiveEditor();\n}\n\n/** @internal */\n\n/**\n * @internal\n * Compute a cached Map of node type to nodes for a frozen EditorState\n */\nconst cachedNodeMaps = new WeakMap();\nconst EMPTY_TYPE_TO_NODE_MAP = new Map();\nfunction getCachedTypeToNodeMap(editorState) {\n  // If this is a new Editor it may have a writable this._editorState\n  // with only a 'root' entry.\n  if (!editorState._readOnly && editorState.isEmpty()) {\n    return EMPTY_TYPE_TO_NODE_MAP;\n  }\n  if (!editorState._readOnly) {\n    throw Error(`getCachedTypeToNodeMap called with a writable EditorState`);\n  }\n  let typeToNodeMap = cachedNodeMaps.get(editorState);\n  if (!typeToNodeMap) {\n    typeToNodeMap = computeTypeToNodeMap(editorState);\n    cachedNodeMaps.set(editorState, typeToNodeMap);\n  }\n  return typeToNodeMap;\n}\n\n/**\n * @internal\n * Compute a Map of node type to nodes for an EditorState\n */\nfunction computeTypeToNodeMap(editorState) {\n  const typeToNodeMap = new Map();\n  for (const [nodeKey, node] of editorState._nodeMap) {\n    const nodeType = node.__type;\n    let nodeMap = typeToNodeMap.get(nodeType);\n    if (!nodeMap) {\n      nodeMap = new Map();\n      typeToNodeMap.set(nodeType, nodeMap);\n    }\n    nodeMap.set(nodeKey, node);\n  }\n  return typeToNodeMap;\n}\n\n/**\n * Returns a clone of a node using `node.constructor.clone()` followed by\n * `clone.afterCloneFrom(node)`. The resulting clone must have the same key,\n * parent/next/prev pointers, and other properties that are not set by\n * `node.constructor.clone` (format, style, etc.). This is primarily used by\n * {@link LexicalNode.getWritable} to create a writable version of an\n * existing node. The clone is the same logical node as the original node,\n * do not try and use this function to duplicate or copy an existing node.\n *\n * Does not mutate the EditorState.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\nfunction $cloneWithProperties(latestNode) {\n  const constructor = latestNode.constructor;\n  const mutableNode = constructor.clone(latestNode);\n  mutableNode.afterCloneFrom(latestNode);\n  {\n    if (!(mutableNode.__key === latestNode.__key)) {\n      throw Error(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') did not return a node with the same key, make sure to specify node.__key as the last argument to the constructor`);\n    }\n    if (!(mutableNode.__parent === latestNode.__parent && mutableNode.__next === latestNode.__next && mutableNode.__prev === latestNode.__prev)) {\n      throw Error(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') overrided afterCloneFrom but did not call super.afterCloneFrom(prevNode)`);\n    }\n  }\n  return mutableNode;\n}\nfunction setNodeIndentFromDOM(elementDom, elementNode) {\n  const indentSize = parseInt(elementDom.style.paddingInlineStart, 10) || 0;\n  const indent = indentSize / 40;\n  elementNode.setIndent(indent);\n}\n\n/**\n * @internal\n *\n * Mark this node as unmanaged by lexical's mutation observer like\n * decorator nodes\n */\nfunction setDOMUnmanaged(elementDom) {\n  const el = elementDom;\n  el.__lexicalUnmanaged = true;\n}\n\n/**\n * @internal\n *\n * True if this DOM node was marked with {@link setDOMUnmanaged}\n */\nfunction isDOMUnmanaged(elementDom) {\n  const el = elementDom;\n  return el.__lexicalUnmanaged === true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key;\n    // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMapDelete.push(childKey);\n    }\n    child = child.getNextSibling();\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n  const nodeMapDelete = [];\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        }\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet subTreeTextFormat = null;\nlet subTreeTextStyle = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '40px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction $createNode(key, slot) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      $createChildrenWithDirection(children, endIndex, node, dom);\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (slot !== null) {\n    slot.insertChild(dom);\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction $createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  $createChildren(children, element, 0, endIndex, element.getDOMSlot(dom));\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\nfunction $createChildren(children, element, _startIndex, endIndex, slot) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    $createNode(children[startIndex], slot);\n    const node = activeNextNodeMap.get(children[startIndex]);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  const dom = slot.element;\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(element, nodeMap) {\n  if (element) {\n    const lastKey = element.__last;\n    if (lastKey) {\n      const node = nodeMap.get(lastKey);\n      if (node) {\n        return $isLineBreakNode(node) ? 'line-break' : $isDecoratorNode(node) && node.isInline() ? 'decorator' : null;\n      }\n    }\n    return 'empty';\n  }\n  return null;\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = isLastChildLineBreakOrDecorator(prevElement, activePrevNodeMap);\n  const nextLineBreak = isLastChildLineBreakOrDecorator(nextElement, activeNextNodeMap);\n  if (prevLineBreak !== nextLineBreak) {\n    nextElement.getDOMSlot(dom).setManagedLineBreak(nextLineBreak);\n  }\n}\nfunction reconcileTextFormat(element) {\n  if (subTreeTextFormat != null && subTreeTextFormat !== element.__textFormat && !activeEditorStateReadOnly) {\n    element.setTextFormat(subTreeTextFormat);\n    element.setTextStyle(subTreeTextStyle);\n  }\n}\nfunction reconcileTextStyle(element) {\n  if (subTreeTextStyle !== '' && subTreeTextStyle !== element.__textStyle && !activeEditorStateReadOnly) {\n    element.setTextStyle(subTreeTextStyle);\n  }\n}\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent || '';\n  const previousDirection = dom.__lexicalDir || '';\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined;\n\n      // Remove the old theme classes if they exist\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = normalizeClassNames(previousDirectionTheme);\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        }\n\n        // @ts-ignore: intentional\n        classList.remove(...previousDirectionTheme);\n      }\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = normalizeClassNames(nextDirectionTheme);\n            // @ts-expect-error: intentional\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        }\n\n        // Update direction\n        dom.dir = direction;\n      }\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n    activeTextDirection = direction;\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;\n    dom.__lexicalDir = direction;\n  }\n}\nfunction $reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  subTreeTextFormat = null;\n  subTreeTextStyle = '';\n  $reconcileChildren(prevElement, nextElement, nextElement.getDOMSlot(dom));\n  reconcileBlockDirection(nextElement, dom);\n  reconcileTextFormat(nextElement);\n  reconcileTextStyle(nextElement);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction $reconcileChildren(prevElement, nextElement, slot) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  const dom = slot.element;\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFirstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFirstChildKey) {\n      $reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = $createNode(nextFirstChildKey, null);\n      try {\n        dom.replaceChild(replacementDOM, lastDOM);\n      } catch (error) {\n        if (typeof error === 'object' && error != null) {\n          const msg = `${error.toString()} Parent: ${dom.tagName}, new child: {tag: ${replacementDOM.tagName} key: ${nextFirstChildKey}}, old child: {tag: ${lastDOM.tagName}, key: ${prevFirstChildKey}}.`;\n          throw new Error(msg);\n        } else {\n          throw error;\n        }\n      }\n      destroyNode(prevFirstChildKey, null);\n    }\n    const nextChildNode = activeNextNodeMap.get(nextFirstChildKey);\n    if ($isTextNode(nextChildNode)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = nextChildNode.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = nextChildNode.getStyle();\n      }\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (!(prevChildren.length === prevChildrenSize)) {\n      throw Error(`$reconcileChildren: prevChildren.length !== prevChildrenSize`);\n    }\n    if (!(nextChildren.length === nextChildrenSize)) {\n      throw Error(`$reconcileChildren: nextChildren.length !== nextChildrenSize`);\n    }\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        $createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, slot);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        const canUseFastPath = slot.after == null && slot.before == null && slot.element.__lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, slot);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction $reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = $createNode(key, null);\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      $reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    const nextRootNode = nextNode.getWritable();\n    nextRootNode.__cachedText = editorTextContent;\n    nextNode = nextRootNode;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, slot) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = slot.getFirstChild();\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, slot.element);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        $createNode(nextKey, slot.withBefore(siblingDOM));\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));\n        } else {\n          slot.withBefore(siblingDOM).insertChild(childDOM);\n          $reconcileNode(nextKey, slot.element);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n    const node = activeNextNodeMap.get(nextKey);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    $createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, slot.withBefore(insertDOM));\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, slot.element);\n  }\n}\nfunction $reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  $reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor$1 = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap;\n  setNodeKeyOnDOMNode(dom, editor, key);\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = null;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nconst rootElementsRegistered = new WeakMap();\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\n\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return isDOMTextNode(domNode) && domNode.nodeValue !== null && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    const selection = $getSelection();\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range – then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        const root = $getRoot();\n        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === '';\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Point.getNode() must return TextNode when type is text`);\n            }\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element' && !isRootTextContentEmpty) {\n            if (!$isElementNode(anchorNode)) {\n              throw Error(`Point.getNode() must return ElementNode when type is element`);\n            }\n            const lastNode = anchor.getNode();\n            selection.style = '';\n            if (\n            // This previously applied to all ParagraphNode\n            lastNode.isEmpty()) {\n              selection.format = lastNode.getTextFormat();\n              selection.style = lastNode.getTextStyle();\n            } else {\n              selection.format = 0;\n            }\n          }\n        }\n      } else {\n        const anchorKey = anchor.key;\n        const focus = selection.focus;\n        const focusKey = focus.key;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        const isBackward = selection.isBackward();\n        const startOffset = isBackward ? focusOffset : anchorOffset;\n        const endOffset = isBackward ? anchorOffset : focusOffset;\n        const startKey = isBackward ? focusKey : anchorKey;\n        const endKey = isBackward ? anchorKey : focusKey;\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          const textContentSize = node.getTextContentSize();\n          if ($isTextNode(node) && textContentSize !== 0 &&\n          // Exclude empty text nodes at boundaries resulting from user's selection\n          !(i === 0 && node.__key === startKey && startOffset === textContentSize || i === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Triple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n          if (anchorNode !== focusNode) {\n            if ($isElementNode(anchorNode)) {\n              anchorNode.select(0);\n            } else {\n              anchorNode.getParentOrThrow().select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n        // If the user is attempting to click selection back onto text, then\n        // we should attempt create a range selection.\n        // When we click on an empty paragraph node or the end of a paragraph that ends\n        // with an image/poll, the nodeType will be ELEMENT_NODE\n        if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {\n          const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, editor, event);\n          $setSelection(newSelection);\n        }\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (isDOMNode(target) && pointerType !== 'touch' && event.button === 0) {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n  const targetRanges = event.getTargetRanges();\n  if (targetRanges.length === 0) {\n    return null;\n  }\n  return targetRanges[0];\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 'MediaLast' && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event);\n\n  // We let the browser do its own thing for composition.\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Anchor node must be a TextNode`);\n            }\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          $setCompositionKey(null);\n          event.preventDefault();\n          // Chromium Android at the moment seems to ignore the preventDefault\n          // on 'deleteContentBackward' and still deletes the content. Which leads\n          // to multiple deletions. So we let the browser handle the deletion in this case.\n          const selectedNode = selection.anchor.getNode();\n          const selectedNodeText = selectedNode.getTextContent();\n          // When the target node has `canInsertTextAfter` set to false, the first deletion\n          // doesn't have an effect, so we need to handle it with Lexical.\n          const selectedNodeCanInsertTextAfter = selectedNode.canInsertTextAfter();\n          const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;\n          const shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode && selectedNodeCanInsertTextAfter;\n          if (!shouldLetBrowserHandleDelete) {\n            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n          }\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n\n          // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n      // NO-OP\n    }\n  });\n}\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection === null) {\n        return;\n      }\n      const isBackward = selection.isBackward();\n      const startOffset = isBackward ? selection.anchor.offset : selection.focus.offset;\n      const endOffset = isBackward ? selection.focus.offset : selection.anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, startOffset) + data + anchorNode.getTextContent().slice(startOffset + endOffset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction $onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      $onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.key;\n  if (editor.isComposing()) {\n    return;\n  }\n  const {\n    key,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (key == null) {\n    return;\n  }\n  if (isMoveForward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(key, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(key)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(key, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(key, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(key, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(key)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(key)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(key)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(key, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if (prevSelection !== null && !$isRangeSelection(prevSelection)) {\n      // Only RangeSelection can use the native cut/copy/select all\n      if (isCopy(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(key, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      }\n      // FF does it well (no need to override behavior)\n    } else if (!IS_FIREFOX && isSelectAll(key, metaKey, ctrlKey)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const domSelection = getDOMSelectionFromTarget(event.target);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {\n        // If the user is attempting to click selection back onto text, then\n        // we should attempt create a range selection.\n        // When we click on an empty paragraph node or the end of a paragraph that ends\n        // with an image/poll, the nodeType will be ELEMENT_NODE\n        const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);\n        $setSelection(newSelection);\n      }\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (documentRootElementsCount === undefined || documentRootElementsCount < 1) {\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered.set(doc, (documentRootElementsCount || 0) + 1);\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable() || eventName === 'click') {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      const isEditable = editor.isEditable();\n      switch (eventName) {\n        case 'cut':\n          return isEditable && dispatchCommand(editor, CUT_COMMAND, event);\n        case 'copy':\n          return dispatchCommand(editor, COPY_COMMAND, event);\n        case 'paste':\n          return isEditable && dispatchCommand(editor, PASTE_COMMAND, event);\n        case 'dragstart':\n          return isEditable && dispatchCommand(editor, DRAGSTART_COMMAND, event);\n        case 'dragover':\n          return isEditable && dispatchCommand(editor, DRAGOVER_COMMAND, event);\n        case 'dragend':\n          return isEditable && dispatchCommand(editor, DRAGEND_COMMAND, event);\n        case 'focus':\n          return isEditable && dispatchCommand(editor, FOCUS_COMMAND, event);\n        case 'blur':\n          {\n            return isEditable && dispatchCommand(editor, BLUR_COMMAND, event);\n          }\n        case 'drop':\n          return isEditable && dispatchCommand(editor, DROP_COMMAND, event);\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (!(documentRootElementsCount !== undefined)) {\n    throw Error(`Root element not registered`);\n  } // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const newCount = documentRootElementsCount - 1;\n  if (!(newCount >= 0)) {\n    throw Error(`Root element count less than 0`);\n  }\n  rootElementsRegistered.set(doc, newCount);\n  if (newCount === 0) {\n    doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  const editor = getEditorPropertyFromDOMNode(rootElement);\n  if (isLexicalEditor(editor)) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  } else if (editor) {\n    {\n      throw Error(`Attempted to remove event handlers from a node that does not belong to this build of Lexical`);\n    }\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * The base type for all serialized nodes\n */\n\n/**\n * Omit the children, type, and version properties from the given SerializedLexicalNode definition.\n */\n\n/** @internal */\n\nfunction $removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    $removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // Allow us to look up the type including static props\n\n  /** @internal */\n\n  /** @internal */\n  //@ts-ignore We set the key in the constructor.\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  /**\n   * Perform any state updates on the clone of prevNode that are not already\n   * handled by the constructor call in the static clone method. If you have\n   * state to update in your clone that is not handled directly by the\n   * constructor, it is advisable to override this method but it is required\n   * to include a call to `super.afterCloneFrom(prevNode)` in your\n   * implementation. This is only intended to be called by\n   * {@link $cloneWithProperties} function or via a super call.\n   *\n   * @example\n   * ```ts\n   * class ClassesTextNode extends TextNode {\n   *   // Not shown: static getType, static importJSON, exportJSON, createDOM, updateDOM\n   *   __classes = new Set<string>();\n   *   static clone(node: ClassesTextNode): ClassesTextNode {\n   *     // The inherited TextNode constructor is used here, so\n   *     // classes is not set by this method.\n   *     return new ClassesTextNode(node.__text, node.__key);\n   *   }\n   *   afterCloneFrom(node: this): void {\n   *     // This calls TextNode.afterCloneFrom and LexicalNode.afterCloneFrom\n   *     // for necessary state updates\n   *     super.afterCloneFrom(node);\n   *     this.__addClasses(node.__classes);\n   *   }\n   *   // This method is a private implementation detail, it is not\n   *   // suitable for the public API because it does not call getWritable\n   *   __addClasses(classNames: Iterable<string>): this {\n   *     for (const className of classNames) {\n   *       this.__classes.add(className);\n   *     }\n   *     return this;\n   *   }\n   *   addClass(...classNames: string[]): this {\n   *     return this.getWritable().__addClasses(classNames);\n   *   }\n   *   removeClass(...classNames: string[]): this {\n   *     const node = this.getWritable();\n   *     for (const className of classNames) {\n   *       this.__classes.delete(className);\n   *     }\n   *     return this;\n   *   }\n   *   getClasses(): Set<string> {\n   *     return this.getLatest().__classes;\n   *   }\n   * }\n   * ```\n   *\n   */\n  afterCloneFrom(prevNode) {\n    this.__parent = prevNode.__parent;\n    this.__next = prevNode.__next;\n    this.__prev = prevNode.__prev;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  constructor(key) {\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n  getType() {\n    return this.__type;\n  }\n  isInline() {\n    {\n      throw Error(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);\n    }\n  }\n\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    const isElementRangeSelection = $isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element';\n    if (isElementRangeSelection) {\n      if (targetSelection.isCollapsed()) {\n        return false;\n      }\n      const parentNode = this.getParent();\n      if ($isDecoratorNode(this) && this.isInline() && parentNode) {\n        const firstPoint = targetSelection.isBackward() ? targetSelection.focus : targetSelection.anchor;\n        const firstElement = firstPoint.getNode();\n        if (firstPoint.offset === firstElement.getChildrenSize() && firstElement.is(parentNode) && firstElement.getLastChildOrThrow().is(this)) {\n          return false;\n        }\n      }\n    }\n    return isSelected;\n  }\n\n  /**\n   * Returns this nodes key.\n   */\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        if (!($isElementNode(node) || node === this && $isDecoratorNode(node))) {\n          throw Error(`Children of root nodes must be elements or decorators`);\n        }\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n    const bSet = new Set(b);\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n  isBefore(targetNode) {\n    if (this === targetNode) {\n      return false;\n    }\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    node = targetNode;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    return indexA < indexB;\n  }\n\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n  isParentOf(targetNode) {\n    const key = this.__key;\n    if (key === targetNode.__key) {\n      return false;\n    }\n    let node = targetNode;\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n      node = node.getParent();\n    }\n    return false;\n  }\n\n  // TO-DO: this function can be simplified a lot\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      if (node === null) {\n        break;\n      }\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        } else {\n          break;\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n\n  /**\n   * Returns a mutable version of the node using {@link $cloneWithProperties}\n   * if necessary. Will throw an error if called outside of a Lexical Editor\n   * {@link LexicalEditor.update} callback.\n   *\n   */\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection.setCachedNodes(null);\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const mutableNode = $cloneWithProperties(latestNode);\n    cloneNotNeeded.add(key);\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n  getTextContent() {\n    return '';\n  }\n\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n  getTextContentSize() {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  exportJSON() {\n    return {\n      type: this.__type,\n      version: 1\n    };\n  }\n\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n\n  /**\n   * Update this LexicalNode instance from serialized JSON. It's recommended\n   * to implement as much logic as possible in this method instead of the\n   * static importJSON method, so that the functionality can be inherited in subclasses.\n   *\n   * The LexicalUpdateJSON utility type should be used to ignore any type, version,\n   * or children properties in the JSON so that the extended JSON from subclasses\n   * are acceptable parameters for the super call.\n   *\n   * If overridden, this method must call super.\n   *\n   * @example\n   * ```ts\n   * class MyTextNode extends TextNode {\n   *   // ...\n   *   static importJSON(serializedNode: SerializedMyTextNode): MyTextNode {\n   *     return $createMyTextNode()\n   *       .updateFromJSON(serializedNode);\n   *   }\n   *   updateFromJSON(\n   *     serializedNode: LexicalUpdateJSON<SerializedMyTextNode>,\n   *   ): this {\n   *     return super.updateFromJSON(serializedNode)\n   *       .setMyProperty(serializedNode.myProperty);\n   *   }\n   * }\n   * ```\n   **/\n  updateFromJSON(serializedNode) {\n    return this;\n  }\n\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n  static transform() {\n    return null;\n  }\n\n  // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n  remove(preserveEmptyParent) {\n    $removeNode(this, true, preserveEmptyParent);\n  }\n\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) {\n      selection = selection.clone();\n    }\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    $removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert before this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n  isParentRequired() {\n    return false;\n  }\n\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  selectStart() {\n    return this.selectPrevious();\n  }\n  selectEnd() {\n    return this.selectNext(0, 0);\n  }\n\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n  markDirty() {\n    this.getWritable();\n  }\n\n  /**\n   * @internal\n   *\n   * When the reconciler detects that a node was mutated, this method\n   * may be called to restore the node to a known good state.\n   */\n  reconcileObservedMutation(dom, editor) {\n    this.markDirty();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Insert a series of nodes after this LexicalNode (as next siblings)\n *\n * @param firstToInsert - The first node to insert after this one.\n * @param lastToInsert - The last node to insert after this one. Must be a\n * later sibling of FirstNode. If not provided, it will be its last sibling.\n */\nfunction insertRangeAfter(node, firstToInsert, lastToInsert) {\n  const lastToInsert2 = firstToInsert.getParentOrThrow().getLastChild();\n  let current = firstToInsert;\n  const nodesToInsert = [firstToInsert];\n  while (current !== lastToInsert2) {\n    if (!current.getNextSibling()) {\n      {\n        throw Error(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);\n      }\n    }\n    current = current.getNextSibling();\n    nodesToInsert.push(current);\n  }\n  let currentNode = node;\n  for (const nodeToInsert of nodesToInsert) {\n    currentNode = currentNode.insertAfter(nodeToInsert);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        if (isOnlyChildInBlockNode(node) || isLastChildInBlockNode(node)) {\n          return null;\n        }\n        return {\n          conversion: $convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode().updateFromJSON(serializedLineBreakNode);\n  }\n}\nfunction $convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\nfunction isOnlyChildInBlockNode(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      const lastChild = parentElement.lastChild;\n      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isLastChildInBlockNode(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    // check if node is first child, because only childs dont count\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      return false;\n    }\n\n    // check if its last child\n    const lastChild = parentElement.lastChild;\n    if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isWhitespaceDomTextNode(node) {\n  return isDOMTextNode(node) && /^( |\\t|\\r?\\n)+$/.test(node.textContent || '');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__text = prevNode.__text;\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__mode = prevNode.__mode;\n    this.__detail = prevNode.__detail;\n  }\n  constructor(text = '', key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  /**\n   *\n   * @returns true if the text node supports font styling, false otherwise.\n   */\n  canHaveFormat() {\n    return true;\n  }\n\n  // View\n\n  createDOM(config, editor) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: $convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTextNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setTextContent(serializedNode.text).setFormat(serializedNode.format).setDetail(serializedNode.detail).setMode(serializedNode.mode).setStyle(serializedNode.style);\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n    if (!isHTMLElement(element)) {\n      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);\n    }\n    element.style.whiteSpace = 'pre-wrap';\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'i');\n    }\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      // As an exception here we invoke super at the end for historical reasons.\n      // Namely, to preserve the order of the properties and not to break the tests\n      // that use the serialized string representation.\n      ...super.exportJSON()\n    };\n  }\n\n  // Mutators\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.toggleUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.\n   * The subscript and superscript formats are mutually exclusive.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n  toggleFormat(type) {\n    const format = this.getFormat();\n    const newFormat = toggleTextFormatType(format, type, null);\n    return this.setFormat(newFormat);\n  }\n\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  selectStart() {\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const size = this.getTextContentSize();\n    return this.select(size, size);\n  }\n\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n  canInsertTextBefore() {\n    return true;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n  canInsertTextAfter() {\n    return true;\n  }\n\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n      string += textContent[i];\n    }\n    if (string !== '') {\n      parts.push(string);\n    }\n    const partsLength = parts.length;\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParent();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    }\n\n    // Handle selection\n    const selection = $getSelection();\n\n    // Then handle all other parts\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    }\n\n    // Insert the nodes into the parent's children\n    if (parent !== null) {\n      internalMarkSiblingsAsDirty(this);\n      const writableParent = parent.getWritable();\n      const insertionIndex = this.getIndexWithinParent();\n      if (hasReplacedSelf) {\n        writableParent.splice(insertionIndex, 0, splitNodes);\n        this.remove();\n      } else {\n        writableParent.splice(insertionIndex, 1, splitNodes);\n      }\n      if ($isRangeSelection(selection)) {\n        $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n      }\n    }\n    return splitNodes;\n  }\n\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  const style = span.style;\n  return {\n    forChild: applyTextFormatFromStyle(style),\n    node: null\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: applyTextFormatFromStyle(b.style, hasNormalFontWeight ? undefined : 'bold'),\n    node: null\n  };\n}\nconst preParentCache = new WeakMap();\nfunction isNodePre(node) {\n  if (!isHTMLElement(node)) {\n    return false;\n  } else if (node.nodeName === 'PRE') {\n    return true;\n  }\n  const whiteSpace = node.style.whiteSpace;\n  return typeof whiteSpace === 'string' && whiteSpace.startsWith('pre');\n}\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n  const resultNode = cached === undefined ? parent : cached;\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n  return resultNode;\n}\nfunction $convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n  if (!(parentDom !== null)) {\n    throw Error(`Expected parentElement of Text not to be null`);\n  }\n  let textContent = domNode_.textContent || '';\n  // No collapse and preserve segment break for pre, pre-wrap and pre-line\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n    return {\n      node: nodes\n    };\n  }\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n        isStartOfLine = false;\n        break;\n      }\n    }\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nfunction findTextInLine(text, forward) {\n  let node = text;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let sibling;\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n      if (parentElement === null) {\n        return null;\n      }\n      node = parentElement;\n    }\n    node = sibling;\n    if (isHTMLElement(node)) {\n      const display = node.style.display;\n      if (display === '' && !isInlineDomNode(node) || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n    let descendant = node;\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n    if (isDOMTextNode(node)) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: applyTextFormatFromStyle(domNode.style, format),\n    node: null\n  };\n}\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\nfunction applyTextFormatFromStyle(style, shouldApply) {\n  const fontWeight = style.fontWeight;\n  const textDecoration = style.textDecoration.split(' ');\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = fontWeight === '700' || fontWeight === 'bold';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = style.verticalAlign;\n  return lexicalNode => {\n    if (!$isTextNode(lexicalNode)) {\n      return lexicalNode;\n    }\n    if (hasBoldFontWeight && !lexicalNode.hasFormat('bold')) {\n      lexicalNode.toggleFormat('bold');\n    }\n    if (hasLinethroughTextDecoration && !lexicalNode.hasFormat('strikethrough')) {\n      lexicalNode.toggleFormat('strikethrough');\n    }\n    if (hasItalicFontStyle && !lexicalNode.hasFormat('italic')) {\n      lexicalNode.toggleFormat('italic');\n    }\n    if (hasUnderlineTextDecoration && !lexicalNode.hasFormat('underline')) {\n      lexicalNode.toggleFormat('underline');\n    }\n    if (verticalAlign === 'sub' && !lexicalNode.hasFormat('subscript')) {\n      lexicalNode.toggleFormat('subscript');\n    }\n    if (verticalAlign === 'super' && !lexicalNode.hasFormat('superscript')) {\n      lexicalNode.toggleFormat('superscript');\n    }\n    if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {\n      lexicalNode.toggleFormat(shouldApply);\n    }\n    return lexicalNode;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n  static clone(node) {\n    return new TabNode(node.__key);\n  }\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n  static importDOM() {\n    return null;\n  }\n  createDOM(config) {\n    const dom = super.createDOM(config);\n    const classNames = getCachedClassNameArray(config.theme, 'tab');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  static importJSON(serializedTabNode) {\n    return $createTabNode().updateFromJSON(serializedTabNode);\n  }\n  setTextContent(text) {\n    if (!(text === '\\t' || text === '')) {\n      throw Error(`TabNode does not support setTextContent`);\n    }\n    return super.setTextContent(text);\n  }\n  setDetail(detail) {\n    if (!(detail === IS_UNMERGEABLE)) {\n      throw Error(`TabNode does not support setDetail`);\n    }\n    return this;\n  }\n  setMode(type) {\n    if (!(type === 'normal')) {\n      throw Error(`TabNode does not support setMode`);\n    }\n    return this;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass Point {\n  constructor(key, offset, type) {\n    {\n      // This prevents a circular reference error when serialized as JSON,\n      // which happens on unit test failures\n      Object.defineProperty(this, '_selection', {\n        enumerable: false,\n        writable: true\n      });\n    }\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n    return aNode.isBefore(bNode);\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection.setCachedNodes(null);\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\nclass NodeSelection {\n  constructor(objects) {\n    this._cachedNodes = null;\n    this._nodes = objects;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return false;\n  }\n  getStartEndPoints() {\n    return null;\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.format = format;\n    this.style = style;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const overselectedFirstNode = $isElementNode(firstNode) && firstPoint.offset > 0 && firstPoint.offset >= firstNode.getChildrenSize();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset);\n      // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n    let nodes;\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n      // Prevent over-selection due to the edge case of getDescendantByIndex always returning something #6974\n      if (overselectedFirstNode) {\n        const deleteCount = nodes.findIndex(node => !node.is(firstNode) && !node.isBefore(firstNode));\n        nodes.splice(0, deleteCount);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = $internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n    this.insertNodes(nodes);\n  }\n\n  /**\n   * Insert the provided text into the EditorState at the current Selection.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertText(text) {\n    // Now that \"removeText\" has been improved and does not depend on\n    // insertText, insertText can be greatly simplified. The next\n    // commented version is a WIP (about 5 tests fail).\n    //\n    // this.removeText();\n    // if (text === '') {\n    //   return;\n    // }\n    // const anchorNode = this.anchor.getNode();\n    // const textNode = $createTextNode(text);\n    // textNode.setFormat(this.format);\n    // textNode.setStyle(this.style);\n    // if ($isTextNode(anchorNode)) {\n    //   const parent = anchorNode.getParentOrThrow();\n    //   if (this.anchor.offset === 0) {\n    //     if (parent.isInline() && !anchorNode.__prev) {\n    //       parent.insertBefore(textNode);\n    //     } else {\n    //       anchorNode.insertBefore(textNode);\n    //     }\n    //   } else if (this.anchor.offset === anchorNode.getTextContentSize()) {\n    //     if (parent.isInline() && !anchorNode.__next) {\n    //       parent.insertAfter(textNode);\n    //     } else {\n    //       anchorNode.insertAfter(textNode);\n    //     }\n    //   } else {\n    //     const [before] = anchorNode.splitText(this.anchor.offset);\n    //     before.insertAfter(textNode);\n    //   }\n    // } else {\n    //   anchorNode.splice(this.anchor.offset, 0, [textNode]);\n    // }\n    // const nodeToSelect = textNode.isAttached() ? textNode : anchorNode;\n    // nodeToSelect.selectEnd();\n    // // When composing, we need to adjust the anchor offset so that\n    // // we correctly replace that right range.\n    // if (\n    //   textNode.isComposing() &&\n    //   this.anchor.type === 'text' &&\n    //   anchorNode.getTextContent() !== ''\n    // ) {\n    //   this.anchor.offset -= text.length;\n    // }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const format = this.format;\n    const style = this.style;\n    let firstPoint = anchor;\n    let endPoint = focus;\n    if (!this.isCollapsed() && focus.isBefore(anchor)) {\n      firstPoint = focus;\n      endPoint = anchor;\n    }\n    if (firstPoint.type === 'element') {\n      $transferStartingElementPointToTextPoint(firstPoint, endPoint, format, style);\n    }\n    const startOffset = firstPoint.offset;\n    let endOffset = endPoint.offset;\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (selectedNodesLength === 1 && endPoint.type === 'element') {\n      endOffset = firstNodeTextLength;\n      endPoint.set(firstPoint.key, endOffset, 'text');\n    }\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        nextSibling.setStyle(style);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      } else if ($isTabNode(firstNode)) {\n        // We don't need to check for delCount because there is only the entire selected node case\n        // that can hit here for content size 1 and with canInsertTextBeforeAfter false\n        const textNode = $createTextNode(text);\n        textNode.setFormat(format);\n        textNode.setStyle(style);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          // root node selections only select whole nodes, so no text splice is necessary\n          if (!$isRootNode(endPoint.getNode()) && endPoint.type === 'text') {\n            lastNode = lastNode.spliceText(0, endOffset, '');\n          }\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n  removeText() {\n    if (this.isCollapsed()) {\n      return;\n    }\n    const {\n      anchor,\n      focus\n    } = this;\n    const selectedNodes = this.getNodes();\n    const firstPoint = this.isBackward() ? focus : anchor;\n    const lastPoint = this.isBackward() ? anchor : focus;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const firstBlock = $getAncestor(firstNode, INTERNAL_$isBlock);\n    const lastBlock = $getAncestor(lastNode, INTERNAL_$isBlock);\n    // If a token is partially selected then move the selection to cover the whole selection\n    if ($isTextNode(firstNode) && firstNode.isToken() && firstPoint.offset < firstNode.getTextContentSize()) {\n      firstPoint.offset = 0;\n    }\n    if (lastPoint.offset > 0 && $isTextNode(lastNode) && lastNode.isToken()) {\n      lastPoint.offset = lastNode.getTextContentSize();\n    }\n    for (const node of selectedNodes) {\n      if (!$hasAncestor(firstNode, node) && !$hasAncestor(lastNode, node) && node.getKey() !== firstNode.getKey() && node.getKey() !== lastNode.getKey()) {\n        node.remove();\n      }\n    }\n    const fixText = (node, del) => {\n      if (node.getTextContent() === '') {\n        node.remove();\n      } else if (del !== 0 && $isTokenOrSegmented(node)) {\n        const textNode = $createTextNode(node.getTextContent());\n        textNode.setFormat(node.getFormat());\n        textNode.setStyle(node.getStyle());\n        return node.replace(textNode);\n      }\n    };\n    if (firstNode === lastNode && $isTextNode(firstNode)) {\n      const del = Math.abs(focus.offset - anchor.offset);\n      firstNode.spliceText(firstPoint.offset, del, '', true);\n      fixText(firstNode, del);\n      return;\n    }\n    if ($isTextNode(firstNode)) {\n      const del = firstNode.getTextContentSize() - firstPoint.offset;\n      firstNode.spliceText(firstPoint.offset, del, '');\n      firstNode = fixText(firstNode, del) || firstNode;\n    }\n    if ($isTextNode(lastNode)) {\n      lastNode.spliceText(0, lastPoint.offset, '');\n      lastNode = fixText(lastNode, lastPoint.offset) || lastNode;\n    }\n    if (firstNode.isAttached() && $isTextNode(firstNode)) {\n      firstNode.selectEnd();\n    } else if (lastNode.isAttached() && $isTextNode(lastNode)) {\n      lastNode.selectStart();\n    }\n\n    // Merge blocks\n    const bothElem = $isElementNode(firstBlock) && $isElementNode(lastBlock);\n    if (bothElem && firstBlock !== lastBlock) {\n      firstBlock.append(...lastBlock.getChildren());\n      lastBlock.remove();\n      lastPoint.set(firstPoint.key, firstPoint.offset, firstPoint.type);\n    }\n  }\n\n  // TO-DO: Migrate this method to the new utility function $forEachSelectedTextNode (share similar logic)\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   * @param alignWithFormat a 32-bit integer representing formatting flags to align with.\n   */\n  formatText(formatType, alignWithFormat = null) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const applyFormatToElements = alignWith => {\n      selectedNodes.forEach(node => {\n        if ($isElementNode(node)) {\n          const newFormat = node.getFormatFlags(formatType, alignWith);\n          node.setTextFormat(newFormat);\n        }\n      });\n    };\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      applyFormatToElements(alignWithFormat);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, alignWithFormat);\n    applyFormatToElements(firstNextFormat);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected or it is token, so just format it\n      if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize() && !$isTokenOrSegmented(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n      textNode.setFormat(nextFormat);\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accommodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   */\n  insertNodes(nodes) {\n    if (nodes.length === 0) {\n      return;\n    }\n    if (this.anchor.key === 'root') {\n      this.insertParagraph();\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        throw Error(`Expected RangeSelection after insertParagraph`);\n      }\n      return selection.insertNodes(nodes);\n    }\n    const firstPoint = this.isBackward() ? this.focus : this.anchor;\n    const firstNode = firstPoint.getNode();\n    const firstBlock = $getAncestor(firstNode, INTERNAL_$isBlock);\n    const last = nodes[nodes.length - 1];\n\n    // CASE 1: insert inside a code block\n    if ($isElementNode(firstBlock) && '__language' in firstBlock) {\n      if ('__language' in nodes[0]) {\n        this.insertText(nodes[0].getTextContent());\n      } else {\n        const index = $removeTextAndSplitBlock(this);\n        firstBlock.splice(index, 0, nodes);\n        last.selectEnd();\n      }\n      return;\n    }\n\n    // CASE 2: All elements of the array are inline\n    const notInline = node => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();\n    if (!nodes.some(notInline)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);\n      }\n      const index = $removeTextAndSplitBlock(this);\n      firstBlock.splice(index, 0, nodes);\n      last.selectEnd();\n      return;\n    }\n\n    // CASE 3: At least 1 element of the array is not inline\n    const blocksParent = $wrapInlineNodes(nodes);\n    const nodeToSelect = blocksParent.getLastDescendant();\n    const blocks = blocksParent.getChildren();\n    const isMergeable = node => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || firstBlock.canMergeWhenEmpty());\n    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();\n    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;\n    const lastToInsert = blocks[blocks.length - 1];\n    let firstToInsert = blocks[0];\n    if (isMergeable(firstToInsert)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);\n      }\n      firstBlock.append(...firstToInsert.getChildren());\n      firstToInsert = blocks[1];\n    }\n    if (firstToInsert) {\n      if (!(firstBlock !== null)) {\n        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ancestor`);\n      }\n      insertRangeAfter(firstBlock, firstToInsert);\n    }\n    const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);\n    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (insertedParagraph.canMergeWhenEmpty() || INTERNAL_$isBlock(lastToInsert))) {\n      lastInsertedBlock.append(...insertedParagraph.getChildren());\n      insertedParagraph.remove();\n    }\n    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {\n      firstBlock.remove();\n    }\n    nodeToSelect.selectEnd();\n\n    // To understand this take a look at the test \"can wrap post-linebreak nodes into new element\"\n    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;\n    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {\n      lastChild.remove();\n    }\n  }\n\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   *\n   * @returns the newly inserted node.\n   */\n  insertParagraph() {\n    if (this.anchor.key === 'root') {\n      const paragraph = $createParagraphNode();\n      $getRoot().splice(this.anchor.offset, 0, [paragraph]);\n      paragraph.select();\n      return paragraph;\n    }\n    const index = $removeTextAndSplitBlock(this);\n    const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);\n    if (!$isElementNode(block)) {\n      throw Error(`Expected ancestor to be a block ElementNode`);\n    }\n    const firstToAppend = block.getChildAtIndex(index);\n    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];\n    const newBlock = block.insertNewAfter(this, false);\n    if (newBlock) {\n      newBlock.append(...nodesToInsert);\n      newBlock.selectStart();\n      return newBlock;\n    }\n    // if newBlock is null, it means that block is of type CodeNode.\n    return null;\n  }\n\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   */\n  insertLineBreak(selectStart) {\n    const lineBreak = $createLineBreakNode();\n    this.insertNodes([lineBreak]);\n    // this is used in MacOS with the command 'ctrl-O' (openLineBreak)\n    if (selectStart) {\n      const parent = lineBreak.getParentOrThrow();\n      const index = lineBreak.getIndexWithinParent();\n      parent.select(index, index);\n    }\n  }\n\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move';\n\n    // Handle the selection movement around decorators.\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n          if (!isBackward) {\n            offset++;\n          }\n        }\n        focus.set(elementKey, offset, 'element');\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n        return;\n      }\n    }\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Helper for handling forward character and word deletion that prevents element nodes\n   * like a table, columns layout being destroyed\n   *\n   * @param anchor the anchor\n   * @param anchorNode the anchor node in the selection\n   * @param isBackward whether or not selection is backwards\n   */\n  forwardDeletion(anchor, anchorNode, isBackward) {\n    if (!isBackward && (\n    // Delete forward handle case\n    anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n      const parent = anchorNode.getParent();\n      const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      let anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n\n      // Handle the deletion around decorators.\n      const focus = this.focus;\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n        return;\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      // Since `domSelection.modify('extend', ..., 'lineboundary')` works well for text selections\n      // but doesn't properly handle selections which end on elements, a space character is added\n      // for such selections transforming their anchor's type to 'text'\n      const anchorIsElement = this.anchor.type === 'element';\n      if (anchorIsElement) {\n        this.insertText(' ');\n      }\n      this.modify('extend', isBackward, 'lineboundary');\n\n      // If the selection starts at the beginning of a text node (offset 0),\n      // extend the selection by one character in the specified direction.\n      // This ensures that the parent element is deleted along with its content.\n      // Otherwise, only the text content will be deleted, leaving an empty parent node.\n      if (this.isCollapsed() && this.anchor.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n\n      // Adjusts selection to include an extra character added for element anchors to remove it\n      if (anchorIsElement) {\n        const startPoint = isBackward ? this.anchor : this.focus;\n        startPoint.set(startPoint.key, startPoint.offset + 1, startPoint.type);\n      }\n    }\n    this.removeText();\n  }\n\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction $getCharacterOffsets(selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return [0, 0];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction $internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (isHTMLElement(dom)) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    const blockCursorElement = editor._blockCursorElement;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (blockCursorElement !== null) {\n      const blockCursorElementParent = blockCursorElement.parentNode;\n      if (dom === blockCursorElementParent) {\n        const blockCursorOffset = Array.prototype.indexOf.call(blockCursorElementParent.children, blockCursorElement);\n        if (offset > blockCursorOffset) {\n          resolvedOffset--;\n        }\n      }\n    }\n    resolvedNode = $getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = $getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        const elementDOM = editor.getElementByKey(resolvedElement.getKey());\n        if (!(elementDOM !== null)) {\n          throw Error(`$internalResolveSelectionPoint: node in DOM but not keyToDOMMap`);\n        }\n        const slot = resolvedElement.getDOMSlot(elementDOM);\n        [resolvedElement, resolvedOffset] = slot.resolveChildIndex(resolvedElement, elementDOM, dom, offset);\n        // This is just a typescript workaround, it is true but lost due to mutability\n        if (!$isElementNode(resolvedElement)) {\n          throw Error(`$internalResolveSelectionPoint: resolvedElement is not an ElementNode`);\n        }\n        if (moveSelectionToEnd && resolvedOffset >= resolvedElement.getChildrenSize()) {\n          resolvedOffset = Math.max(0, resolvedElement.getChildrenSize() - 1);\n        }\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n          resolvedOffset = 0;\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          if (!$isElementNode(resolvedElement)) {\n            throw Error(`invariant`);\n          }\n          resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset + 1);\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && $getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = $getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize();\n        // @ts-expect-error: intentional\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0;\n      // @ts-expect-error: intentional\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\nfunction $normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\nfunction $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = $internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  {\n    $validatePoint(editor, 'anchor', resolvedAnchorPoint);\n  }\n  const resolvedFocusPoint = $internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  {\n    $validatePoint(editor, 'focus', resolvedAnchorPoint);\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = $getNodeFromDOM(anchorDOM);\n    const focusNode = $getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  $normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction $internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction $internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n  if ($isRangeSelection(lastSelection) || lastSelection == null) {\n    return $internalCreateRangeSelection(lastSelection, domSelection, editor, null);\n  }\n  return lastSelection.clone();\n}\nfunction $createRangeSelectionFromDom(domSelection, editor) {\n  return $internalCreateRangeSelection(null, domSelection, editor, null);\n}\nfunction $internalCreateRangeSelection(lastSelection, domSelection, editor, event) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = event || windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $validatePoint(editor, name, point) {\n  const node = $getNodeByKey(point.key);\n  if (!(node !== undefined)) {\n    throw Error(`$validatePoint: ${name} key ${point.key} not found in current editorState`);\n  }\n  if (point.type === 'text') {\n    if (!$isTextNode(node)) {\n      throw Error(`$validatePoint: ${name} key ${point.key} is not a TextNode`);\n    }\n    const size = node.getTextContentSize();\n    if (!(point.offset <= size)) {\n      throw Error(`$validatePoint: ${name} point.offset > node.getTextContentSize() (${String(point.offset)} > ${String(size)})`);\n    }\n  } else {\n    if (!$isElementNode(node)) {\n      throw Error(`$validatePoint: ${name} key ${point.key} is not an ElementNode`);\n    }\n    const size = node.getChildrenSize();\n    if (!(point.offset <= size)) {\n      throw Error(`$validatePoint: ${name} point.offset > node.getChildrenSize() (${String(point.offset)} > ${String(size)})`);\n    }\n  }\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n    {\n      console.warn(error);\n    }\n  }\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = $isRangeSelection(nextSelection) && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      let selectionRect;\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes) {\n  let selection = $getSelection() || $getPreviousSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  selection.insertNodes(nodes);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\nfunction $removeTextAndSplitBlock(selection) {\n  let selection_ = selection;\n  if (!selection.isCollapsed()) {\n    selection_.removeText();\n  }\n  // A new selection can originate as a result of node replacement, in which case is registered via\n  // $setSelection\n  const newSelection = $getSelection();\n  if ($isRangeSelection(newSelection)) {\n    selection_ = newSelection;\n  }\n  if (!$isRangeSelection(selection_)) {\n    throw Error(`Unexpected dirty selection to be null`);\n  }\n  const anchor = selection_.anchor;\n  let node = anchor.getNode();\n  let offset = anchor.offset;\n  while (!INTERNAL_$isBlock(node)) {\n    [node, offset] = $splitNodeAtPoint(node, offset);\n  }\n  return offset;\n}\nfunction $splitNodeAtPoint(node, offset) {\n  const parent = node.getParent();\n  if (!parent) {\n    const paragraph = $createParagraphNode();\n    $getRoot().append(paragraph);\n    paragraph.select();\n    return [$getRoot(), 0];\n  }\n  if ($isTextNode(node)) {\n    const split = node.splitText(offset);\n    if (split.length === 0) {\n      return [parent, node.getIndexWithinParent()];\n    }\n    const x = offset === 0 ? 0 : 1;\n    const index = split[0].getIndexWithinParent() + x;\n    return [parent, index];\n  }\n  if (!$isElementNode(node) || offset === 0) {\n    return [parent, node.getIndexWithinParent()];\n  }\n  const firstToAppend = node.getChildAtIndex(offset);\n  if (firstToAppend) {\n    const insertPoint = new RangeSelection($createPoint(node.__key, offset, 'element'), $createPoint(node.__key, offset, 'element'), 0, '');\n    const newElement = node.insertNewAfter(insertPoint);\n    if (newElement) {\n      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());\n    }\n  }\n  return [parent, node.getIndexWithinParent() + 1];\n}\nfunction $wrapInlineNodes(nodes) {\n  // We temporarily insert the topLevelNodes into an arbitrary ElementNode,\n  // since insertAfter does not work on nodes that have no parent (TO-DO: fix that).\n  const virtualRoot = $createParagraphNode();\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = $isLineBreakNode(node);\n    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        virtualRoot.append(currentBlock);\n        // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      virtualRoot.append(node);\n      currentBlock = null;\n    }\n  }\n  return virtualRoot;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update(), editor.read(), or editorState.read().${collectBuildInformation()}`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update() or editor.read().${collectBuildInformation()}`);\n    }\n  }\n  return activeEditor;\n}\nfunction collectBuildInformation() {\n  let compatibleEditors = 0;\n  const incompatibleEditors = new Set();\n  const thisVersion = LexicalEditor.version;\n  if (typeof window !== 'undefined') {\n    for (const node of document.querySelectorAll('[contenteditable]')) {\n      const editor = getEditorPropertyFromDOMNode(node);\n      if (isLexicalEditor(editor)) {\n        compatibleEditors++;\n      } else if (editor) {\n        let version = String(editor.constructor.version || '<0.17.1');\n        if (version === thisVersion) {\n          version += ' (separately built, likely a bundler configuration issue)';\n        }\n        incompatibleEditors.add(version);\n      }\n    }\n  }\n  let output = ` Detected on the page: ${compatibleEditors} compatible editor(s) with version ${thisVersion}`;\n  if (incompatibleEditors.size) {\n    output += ` and incompatible editors with versions ${Array.from(incompatibleEditors).join(', ')}`;\n  }\n  return output;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction internalGetActiveEditorState() {\n  return activeEditorState;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\nfunction addTags(editor, tags) {\n  if (!tags) {\n    return;\n  }\n  const updateTags = editor._updateTags;\n  let tags_ = tags;\n  if (!Array.isArray(tags)) {\n    tags_ = [tags];\n  }\n  for (const tag of tags_) {\n    updateTags.add(tag);\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editor, editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = editor;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction $commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = $reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        $commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty) && rootElement !== null && !tags.has('skip-dom-selection')) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n\n  // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  $triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags\n      });\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction $triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      $beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (options.discrete) {\n          const pendingEditorState = editor._pendingEditorState;\n          if (!(pendingEditorState !== null)) {\n            throw Error(`Unexpected empty pending editor state on discrete nested update`);\n          }\n          pendingEditorState._flushSync = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        addTags(editor, options.tag);\n      }\n      nextUpdateFn();\n    }\n  }\n  return skipTransforms;\n}\nfunction $beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    addTags(editor, options.tag);\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection !== null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = $internalCreateSelection(editor);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    $commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editor._deferred.length > 0 || editorStateHasDirtySelection(pendingEditorState, editor);\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      $commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        $commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    $beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n/**\n * A utility class for managing the DOM children of an ElementNode\n */\nclass ElementDOMSlot {\n  constructor(/** The element returned by createDOM */\n  element, /** All managed children will be inserted before this node, if defined */\n  before, /** All managed children will be inserted after this node, if defined */\n  after) {\n    this.element = element;\n    this.before = before || null;\n    this.after = after || null;\n  }\n  /**\n   * Return a new ElementDOMSlot where all managed children will be inserted before this node\n   */\n  withBefore(before) {\n    return new ElementDOMSlot(this.element, before, this.after);\n  }\n  /**\n   * Return a new ElementDOMSlot where all managed children will be inserted after this node\n   */\n  withAfter(after) {\n    return new ElementDOMSlot(this.element, this.before, after);\n  }\n  /**\n   * Return a new ElementDOMSlot with an updated root element\n   */\n  withElement(element) {\n    return new ElementDOMSlot(element, this.before, this.after);\n  }\n  /**\n   * Insert the given child before this.before and any reconciler managed line break node,\n   * or append it if this.before is not defined\n   */\n  insertChild(dom) {\n    const before = this.before || this.getManagedLineBreak();\n    if (!(before === null || before.parentElement === this.element)) {\n      throw Error(`ElementDOMSlot.insertChild: before is not in element`);\n    }\n    this.element.insertBefore(dom, before);\n    return this;\n  }\n  /**\n   * Remove the managed child from this container, will throw if it was not already there\n   */\n  removeChild(dom) {\n    if (!(dom.parentElement === this.element)) {\n      throw Error(`ElementDOMSlot.removeChild: dom is not in element`);\n    }\n    this.element.removeChild(dom);\n    return this;\n  }\n  /**\n   * Replace managed child prevDom with dom. Will throw if prevDom is not a child\n   *\n   * @param dom The new node to replace prevDom\n   * @param prevDom the node that will be replaced\n   */\n  replaceChild(dom, prevDom) {\n    if (!(prevDom.parentElement === this.element)) {\n      throw Error(`ElementDOMSlot.replaceChild: prevDom is not in element`);\n    }\n    this.element.replaceChild(dom, prevDom);\n    return this;\n  }\n  /**\n   * Returns the first managed child of this node,\n   * which will either be this.after.nextSibling or this.element.firstChild,\n   * and will never be this.before if it is defined.\n   */\n  getFirstChild() {\n    const firstChild = this.after ? this.after.nextSibling : this.element.firstChild;\n    return firstChild === this.before || firstChild === this.getManagedLineBreak() ? null : firstChild;\n  }\n  /**\n   * @internal\n   */\n  getManagedLineBreak() {\n    const element = this.element;\n    return element.__lexicalLineBreak || null;\n  }\n  /** @internal */\n  setManagedLineBreak(lineBreakType) {\n    if (lineBreakType === null) {\n      this.removeManagedLineBreak();\n    } else {\n      const webkitHack = lineBreakType === 'decorator' && (IS_IOS || IS_SAFARI);\n      this.insertManagedLineBreak(webkitHack);\n    }\n  }\n\n  /** @internal */\n  removeManagedLineBreak() {\n    const br = this.getManagedLineBreak();\n    if (br) {\n      const element = this.element;\n      const sibling = br.nodeName === 'IMG' ? br.nextSibling : null;\n      if (sibling) {\n        element.removeChild(sibling);\n      }\n      element.removeChild(br);\n      element.__lexicalLineBreak = undefined;\n    }\n  }\n  /** @internal */\n  insertManagedLineBreak(webkitHack) {\n    const prevBreak = this.getManagedLineBreak();\n    if (prevBreak) {\n      if (webkitHack === (prevBreak.nodeName === 'IMG')) {\n        return;\n      }\n      this.removeManagedLineBreak();\n    }\n    const element = this.element;\n    const before = this.before;\n    const br = document.createElement('br');\n    element.insertBefore(br, before);\n    if (webkitHack) {\n      const img = document.createElement('img');\n      img.setAttribute('data-lexical-linebreak', 'true');\n      img.style.cssText = 'display: inline !important; border: 0px !important; margin: 0px !important;';\n      img.alt = '';\n      element.insertBefore(img, br);\n      element.__lexicalLineBreak = img;\n    } else {\n      element.__lexicalLineBreak = br;\n    }\n  }\n\n  /**\n   * @internal\n   *\n   * Returns the offset of the first child\n   */\n  getFirstChildOffset() {\n    let i = 0;\n    for (let node = this.after; node !== null; node = node.previousSibling) {\n      i++;\n    }\n    return i;\n  }\n\n  /**\n   * @internal\n   */\n  resolveChildIndex(element, elementDOM, initialDOM, initialOffset) {\n    if (initialDOM === this.element) {\n      const firstChildOffset = this.getFirstChildOffset();\n      return [element, Math.min(firstChildOffset + element.getChildrenSize(), Math.max(firstChildOffset, initialOffset))];\n    }\n    // The resolved offset must be before or after the children\n    const initialPath = indexPath(elementDOM, initialDOM);\n    initialPath.push(initialOffset);\n    const elementPath = indexPath(elementDOM, this.element);\n    let offset = element.getIndexWithinParent();\n    for (let i = 0; i < elementPath.length; i++) {\n      const target = initialPath[i];\n      const source = elementPath[i];\n      if (target === undefined || target < source) {\n        break;\n      } else if (target > source) {\n        offset += 1;\n        break;\n      }\n    }\n    return [element.getParentOrThrow(), offset];\n  }\n}\nfunction indexPath(root, child) {\n  const path = [];\n  let node = child;\n  for (; node !== root && node !== null; node = child.parentNode) {\n    let i = 0;\n    for (let sibling = node.previousSibling; sibling !== null; sibling = node.previousSibling) {\n      i++;\n    }\n    path.push(i);\n  }\n  if (!(node === root)) {\n    throw Error(`indexPath: root is not a parent of child`);\n  }\n  return path.reverse();\n}\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__style = '';\n    this.__indent = 0;\n    this.__dir = null;\n    this.__textFormat = 0;\n    this.__textStyle = '';\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__first = prevNode.__first;\n    this.__last = prevNode.__last;\n    this.__size = prevNode.__size;\n    this.__indent = prevNode.__indent;\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__dir = prevNode.__dir;\n    this.__textFormat = prevNode.__textFormat;\n    this.__textStyle = prevNode.__textStyle;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while ($isElementNode(node)) {\n      const child = node.getLastChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n    return textContentSize;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  getTextFormat() {\n    const self = this.getLatest();\n    return self.__textFormat;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n  hasTextFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getTextFormat() & formatFlag) !== 0;\n  }\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__textFormat;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n  getTextStyle() {\n    const self = this.getLatest();\n    return self.__textStyle;\n  }\n\n  // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    return firstNode ? firstNode.selectStart() : this.select();\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    return lastNode ? lastNode.selectEnd() : this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style || '';\n    return this;\n  }\n  setTextFormat(type) {\n    const self = this.getWritable();\n    self.__textFormat = type;\n    return self;\n  }\n  setTextStyle(style) {\n    const self = this.getWritable();\n    self.__textStyle = style;\n    return self;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    if (!(start + deleteCount <= oldSize)) {\n      throw Error(`ElementNode.splice: start + deleteCount > oldSize (${String(start)} + ${String(deleteCount)} > ${String(oldSize)})`);\n    }\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  }\n  /**\n   * @internal\n   *\n   * An experimental API that an ElementNode can override to control where its\n   * children are inserted into the DOM, this is useful to add a wrapping node\n   * or accessory nodes before or after the children. The root of the node returned\n   * by createDOM must still be exactly one HTMLElement.\n   */\n  getDOMSlot(element) {\n    return new ElementDOMSlot(element);\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML\n        // (see https://www.caniemail.com/features/css-padding-inline-start-end/),\n        // If you want to use HTML output for email, consider overriding the serialization\n        // to use `padding-right` in RTL languages, `padding-left` in `LTR` languages, or\n        // `text-indent` if you are ok with first-line indents.\n        // We recommend keeping multiples of 40px to maintain consistency with list-items\n        // (see https://github.com/facebook/lexical/pull/4025)\n        element.style.paddingInlineStart = `${indent * 40}px`;\n      }\n    }\n    return {\n      element\n    };\n  }\n  // JSON serialization\n  exportJSON() {\n    const json = {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      // As an exception here we invoke super at the end for historical reasons.\n      // Namely, to preserve the order of the properties and not to break the tests\n      // that use the serialized string representation.\n      ...super.exportJSON()\n    };\n    const textFormat = this.getTextFormat();\n    const textStyle = this.getTextStyle();\n    if (textFormat !== 0) {\n      json.textFormat = textFormat;\n    }\n    if (textStyle !== '') {\n      json.textStyle = textStyle;\n    }\n    return json;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setFormat(serializedNode.format).setIndent(serializedNode.indent).setDirection(serializedNode.direction).setTextFormat(serializedNode.textFormat || 0).setTextStyle(serializedNode.textStyle || '');\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  }\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return true;\n  }\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot() {\n    return false;\n  }\n  /** @deprecated @internal */\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n\n  /**\n   * Determines whether this node, when empty, can merge with a first block\n   * of nodes being inserted.\n   *\n   * This method is specifically called in {@link RangeSelection.insertNodes}\n   * to determine merging behavior during nodes insertion.\n   *\n   * @example\n   * // In a ListItemNode or QuoteNode implementation:\n   * canMergeWhenEmpty(): true {\n   *  return true;\n   * }\n   */\n  canMergeWhenEmpty() {\n    return false;\n  }\n\n  /** @internal */\n  reconcileObservedMutation(dom, editor) {\n    const slot = this.getDOMSlot(dom);\n    let currentDOM = slot.getFirstChild();\n    for (let currentNode = this.getFirstChild(); currentNode; currentNode = currentNode.getNextSibling()) {\n      const correctDOM = editor.getElementByKey(currentNode.getKey());\n      if (correctDOM === null) {\n        continue;\n      }\n      if (currentDOM == null) {\n        slot.insertChild(correctDOM);\n        currentDOM = correctDOM;\n      } else if (currentDOM !== correctDOM) {\n        slot.replaceChild(correctDOM, currentDOM);\n      }\n      currentDOM = currentDOM.nextSibling;\n    }\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass DecoratorNode extends LexicalNode {\n  /**\n   * The returned value is added to the LexicalEditor._decorators\n   */\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  }\n\n  // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  // Mutate\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n    return super.append(...nodesToAppend);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    return $getRoot().updateFromJSON(serializedNode);\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn, options) {\n    return readEditorState(options && options.editor || null, this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(null, this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// TODO: Cleanup ArtificialNode__DO_NOT_USE #5966\nclass ArtificialNode__DO_NOT_USE extends ElementNode {\n  static getType() {\n    return 'artificial';\n  }\n  createDOM(config) {\n    // this isnt supposed to be used and is not used anywhere but defining it to appease the API\n    const dom = document.createElement('div');\n    return dom;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: $convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createParagraphNode().updateFromJSON(serializedNode);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      // These are included explicitly for backwards compatibility\n      textFormat: this.getTextFormat(),\n      textStyle: this.getTextStyle()\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(rangeSelection, restoreSelection) {\n    const newElement = $createParagraphNode();\n    newElement.setTextFormat(rangeSelection.format);\n    newElement.setTextStyle(rangeSelection.style);\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    newElement.setFormat(this.getFormatType());\n    newElement.setStyle(this.getTextStyle());\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction $convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    setNodeIndentFromDOM(element, node);\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// https://github.com/microsoft/TypeScript/issues/3841\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst DEFAULT_SKIP_INITIALIZATION = false;\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/**\n * Type helper for extracting the payload type from a command.\n *\n * @example\n * ```ts\n * const MY_COMMAND = createCommand<SomeType>();\n *\n * // ...\n *\n * editor.registerCommand(MY_COMMAND, payload => {\n *   // Type of `payload` is inferred here. But lets say we want to extract a function to delegate to\n *   $handleMyCommand(editor, payload);\n *   return true;\n * });\n *\n * function $handleMyCommand(editor: LexicalEditor, payload: CommandPayloadType<typeof MY_COMMAND>) {\n *   // `payload` is of type `SomeType`, extracted from the command.\n * }\n * ```\n */\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes, additionalConversions) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  const addConversionsToCache = map => {\n    Object.keys(map).forEach(key => {\n      let currentCache = conversionCache.get(key);\n      if (currentCache === undefined) {\n        currentCache = [];\n        conversionCache.set(key, currentCache);\n      }\n      currentCache.push(map[key]);\n    });\n  };\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM.call(node.klass);\n    if (map !== null) {\n      addConversionsToCache(map);\n    }\n  });\n  if (additionalConversions) {\n    addConversionsToCache(additionalConversions);\n  }\n  return conversionCache;\n}\n\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ArtificialNode__DO_NOT_USE, ...(config.nodes || [])];\n  const {\n    onError,\n    html\n  } = config;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replace = null;\n      let replaceWithKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replace = options.with;\n        replaceWithKlass = options.withKlass || null;\n      }\n      // Ensure custom nodes implement required methods and replaceWithKlass is instance of base klass.\n      {\n        // ArtificialNode__DO_NOT_USE can get renamed, so we use the type\n        const nodeType = Object.prototype.hasOwnProperty.call(klass, 'getType') && klass.getType();\n        const name = klass.name;\n        if (replaceWithKlass) {\n          if (!(replaceWithKlass.prototype instanceof klass)) {\n            throw Error(`${replaceWithKlass.name} doesn't extend the ${name}`);\n          }\n        }\n        if (name !== 'RootNode' && nodeType !== 'root' && nodeType !== 'artificial') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') &&\n          // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if ($isDecoratorNode(proto)) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n      registeredNodes.set(type, {\n        exportDOM: html && html.export ? html.export.get(klass) : undefined,\n        klass,\n        replace,\n        replaceWithKlass,\n        transforms\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : undefined), isEditable);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  /** The version with build identifiers for this editor (since 0.17.1) */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched with {@link LexicalEditor.dispatch}, subject to priority.\n   * Listeners that run at a higher priority can \"intercept\" commands and\n   * prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners are always invoked in an {@link LexicalEditor.update} and can\n   * call dollar functions.\n   *\n   * Listeners registered at the same priority level will run\n   * deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   *   (or {@link COMMAND_PRIORITY_EDITOR} |\n   *     {@link COMMAND_PRIORITY_LOW} |\n   *     {@link COMMAND_PRIORITY_NORMAL} |\n   *     {@link COMMAND_PRIORITY_HIGH} |\n   *     {@link COMMAND_PRIORITY_CRITICAL})\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * If any existing nodes are in the DOM, and skipInitialization is not true, the listener\n   * will be called immediately with an updateTag of 'registerMutationListener' where all\n   * nodes have the 'created' NodeMutation. This can be controlled with the skipInitialization option\n   * (whose default was previously true for backwards compatibility with &lt;=0.16.1 but has been changed to false as of 0.21.0).\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @param options - see {@link MutationListenerOptions}\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerMutationListener(klass, listener, options) {\n    const klassToMutate = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(klass)).klass;\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klassToMutate);\n    const skipInitialization = options && options.skipInitialization;\n    if (!(skipInitialization === undefined ? DEFAULT_SKIP_INITIALIZATION : skipInitialization)) {\n      this.initializeMutationListener(listener, klassToMutate);\n    }\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n\n  /** @internal */\n  getRegisteredNode(klass) {\n    const registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  resolveRegisteredNodeAfterReplacements(registeredNode) {\n    while (registeredNode.replaceWithKlass) {\n      registeredNode = this.getRegisteredNode(registeredNode.replaceWithKlass);\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  initializeMutationListener(listener, klass) {\n    const prevEditorState = this._editorState;\n    const nodeMap = getCachedTypeToNodeMap(prevEditorState).get(klass.getType());\n    if (!nodeMap) {\n      return;\n    }\n    const nodeMutationMap = new Map();\n    for (const k of nodeMap.keys()) {\n      nodeMutationMap.set(k, 'created');\n    }\n    if (nodeMutationMap.size > 0) {\n      listener(nodeMutationMap, {\n        dirtyLeaves: new Set(),\n        prevEditorState,\n        updateTags: new Set(['registerMutationListener'])\n      });\n    }\n  }\n\n  /** @internal */\n  registerNodeTransformToKlass(klass, listener) {\n    const registeredNode = this.getRegisteredNode(klass);\n    registeredNode.transforms.add(listener);\n    return registeredNode;\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markNodesWithTypesAsDirty(this, registeredNodes.map(node => node.klass.getType()));\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload. The command listeners\n   * will be triggered in an implicit {@link LexicalEditor.update}, unless\n   * this was invoked from inside an update in which case that update context\n   * will be re-used (as if this was a dollar function itself).\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n  getDecorators() {\n    return this._decorators;\n  }\n\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n  getRootElement() {\n    return this._rootElement;\n  }\n\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add('history-merge');\n        $commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n        {\n          const nextRootElementParent = nextRootElement.parentElement;\n          if (nextRootElementParent != null && ['flex', 'inline-flex'].includes(getComputedStyle(nextRootElementParent).display)) {\n            console.warn(`When using \"display: flex\" or \"display: inline-flex\" on an element containing content editable, Chrome may have unwanted focusing behavior when clicking outside of it. Consider wrapping the content editable within a non-flex element.`);\n          }\n        }\n      } else {\n        // When the content editable is unmounted we will still trigger a\n        // reconciliation so that any pending updates are flushed,\n        // to match the previous state change when\n        // `_editorState = pendingEditorState` was used, but by\n        // using a commit we preserve the readOnly invariant\n        // for editor.getEditorState().\n        this._window = null;\n        this._updateTags.add('history-merge');\n        $commitPendingUpdates(this);\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n  getEditorState() {\n    return this._editorState;\n  }\n\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n\n    // Ensure that we have a writable EditorState so that transforms can run\n    // during a historic operation\n    let writableEditorState = editorState;\n    if (writableEditorState._readOnly) {\n      writableEditorState = cloneEditorState(editorState);\n      writableEditorState._selection = editorState._selection ? editorState._selection.clone() : null;\n    }\n    $flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      $commitPendingUpdates(this);\n    }\n    this._pendingEditorState = writableEditorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n\n    // Only commit pending updates if not already in an editor.update\n    // (e.g. dispatchCommand) otherwise this will cause a second commit\n    // with an already read-only state and selection\n    if (!this._updating) {\n      $commitPendingUpdates(this);\n    }\n  }\n\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserialization from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n\n  /**\n   * Executes a read of the editor's state, with the\n   * editor context available (useful for exporting and read-only DOM\n   * operations). Much like update, but prevents any mutation of the\n   * editor's state. Any pending updates will be flushed immediately before\n   * the read.\n   * @param callbackFn - A function that has access to read-only editor state.\n   */\n  read(callbackFn) {\n    $commitPendingUpdates(this);\n    return this.getEditorState().read(callbackFn, {\n      editor: this\n    });\n  }\n\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        },\n        tag: 'focus'\n      });\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n\n  /**\n   * Removes focus from the editor.\n   */\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\nLexicalEditor.version = \"0.23.1+dev.esm\";\nexport { $addUpdateTag, $applyNodeReplacement, $cloneWithProperties, $copyNode, $createLineBreakNode, $createNodeSelection, $createParagraphNode, $createPoint, $createRangeSelection, $createRangeSelectionFromDom, $createTabNode, $createTextNode, $getAdjacentNode, $getCharacterOffsets, $getEditor, $getNearestNodeFromDOMNode, $getNearestRootOrShadowRoot, $getNodeByKey, $getNodeByKeyOrThrow, $getPreviousSelection, $getRoot, $getSelection, $getTextContent, $hasAncestor, $hasUpdateTag, $insertNodes, $isBlockElementNode, $isDecoratorNode, $isElementNode, $isInlineElementOrDecoratorNode, $isLeafNode, $isLineBreakNode, $isNodeSelection, $isParagraphNode, $isRangeSelection, $isRootNode, $isRootOrShadowRoot, $isTabNode, $isTextNode, $isTokenOrSegmented, $nodesOfType, $normalizeSelection as $normalizeSelection__EXPERIMENTAL, $onUpdate, $parseSerializedNode, $selectAll, $setCompositionKey, $setSelection, $splitNode, ArtificialNode__DO_NOT_USE, BLUR_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CLICK_COMMAND, COMMAND_PRIORITY_CRITICAL, COMMAND_PRIORITY_EDITOR, COMMAND_PRIORITY_HIGH, COMMAND_PRIORITY_LOW, COMMAND_PRIORITY_NORMAL, CONTROLLED_TEXT_INSERTION_COMMAND, COPY_COMMAND, CUT_COMMAND, DELETE_CHARACTER_COMMAND, DELETE_LINE_COMMAND, DELETE_WORD_COMMAND, DRAGEND_COMMAND, DRAGOVER_COMMAND, DRAGSTART_COMMAND, DROP_COMMAND, DecoratorNode, ElementNode, FOCUS_COMMAND, FORMAT_ELEMENT_COMMAND, FORMAT_TEXT_COMMAND, INDENT_CONTENT_COMMAND, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, INSERT_TAB_COMMAND, IS_ALL_FORMATTING, IS_BOLD, IS_CODE, IS_HIGHLIGHT, IS_ITALIC, IS_STRIKETHROUGH, IS_SUBSCRIPT, IS_SUPERSCRIPT, IS_UNDERLINE, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_ARROW_UP_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, KEY_DOWN_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, KEY_MODIFIER_COMMAND, KEY_SPACE_COMMAND, KEY_TAB_COMMAND, LineBreakNode, MOVE_TO_END, MOVE_TO_START, OUTDENT_CONTENT_COMMAND, PASTE_COMMAND, ParagraphNode, REDO_COMMAND, REMOVE_TEXT_COMMAND, RootNode, SELECTION_CHANGE_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, SELECT_ALL_COMMAND, TEXT_TYPE_TO_FORMAT, TabNode, TextNode, UNDO_COMMAND, createCommand, createEditor, getDOMOwnerDocument, getDOMSelection, getDOMSelectionFromTarget, getDOMTextNode, getEditorPropertyFromDOMNode, getNearestEditorFromDOMNode, isBlockDomNode, isCurrentlyReadOnlyMode, isDOMDocumentNode, isDOMNode, isDOMTextNode, isDOMUnmanaged, isDocumentFragment, isHTMLAnchorElement, isHTMLElement, isInlineDomNode, isLexicalEditor, isSelectionCapturedInDecoratorInput, isSelectionWithinEditor, resetRandomKey, setDOMUnmanaged, setNodeIndentFromDOM };","map":{"version":3,"names":["createCommand","type","SELECTION_CHANGE_COMMAND","SELECTION_INSERT_CLIPBOARD_NODES_COMMAND","CLICK_COMMAND","DELETE_CHARACTER_COMMAND","INSERT_LINE_BREAK_COMMAND","INSERT_PARAGRAPH_COMMAND","CONTROLLED_TEXT_INSERTION_COMMAND","PASTE_COMMAND","REMOVE_TEXT_COMMAND","DELETE_WORD_COMMAND","DELETE_LINE_COMMAND","FORMAT_TEXT_COMMAND","UNDO_COMMAND","REDO_COMMAND","KEY_DOWN_COMMAND","KEY_ARROW_RIGHT_COMMAND","MOVE_TO_END","KEY_ARROW_LEFT_COMMAND","MOVE_TO_START","KEY_ARROW_UP_COMMAND","KEY_ARROW_DOWN_COMMAND","KEY_ENTER_COMMAND","KEY_SPACE_COMMAND","KEY_BACKSPACE_COMMAND","KEY_ESCAPE_COMMAND","KEY_DELETE_COMMAND","KEY_TAB_COMMAND","INSERT_TAB_COMMAND","INDENT_CONTENT_COMMAND","OUTDENT_CONTENT_COMMAND","DROP_COMMAND","FORMAT_ELEMENT_COMMAND","DRAGSTART_COMMAND","DRAGOVER_COMMAND","DRAGEND_COMMAND","COPY_COMMAND","CUT_COMMAND","SELECT_ALL_COMMAND","CLEAR_EDITOR_COMMAND","CLEAR_HISTORY_COMMAND","CAN_REDO_COMMAND","CAN_UNDO_COMMAND","FOCUS_COMMAND","BLUR_COMMAND","KEY_MODIFIER_COMMAND","CAN_USE_DOM","window","document","createElement","documentMode","IS_APPLE","test","navigator","platform","IS_FIREFOX","userAgent","CAN_USE_BEFORE_INPUT","InputEvent","IS_SAFARI","IS_IOS","MSStream","IS_ANDROID","IS_CHROME","IS_ANDROID_CHROME","IS_APPLE_WEBKIT","DOM_ELEMENT_TYPE","DOM_TEXT_TYPE","DOM_DOCUMENT_TYPE","DOM_DOCUMENT_FRAGMENT_TYPE","NO_DIRTY_NODES","HAS_DIRTY_NODES","FULL_RECONCILE","IS_NORMAL","IS_TOKEN","IS_SEGMENTED","IS_BOLD","IS_ITALIC","IS_STRIKETHROUGH","IS_UNDERLINE","IS_CODE","IS_SUBSCRIPT","IS_SUPERSCRIPT","IS_HIGHLIGHT","IS_LOWERCASE","IS_UPPERCASE","IS_CAPITALIZE","IS_ALL_FORMATTING","IS_DIRECTIONLESS","IS_UNMERGEABLE","IS_ALIGN_LEFT","IS_ALIGN_CENTER","IS_ALIGN_RIGHT","IS_ALIGN_JUSTIFY","IS_ALIGN_START","IS_ALIGN_END","NON_BREAKING_SPACE","ZERO_WIDTH_SPACE","COMPOSITION_SUFFIX","DOUBLE_LINE_BREAK","COMPOSITION_START_CHAR","RTL","LTR","RTL_REGEX","RegExp","LTR_REGEX","TEXT_TYPE_TO_FORMAT","bold","capitalize","code","highlight","italic","lowercase","strikethrough","subscript","superscript","underline","uppercase","DETAIL_TYPE_TO_DETAIL","directionless","unmergeable","ELEMENT_TYPE_TO_FORMAT","center","end","justify","left","right","start","ELEMENT_FORMAT_TO_TYPE","TEXT_MODE_TO_TYPE","normal","segmented","token","TEXT_TYPE_TO_MODE","normalizeClassNames","classNames","rval","className","s","matchAll","push","TEXT_MUTATION_VARIANCE","isProcessingMutations","lastTextEntryTimeStamp","getIsProcessingMutations","updateTimeStamp","event","timeStamp","initTextEntryListener","editor","getWindow","addEventListener","isManagedLineBreak","dom","target","isBR","nodeName","lexicalLineBreak","__lexicalLineBreak","previousSibling","getNodeKeyFromDOMNode","undefined","getLastSelection","getEditorState","read","selection","$getSelection","clone","$handleTextMutation","node","domSelection","getDOMSelection","_window","anchorOffset","focusOffset","anchorNode","text","nodeValue","$updateTextNodeFromDOMContent","shouldUpdateTextNodeFromMutation","targetDOM","targetNode","$isRangeSelection","anchor","getNode","is","format","getFormat","isDOMTextNode","isAttached","$getNearestManagedNodePairFromDOMNode","startingDOM","editorState","rootElement","isDOMUnmanaged","getParentElement","key","$getNodeByKey","$isDecoratorNode","isHTMLElement","internalGetRoot","$flushMutations$1","mutations","observer","shouldFlushTextMutations","performance","now","updateEditor","badDOMTargets","Map","getRootElement","currentEditorState","_editorState","blockCursorElement","_blockCursorElement","shouldRevertSelection","possibleTextForFirefoxPaste","i","length","mutation","pair","nodeDOM","$isTextNode","addedDOMs","addedNodes","addedDOM","$getNodeFromDOMNode","parentDOM","parentNode","possibleText","innerText","removeChild","removedDOMs","removedNodes","removedDOMsLength","unremovedBRs","removedDOM","appendChild","set","size","reconcileObservedMutation","records","takeRecords","record","dirty","$setSelection","isFirefoxClipboardEvents","insertRawText","$flushRootMutations","_observer","initMutationObserver","MutationObserver","$canSimpleTextNodesBeMerged","node1","node2","node1Mode","__mode","node1Format","__format","node1Style","__style","node2Mode","node2Format","node2Style","$mergeTextNodes","writableNode1","mergeWithSibling","normalizedNodes","getActiveEditor","_normalizedNodes","add","__key","$normalizeTextNode","textNode","__text","isSimpleText","isUnmergeable","remove","previousNode","getPreviousSibling","nextNode","getNextSibling","$normalizeSelection","$normalizePoint","focus","point","offset","nextOffsetAtEnd","getChildrenSize","getChildAtIndex","getTextContentSize","$isElementNode","keyCounter","resetRandomKey","generateRandomKey","getRegisteredNodeOrThrow","nodeType","registeredNode","_nodes","get","Error","scheduleMicroTask","queueMicrotask","fn","Promise","resolve","then","$isSelectionCapturedInDecorator","$getNearestNodeFromDOMNode","isSelectionCapturedInDecoratorInput","anchorDOM","activeElement","contentEditable","getEditorPropertyFromDOMNode","isSelectionWithinEditor","focusDOM","contains","getNearestEditorFromDOMNode","error","isLexicalEditor","LexicalEditor","currentNode","__lexicalEditor","getTextDirection","$isTokenOrSegmented","isToken","isSegmented","isDOMNode","isDOMDocumentNode","getDOMTextNode","element","firstChild","toggleTextFormatType","alignWithFormat","activeFormat","newFormat","$isLeafNode","$isLineBreakNode","$setNodeKey","existingKey","errorOnNodeKeyConstructorMismatch","errorOnReadOnly","errorOnInfiniteTransforms","getActiveEditorState","_nodeMap","_dirtyElements","_dirtyLeaves","_cloneNotNeeded","_dirtyType","internalGetActiveEditorState","existingNode","constructor","name","internalMarkParentElementsAsDirty","parentKey","nodeMap","dirtyElements","nextParentKey","has","__parent","removeFromParent","oldParent","getParent","writableNode","getWritable","writableParent","prevSibling","nextSibling","writableNextSibling","__first","__prev","writablePrevSibling","__next","__last","__size","internalMarkNodeAsDirty","latest","getLatest","parent","internalMarkSiblingsAsDirty","$setCompositionKey","compositionKey","previousCompositionKey","_compositionKey","$getCompositionKey","isCurrentlyReadOnlyMode","setNodeKeyOnDOMNode","prop","_key","cloneDecorators","currentDecorators","_decorators","pendingDecorators","Object","assign","_pendingDecorators","getEditorStateTextContent","$getRoot","getTextContent","markNodesWithTypesAsDirty","types","cachedMap","getCachedTypeToNodeMap","dirtyNodeMaps","update","nodeKey","keys","markDirty","_pendingEditorState","tag","isFrozen","setCachedNodes","_selection","$flushMutations","$getNodeFromDOM","getNodeKeyFromDOMTree","getTextNodeOffset","moveSelectionToEnd","doesContainGrapheme","str","getEditorsToPropagate","editorsToPropagate","currentEditor","_parentEditor","createUID","Math","random","toString","replace","substr","getAnchorTextFromDOM","$updateSelectedTextFromDOM","isCompositionEnd","data","textContent","compositionEnd","isDirty","isComposing","normalizedTextContent","slice","prevTextContent","setTimeout","prevSelection","$getPreviousSelection","prevTextContentSize","getKey","canInsertTextBefore","canInsertTextAfter","setTextContent","setTextNodeRange","originalTextContent","replacement","$createTextNode","$previousSiblingDoesNotAcceptText","isInline","$shouldInsertTextAfterOrBeforeTextNode","isCollapsed","getParentOrThrow","isTab","altKey","ctrlKey","metaKey","isBold","toLowerCase","controlOrMeta","isItalic","isUnderline","isParagraph","shiftKey","isReturn","isLineBreak","isOpenLineBreak","isDeleteWordBackward","isBackspace","isDeleteWordForward","isDelete","isDeleteLineBackward","isDeleteLineForward","isDeleteBackward","isDeleteForward","isUndo","isRedo","isCopy","isCut","isArrowLeft","isArrowRight","isArrowUp","isArrowDown","isMoveBackward","isMoveToStart","isMoveForward","isMoveToEnd","isMoveUp","isMoveDown","isModifier","isSpace","isEscape","isSelectAll","$selectAll","root","topParent","getTopLevelElementOrThrow","rootNode","newSelection","select","getCachedClassNameArray","classNamesTheme","classNameThemeType","__lexicalClassNameCache","classNamesCache","cachedClassNames","classNamesArr","setMutatedNode","mutatedNodes","registeredNodes","mutationListeners","__type","klass","mutatedNodesByType","prevMutation","isMove","$nodesOfType","klassType","getType","_readOnly","nodes","Array","from","values","nodesOfType","resolveElement","isBackward","block","getIndexWithinParent","$getAdjacentNode","focusNode","possibleNode","inputType","dispatchCommand","command","payload","triggerCommandListeners","$textContentRequiresDoubleLinebreakAtEnd","$isRootNode","isLastChild","getElementByKeyOrThrow","_keyToDOMMap","parentElement","assignedSlot","isDocumentFragment","host","getDOMOwnerDocument","ownerDocument","scrollIntoViewIfNeeded","selectionRect","doc","defaultView","getDefaultView","top","currentTop","bottom","currentBottom","targetTop","targetBottom","isBodyElement","body","innerHeight","targetRect","getBoundingClientRect","diff","scrollBy","scrollTop","yOffset","$hasUpdateTag","_updateTags","$addUpdateTag","$onUpdate","updateFn","_deferred","$maybeMoveChildrenSelectionToParent","$hasAncestor","child","domElem","ownerDoc","windowObj","$isInlineElementOrDecoratorNode","$getNearestRootOrShadowRoot","$isRootOrShadowRoot","isShadowRoot","$copyNode","copy","$applyNodeReplacement","replaceWithKlass","replacementNode","replacementNodeKlass","errorOnInsertTextNodeOnRoot","insertNode","$getNodeByKeyOrThrow","createBlockCursorElement","editorConfig","theme","setAttribute","blockCursorTheme","blockCursor","classList","needsBlockCursor","canBeEmpty","removeDOMBlockCursorElement","style","removeProperty","updateDOMBlockCursorElement","nextSelection","elementNode","elementNodeSize","isBlockCursor","insertBeforeElement","sibling","getElementByKey","elementDOM","_config","caretColor","insertBefore","targetWindow","getSelection","getDOMSelectionFromTarget","eventTarget","$splitNode","startNode","recurse","isParentRoot","nodeToMove","insertAfter","leftTree","rightTree","newParent","nextSiblings","getNextSiblings","append","isHTMLAnchorElement","x","tagName","isInlineDomNode","inlineNodes","match","isBlockDomNode","blockNodes","INTERNAL_$isBlock","getFirstChild","isLeafElement","$getAncestor","predicate","$getEditor","cachedNodeMaps","WeakMap","EMPTY_TYPE_TO_NODE_MAP","isEmpty","typeToNodeMap","computeTypeToNodeMap","$cloneWithProperties","latestNode","mutableNode","afterCloneFrom","setNodeIndentFromDOM","elementDom","indentSize","parseInt","paddingInlineStart","indent","setIndent","setDOMUnmanaged","el","__lexicalUnmanaged","$garbageCollectDetachedDecorators","pendingEditorState","decorators","$garbageCollectDetachedDeepChildNodes","prevNodeMap","nodeMapDelete","dirtyNodes","childKey","delete","$garbageCollectDetachedNodes","prevEditorState","dirtyLeaves","subTreeTextContent","subTreeDirectionedTextContent","subTreeTextFormat","subTreeTextStyle","editorTextContent","activeEditorConfig","activeEditor$1","activeEditorNodes","treatAllNodesAsDirty","activeEditorStateReadOnly","activeMutationListeners","activeTextDirection","activeDirtyElements","activeDirtyLeaves","activePrevNodeMap","activeNextNodeMap","activePrevKeyToDOMMap","destroyNode","getPrevElementByKeyOrThrow","children","createChildrenArray","destroyChildren","_startIndex","endIndex","startIndex","setTextAlign","domStyle","value","setProperty","DEFAULT_INDENT_VALUE","setElementIndent","indentClassName","elementHasClassName","indentationBaseValue","getComputedStyle","getPropertyValue","setElementFormat","$createNode","slot","createDOM","storeDOMWithKey","__indent","childrenSize","$createChildrenWithDirection","reconcileElementTerminatingLineBreak","decorator","decorate","reconcileDecorator","isDirectionless","insertChild","freeze","previousSubTreeDirectionedTextContent","$createChildren","getDOMSlot","reconcileBlockDirection","previousSubTreeTextContent","getStyle","__lexicalTextContent","isLastChildLineBreakOrDecorator","lastKey","prevElement","nextElement","prevLineBreak","nextLineBreak","setManagedLineBreak","reconcileTextFormat","__textFormat","setTextFormat","setTextStyle","reconcileTextStyle","__textStyle","previousSubTreeDirectionTextContent","__lexicalDirTextContent","previousDirection","__lexicalDir","hasEmptyDirectionedTextContent","direction","previousDirectionTheme","nextDirectionTheme","removeAttribute","dir","__dir","$reconcileChildrenWithDirection","$reconcileChildren","prevChildrenSize","nextChildrenSize","prevFirstChildKey","nextFirstChildKey","$reconcileNode","lastDOM","replacementDOM","replaceChild","msg","nextChildNode","prevChildren","nextChildren","canUseFastPath","after","before","$reconcileNodeChildren","prevNode","updateDOM","nextIndent","nextFormat","__cachedText","nextRootNode","prevChildrenLength","nextChildrenLength","prevEndIndex","nextEndIndex","prevChildrenSet","nextChildrenSet","siblingDOM","prevIndex","nextIndex","prevKey","nextKey","Set","nextHasPrevKey","prevHasNextKey","withBefore","childDOM","appendNewChildren","removeOldChildren","insertDOM","$reconcileRoot","nextEditorState","dirtyType","_listeners","currentMutatedNodes","keyToDOMMap","PASS_THROUGH_COMMAND","ANDROID_COMPOSITION_LATENCY","rootElementEvents","onKeyDown","onPointerDown","onCompositionStart","onCompositionEnd","onInput","onClick","onBeforeInput","lastKeyDownTimeStamp","lastKeyCode","lastBeforeInputInsertTextTimeStamp","unprocessedBeforeInputData","rootElementsRegistered","isSelectionChangeFromDOMUpdate","isSelectionChangeFromMouseDown","isInsertLineBreak","isFirefoxEndingComposition","collapsedSelectionFormat","$shouldPreventDefaultAndInsertText","domTargetRange","isBeforeInput","domAnchorNode","anchorKey","backingAnchorElement","textLength","collapsed","startContainer","startOffset","shouldSkipSelectionChange","domNode","onSelectionChange","isActive","windowEvent","currentTimeStamp","lastFormat","lastStyle","lastOffset","isRootTextContentEmpty","lastNode","getTextFormat","getTextStyle","focusKey","getNodes","nodesLength","endOffset","startKey","endKey","combinedFormat","hasTextNodes","textContentSize","lastSelection","removeAllRanges","detail","pointerType","$internalCreateRangeSelection","button","getTargetRange","getTargetRanges","targetRanges","$canRemoveText","isPossiblyAndroidKeyPress","targetRange","isSelectionAnchorSameAsFocus","preventDefault","selectedNode","selectedNodeText","selectedNodeCanInsertTextAfter","hasSelectedAllTextInNode","shouldLetBrowserHandleDelete","applyDOMRange","dataTransfer","getData","stopPropagation","$onCompositionEndImpl","characterData","getRootElementRemoveHandles","eventHandles","__lexicalEventHandles","activeNestedEditorsMap","onDocumentSelectionChange","nextActiveEditor","editors","rootEditor","rootEditorKey","activeNestedEditor","prevActiveEditor","stopLexicalPropagation","_lexicalHandled","hasStoppedLexicalPropagation","stopped","addRootElementEvents","documentRootElementsCount","removeHandles","eventName","onEvent","eventHandler","isEditable","removeEventListener","removeRootElementEvents","newCount","cleanActiveNestedEditorsMap","markSelectionChangeFromDOMUpdate","markCollapsedSelectionFormat","$removeNode","nodeToRemove","restoreSelection","preserveEmptyParent","selectionMoved","moveSelectionPointToSibling","$isNodeSelection","isSelected","selectPrevious","index","$updateElementSelectionOnCreateDeleteNode","selectEnd","LexicalNode","_data","errorOnTypeKlassMismatch","targetSelection","some","n","isElementRangeSelection","firstPoint","firstElement","getLastChildOrThrow","getTopLevelElement","getParents","parents","getParentKeys","self","getPreviousSiblings","siblings","getCommonAncestor","a","b","unshift","aLength","bLength","bSet","ancestor","object","isBefore","isParentOf","commonAncestor","indexA","indexB","getNodesBetween","visited","getLastChild","parentSibling","reverse","cloneNotNeeded","_editor","_prevNode","_dom","exportDOM","exportJSON","version","importJSON","_serializedNode","updateFromJSON","serializedNode","transform","replaceWith","includeChildren","toReplaceKey","writableReplaceWith","getChildren","forEach","$moveSelectionPointToEnd","nodeToInsert","writableSelf","writableNodeToInsert","elementAnchorSelectionOnNode","elementFocusSelectionOnNode","oldIndex","oldParentKey","insertKey","writableParentKey","isParentRequired","createParentElementNode","$createParagraphNode","selectStart","selectNext","editorKlass","insertRangeAfter","firstToInsert","lastToInsert","lastToInsert2","current","nodesToInsert","LineBreakNode","importDOM","br","isOnlyChildInBlockNode","isLastChildInBlockNode","conversion","$convertLineBreakElement","priority","serializedLineBreakNode","$createLineBreakNode","isWhitespaceDomTextNode","lastChild","getElementOuterTag","getElementInnerTag","setTextThemeClassNames","prevFormat","textClassNames","domClassList","hasUnderlineStrikethrough","prevUnderlineStrikethrough","nextUnderlineStrikethrough","flag","diffComposedText","nextText","suffix","insert","deleteData","insertData","createTextInnerDOM","innerDOM","innerTag","config","wrapElementWith","TextNode","__detail","getDetail","getMode","hasFormat","formatFlag","getFormatFlags","canHaveFormat","outerTag","cssText","prevOuterTag","nextOuterTag","prevInnerTag","nextInnerTag","prevTag","nextTag","prevInnerDOM","nextInnerDOM","prevStyle","nextStyle","#text","$convertTextDOMNode","convertBringAttentionToElement","convertTextFormatElement","em","span","convertSpanElement","strong","sub","sup","u","setFormat","setDetail","setMode","mode","setStyle","whiteSpace","selectionTransform","toggleFormat","toggleDirectionless","toggleUnmergeable","_anchorOffset","_focusOffset","$internalMakeRangeSelection","spliceText","delCount","newText","moveSelection","handledTextLength","newOffset","updatedText","splitText","splitOffsets","offsetsSet","parts","string","partsLength","firstPart","hasReplacedSelf","splitNodes","textSize","part","partSize","siblingKey","nextTextSize","insertionIndex","splice","targetKey","adjustPointOffsetForMergedSibling","targetText","isTextEntity","forChild","applyTextFormatFromStyle","hasNormalFontWeight","fontWeight","preParentCache","isNodePre","startsWith","findParentPreDOMNode","cached","resultNode","domNode_","parentDom","split","$createTabNode","previousText","isStartOfLine","findTextInLine","previousTextContent","isEndOfLine","nextTextContent","forward","display","descendant","nodeNameToTextFormat","shouldApply","textDecoration","hasBoldFontWeight","hasLinethroughTextDecoration","includes","hasItalicFontStyle","fontStyle","hasUnderlineTextDecoration","verticalAlign","lexicalNode","TabNode","serializedTabNode","$isTabNode","Point","defineProperty","enumerable","writable","aNode","bNode","aOffset","bOffset","aNodeDescendant","getDescendantByIndex","bNodeDescendant","oldKey","$createPoint","selectPointOnNode","textContentLength","getLastDescendant","$transferStartingElementPointToTextPoint","placementNode","$setPointValues","NodeSelection","objects","_cachedNodes","getCachedNodes","every","getStartEndPoints","clear","extract","insertText","insertNodes","selectedNodes","selectedNodesLength","lastSelectedNode","selectionAtEnd","cachedNodes","RangeSelection","lastPoint","firstNode","overselectedFirstNode","firstNodeDescendant","lastNodeDescendant","deleteCount","findIndex","$getCharacterOffsets","prevWasElement","range","resolvedSelectionPoints","$internalResolveSelectionPoints","endContainer","anchorPoint","focusPoint","endPoint","firstNodeText","firstNodeTextLength","firstNodeParent","lastIndex","lastNodeParent","$normalizeSelectionPointsForBoundaries","firstNodeFormat","firstNodeStyle","markedNodeKeysForKeep","lastElement","lastElementChild","lastNodeChildren","selectedNodesSet","firstAndLastElementsAreEqual","insertionTarget","lastNodeChild","lastRemovedParent","childrenLength","removeText","firstBlock","lastBlock","fixText","del","abs","bothElem","formatText","formatType","selectedTextNodes","applyFormatToElements","alignWith","selectedTextNodesLength","startPoint","firstIndex","firstNextFormat","lastNextFormat","insertParagraph","last","$removeTextAndSplitBlock","notInline","blocksParent","$wrapInlineNodes","nodeToSelect","blocks","isMergeable","canMergeWhenEmpty","shouldInsert","insertedParagraph","lastInsertedBlock","paragraph","firstToAppend","newBlock","insertNewAfter","insertLineBreak","lineBreak","shift","lastNodeText","lastNodeTextLength","pop","modify","alter","granularity","collapse","isIsolated","isKeyboardSelectable","nodeSelection","$createNodeSelection","elementKey","_rootElement","moveNativeSelection","rangeCount","getRangeAt","validNodes","shrinkSelection","firstValidNode","lastValidNode","$swapPoints","forwardDeletion","deleteCharacter","wasCollapsed","$removeSegment","$updateCaretSelectionForUnicodeCharacter","collapseAtStart","deleteLine","anchorIsElement","deleteWord","getCharacterOffset","anchorAndFocus","anchorType","characterOffset","splitLength","segmentOffset","restoreOffset","isLast","join","trim","shouldResolveAncestor","resolvedElement","resolvedOffset","$internalResolveSelectionPoint","resolvedNode","childNodes","childNodesLength","hasBlockCursor","blockCursorElementParent","blockCursorOffset","prototype","indexOf","call","resolveChildIndex","max","getFirstDescendant","min","resolveSelectionPointOnBoundary","lastAnchor","lastFocus","resolvedAnchorPoint","$validatePoint","resolvedFocusPoint","$isBlockElementNode","focusType","$createRangeSelection","$internalCreateSelection","$createRangeSelectionFromDom","eventType","isSelectionChange","useDOMSelection","String","nodeOffset","times","selectionOffset","newSelectionOffset","$updateSelectionResolveTextNodes","firstPointNode","lastPointNode","firstPointOffset","lastPointOffset","childSize","anchorOffsetAtEnd","focusOffsetAtEnd","applySelectionTransforms","updateDOMSelection","tags","nodeCount","anchorDOMNode","focusDOMNode","nextAnchorOffset","nextFocusOffset","nextAnchorNode","nextFocusNode","anchorFormatOrStyleChanged","preventScroll","setBaseAndExtent","console","warn","selectionTarget","Text","createRange","selectNode","$insertNodes","$getTextContent","selection_","$splitNodeAtPoint","insertPoint","newElement","virtualRoot","currentBlock","isLineBreakNode","activeEditorState","activeEditor","isReadOnlyMode","isAttemptingToRecoverFromReconcilerError","infiniteTransformCount","observerOptions","childList","subtree","collectBuildInformation","compatibleEditors","incompatibleEditors","thisVersion","querySelectorAll","output","internalGetActiveEditor","$applyTransforms","transformsCache","transformsArr","transforms","transformsArrLength","$isNodeValidForTransform","$normalizeAllDirtyTextNodes","addTags","updateTags","tags_","isArray","$applyAllTransforms","untransformedDirtyLeaves","untransformedDirtyLeavesLength","untransformedDirtyElements","untransformedDirtyElementsLength","currentUntransformedDirtyElement","intentionallyMarkedAsDirty","$parseSerializedNode","internalSerializedNode","$parseSerializedNodeImpl","nodeClass","serializedJSONChildNode","childNode","parseEditorState","serializedEditorState","createEmptyEditorState","previousActiveEditorState","previousReadOnlyMode","previousActiveEditor","previousDirtyElements","previousDirtyLeaves","previousCloneNotNeeded","previousDirtyType","handleDEVOnlyPendingUpdateGuarantees","_onError","readEditorState","callbackFn","$commitPendingUpdates","recoveryEditorState","shouldSkipDOM","_headless","currentSelection","pendingSelection","needsUpdate","previouslyUpdating","_updating","disconnect","resetEditor","observe","deferred","_editable","triggerMutationListeners","triggerListeners","triggerTextContentListeners","triggerDeferredUpdateCallbacks","$triggerEnqueuedUpdates","currentTextContent","latestTextContent","listeners","listenersLength","listener","isCurrentlyEnqueuingUpdates","apply","returnVal","e","commandListeners","_commands","listenerInPriorityOrder","listenersSet","j","queuedUpdates","_updates","queuedUpdate","options","$beginUpdate","processNestedUpdates","initialSkipTransforms","skipTransforms","nextUpdateFn","onUpdate","discrete","_flushSync","editorStateWasCloned","cloneEditorState","startingCompositionKey","endingCompositionKey","pendingNodeMap","shouldUpdate","editorStateHasDirtySelection","ElementDOMSlot","withAfter","withElement","getManagedLineBreak","prevDom","lineBreakType","removeManagedLineBreak","webkitHack","insertManagedLineBreak","prevBreak","img","alt","getFirstChildOffset","initialDOM","initialOffset","firstChildOffset","initialPath","indexPath","elementPath","source","path","ElementNode","getFormatType","getIndent","getChildrenKeys","parentLastChild","getAllTextNodes","textNodes","subChildrenNodes","firstKey","getFirstChildOrThrow","getDirection","hasTextFormat","childrenCount","nodesToAppend","setDirection","indentLevel","nodesToInsertLength","oldSize","writableSelfKey","nodesToInsertKeys","nodesToRemoveKeys","nodeAfterRange","nodeBeforeRange","newSize","nodeToDelete","nodeKeyToDelete","writableNodeToDelete","nodeKeyToInsert","writablePrevNode","writableNodeAfterRange","nodesToRemoveKeySet","nodesToInsertKeySet","isPointRemoved","json","textFormat","textStyle","canIndent","excludeFromCopy","destination","canReplaceWith","canInsertAfter","canMergeWith","extractWithChild","currentDOM","correctDOM","DecoratorNode","RootNode","cachedText","$createRootNode","EditorState","exportNodeToJSON","serializedChildren","serializedChildNode","toJSON","ArtificialNode__DO_NOT_USE","ParagraphNode","p","$convertParagraphElement","textAlign","rangeSelection","$isParagraphNode","DEFAULT_SKIP_INITIALIZATION","COMMAND_PRIORITY_EDITOR","COMMAND_PRIORITY_LOW","COMMAND_PRIORITY_NORMAL","COMMAND_PRIORITY_HIGH","COMMAND_PRIORITY_CRITICAL","prevRootElement","nextRootElement","keyNodeMap","initializeConversionCache","additionalConversions","conversionCache","handledConversions","addConversionsToCache","map","currentCache","createEditor","parentEditor","disableEvents","namespace","initialEditorState","onError","html","editable","with","withKlass","hasOwnProperty","proto","method","export","import","htmlConversions","textcontent","_htmlConversions","registerUpdateListener","listenerSetOrMap","registerEditableListener","registerDecoratorListener","registerTextContentListener","registerRootListener","registerCommand","commandsMap","listenersInPriorityOrder","registerMutationListener","klassToMutate","resolveRegisteredNodeAfterReplacements","getRegisteredNode","skipInitialization","initializeMutationListener","nodeMutationMap","k","registerNodeTransformToKlass","registerNodeTransform","registeredReplaceWithNode","hasNode","hasNodes","bind","getDecorators","setRootElement","userSelect","wordBreak","nextRootElementParent","setEditorState","writableEditorState","maybeStringifiedEditorState","JSON","parse","defaultSelection","blur","setEditable","$normalizeSelection__EXPERIMENTAL"],"sources":["/Users/Matt.Ratliff/Development/lexical-sandbox/node_modules/lexical/Lexical.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createCommand(type) {\n  return {\n    type\n  } ;\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand('SELECTION_INSERT_CLIPBOARD_NODES_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3;\nconst DOM_DOCUMENT_TYPE = 9;\nconst DOM_DOCUMENT_FRAGMENT_TYPE = 11;\n\n// Reconciling\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2;\n\n// Text node modes\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_LOWERCASE = 1 << 8;\nconst IS_UPPERCASE = 1 << 9;\nconst IS_CAPITALIZE = 1 << 10;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT | IS_LOWERCASE | IS_UPPERCASE | IS_CAPITALIZE;\n\n// Text node details\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6;\n\n// Reconciliation\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  capitalize: IS_CAPITALIZE,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  lowercase: IS_LOWERCASE,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE,\n  uppercase: IS_UPPERCASE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcessingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  const isBR = dom.nodeName === 'BR';\n  const lexicalLineBreak = target.__lexicalLineBreak;\n  return lexicalLineBreak && (dom === lexicalLineBreak || isBR && dom.previousSibling === lexicalLineBreak) || isBR && getNodeKeyFromDOMNode(dom, editor) !== undefined;\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction $handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return isDOMTextNode(targetDOM) && targetNode.isAttached();\n}\nfunction $getNearestManagedNodePairFromDOMNode(startingDOM, editor, editorState, rootElement) {\n  for (let dom = startingDOM; dom && !isDOMUnmanaged(dom); dom = getParentElement(dom)) {\n    const key = getNodeKeyFromDOMNode(dom, editor);\n    if (key !== undefined) {\n      const node = $getNodeByKey(key, editorState);\n      if (node) {\n        // All decorator nodes are unmanaged\n        return $isDecoratorNode(node) || !isHTMLElement(dom) ? undefined : [dom, node];\n      }\n    } else if (dom === rootElement) {\n      return [rootElement, internalGetRoot(editorState)];\n    }\n  }\n}\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        const pair = $getNearestManagedNodePairFromDOMNode(targetDOM, editor, currentEditorState, rootElement);\n        if (!pair) {\n          continue;\n        }\n        const [nodeDOM, targetNode] = pair;\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && isDOMTextNode(targetDOM) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            $handleTextMutation(targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = $getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && !isManagedLineBreak(addedDOM, parentDOM, editor)) {\n              if (IS_FIREFOX) {\n                const possibleText = (isHTMLElement(addedDOM) ? addedDOM.innerText : null) || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              badDOMTargets.set(nodeDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [nodeDOM, targetNode] of badDOMTargets) {\n          targetNode.reconcileObservedMutation(nodeDOM, editor);\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction $flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet keyCounter = 1;\nfunction resetRandomKey() {\n  keyCounter = 1;\n}\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (!isHTMLElement(activeElement)) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' && getEditorPropertyFromDOMNode(activeElement) == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * @returns true if the given argument is a LexicalEditor instance from this build of Lexical\n */\nfunction isLexicalEditor(editor) {\n  // Check instanceof to prevent issues with multiple embedded Lexical installations\n  return editor instanceof LexicalEditor;\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const editor = getEditorPropertyFromDOMNode(currentNode);\n    if (isLexicalEditor(editor)) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\n\n/** @internal */\nfunction getEditorPropertyFromDOMNode(node) {\n  // @ts-expect-error: internal field\n  return node ? node.__lexicalEditor : null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\n\n/**\n * @param node - The element being tested\n * @returns Returns true if node is an DOM Text node, false otherwise.\n */\nfunction isDOMTextNode(node) {\n  return isDOMNode(node) && node.nodeType === DOM_TEXT_TYPE;\n}\n\n/**\n * @param node - The element being tested\n * @returns Returns true if node is an DOM Document node, false otherwise.\n */\nfunction isDOMDocumentNode(node) {\n  return isDOMNode(node) && node.nodeType === DOM_DOCUMENT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {\n    return format;\n  }\n  let newFormat = format ^ activeFormat;\n  if (type === 'subscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;\n  } else if (type === 'superscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;\n  } else if (type === 'lowercase') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;\n  } else if (type === 'uppercase') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;\n  } else if (type === 'capitalize') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;\n  }\n  return newFormat;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    {\n      errorOnNodeKeyConstructorMismatch(node, existingKey);\n    }\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction errorOnNodeKeyConstructorMismatch(node, existingKey) {\n  const editorState = internalGetActiveEditorState();\n  if (!editorState) {\n    // tests expect to be able to do this kind of clone without an active editor state\n    return;\n  }\n  const existingNode = editorState._nodeMap.get(existingKey);\n  if (existingNode && existingNode.constructor !== node.constructor) {\n    // Lifted condition to if statement because the inverted logic is a bit confusing\n    if (node.constructor.name !== existingNode.constructor.name) {\n      {\n        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with constructor ${existingNode.constructor.name}. Keys must not be re-used when the type is changed.`);\n      }\n    } else {\n      {\n        throw Error(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.`);\n      }\n    }\n  }\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\n// TODO #6031 this function or their callers have to adjust selection (i.e. insertBefore)\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n    // TODO: this function duplicates a bunch of operations, can be simplified.\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n      writableNode.__prev = null;\n    }\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n      writableNode.__next = null;\n    }\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction $getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor();\n  const key = getNodeKeyFromDOMNode(dom, editor);\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction setNodeKeyOnDOMNode(dom, editor, key) {\n  const prop = `__lexicalKey_${editor._key}`;\n  dom[prop] = key;\n}\nfunction getNodeKeyFromDOMNode(dom, editor) {\n  const prop = `__lexicalKey_${editor._key}`;\n  return dom[prop];\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = $getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markNodesWithTypesAsDirty(editor, types) {\n  // We only need to mark nodes dirty if they were in the previous state.\n  // If they aren't, then they are by definition dirty already.\n  const cachedMap = getCachedTypeToNodeMap(editor.getEditorState());\n  const dirtyNodeMaps = [];\n  for (const type of types) {\n    const nodeMap = cachedMap.get(type);\n    if (nodeMap) {\n      // By construction these are non-empty\n      dirtyNodeMaps.push(nodeMap);\n    }\n  }\n  // Nothing to mark dirty, no update necessary\n  if (dirtyNodeMaps.length === 0) {\n    return;\n  }\n  editor.update(() => {\n    for (const nodeMap of dirtyNodeMaps) {\n      for (const nodeKey of nodeMap.keys()) {\n        // We are only concerned with nodes that are still in the latest NodeMap,\n        // if they no longer exist then markDirty would raise an exception\n        const latest = $getNodeByKey(nodeKey);\n        if (latest) {\n          latest.markDirty();\n        }\n      }\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection.setCachedNodes(null);\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  $flushRootMutations(editor);\n}\nfunction $getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOMTree(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\nfunction getNodeKeyFromDOMTree(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    const key = getNodeKeyFromDOMNode(node, editor);\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  return isDOMTextNode(anchorNode) ? anchorNode.nodeValue : null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() && !node.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() && !node.isComposing() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(key, altKey, ctrlKey, metaKey) {\n  return key === 'Tab' && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'b' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'i' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(key, altKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'u' && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(key, shiftKey) {\n  return isReturn(key) && !shiftKey;\n}\nfunction isLineBreak(key, shiftKey) {\n  return isReturn(key) && shiftKey;\n}\n\n// Inserts a new line after the selection\n\nfunction isOpenLineBreak(key, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && key.toLowerCase() === 'o';\n}\nfunction isDeleteWordBackward(key, altKey, ctrlKey) {\n  return isBackspace(key) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(key, altKey, ctrlKey) {\n  return isDelete(key) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(key, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(key);\n}\nfunction isDeleteLineForward(key, metaKey) {\n  return IS_APPLE && metaKey && isDelete(key);\n}\nfunction isDeleteBackward(key, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n    return isBackspace(key) || key.toLowerCase() === 'h' && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isBackspace(key);\n}\nfunction isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n    return isDelete(key) || key.toLowerCase() === 'd' && ctrlKey;\n  }\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n  return isDelete(key);\n}\nfunction isUndo(key, shiftKey, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'z' && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(key, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return key.toLowerCase() === 'z' && metaKey && shiftKey;\n  }\n  return key.toLowerCase() === 'y' && ctrlKey || key.toLowerCase() === 'z' && ctrlKey && shiftKey;\n}\nfunction isCopy(key, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'c') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isCut(key, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n  if (key.toLowerCase() === 'x') {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n  return false;\n}\nfunction isArrowLeft(key) {\n  return key === 'ArrowLeft';\n}\nfunction isArrowRight(key) {\n  return key === 'ArrowRight';\n}\nfunction isArrowUp(key) {\n  return key === 'ArrowUp';\n}\nfunction isArrowDown(key) {\n  return key === 'ArrowDown';\n}\nfunction isMoveBackward(key, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(key) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(key, ctrlKey, altKey, metaKey) {\n  return isArrowRight(key) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(key) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(key, ctrlKey, metaKey) {\n  return isArrowUp(key) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(key, ctrlKey, metaKey) {\n  return isArrowDown(key) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(key) {\n  return key === ' ';\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\nfunction isReturn(key) {\n  return key === 'Enter';\n}\nfunction isBackspace(key) {\n  return key === 'Backspace';\n}\nfunction isEscape(key) {\n  return key === 'Escape';\n}\nfunction isDelete(key) {\n  return key === 'Delete';\n}\nfunction isSelectAll(key, metaKey, ctrlKey) {\n  return key.toLowerCase() === 'a' && controlOrMeta(metaKey, ctrlKey);\n}\nfunction $selectAll(selection) {\n  const root = $getRoot();\n  if ($isRangeSelection(selection)) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const topParent = anchorNode.getTopLevelElementOrThrow();\n    const rootNode = topParent.getParentOrThrow();\n    anchor.set(rootNode.getKey(), 0, 'element');\n    focus.set(rootNode.getKey(), rootNode.getChildrenSize(), 'element');\n    $normalizeSelection(selection);\n    return selection;\n  } else {\n    // Create a new RangeSelection\n    const newSelection = root.select(0, root.getChildrenSize());\n    $setSelection($normalizeSelection(newSelection));\n    return newSelection;\n  }\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = normalizeClassNames(classNames);\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\n/**\n * @deprecated Use {@link LexicalEditor.registerMutationListener} with `skipInitialization: false` instead.\n */\nfunction $nodesOfType(klass) {\n  const klassType = klass.getType();\n  const editorState = getActiveEditorState();\n  if (editorState._readOnly) {\n    const nodes = getCachedTypeToNodeMap(editorState).get(klassType);\n    return nodes ? Array.from(nodes.values()) : [];\n  }\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && node.isAttached()) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return isDocumentFragment(parentElement) ? parentElement.host : parentElement;\n}\nfunction getDOMOwnerDocument(target) {\n  return isDOMDocumentNode(target) ? target : isHTMLElement(target) ? target.ownerDocument : null;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = getDOMOwnerDocument(rootElement);\n  const defaultView = getDefaultView(doc);\n  if (doc === null || defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\n\n/**\n * Add a function to run after the current update. This will run after any\n * `onUpdate` function already supplied to `editor.update()`, as well as any\n * functions added with previous calls to `$onUpdate`.\n *\n * @param updateFn The function to run after the current update.\n */\nfunction $onUpdate(updateFn) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._deferred.push(updateFn);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = getDOMOwnerDocument(domElem);\n  return ownerDoc ? ownerDoc.defaultView : null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\n\n/**\n * Returns a shallow clone of node with a new key\n *\n * @param node - The node to be copied.\n * @returns The copy of the node.\n */\nfunction $copyNode(node) {\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n  const registeredNode = editor._nodes.get(nodeType);\n  if (!(registeredNode !== undefined)) {\n    throw Error(`$applyNodeReplacement node ${node.constructor.name} with type ${nodeType} must be registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n  }\n  const {\n    replace,\n    replaceWithKlass\n  } = registeredNode;\n  if (replace !== null) {\n    const replacementNode = replace(node);\n    const replacementNodeKlass = replacementNode.constructor;\n    if (replaceWithKlass !== null) {\n      if (!(replacementNode instanceof replaceWithKlass)) {\n        throw Error(`$applyNodeReplacement failed. Expected replacement node to be an instance of ${replaceWithKlass.name} with type ${replaceWithKlass.getType()} but returned ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} from original node ${node.constructor.name} with type ${nodeType}`);\n      }\n    } else {\n      if (!(replacementNode instanceof node.constructor && replacementNodeKlass !== node.constructor)) {\n        throw Error(`$applyNodeReplacement failed. Ensure replacement node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} is a subclass of the original node ${node.constructor.name} with type ${nodeType}.`);\n      }\n    }\n    if (!(replacementNode.__key !== node.__key)) {\n      throw Error(`$applyNodeReplacement failed. Ensure that the key argument is *not* used in your replace function (from node ${node.constructor.name} with type ${nodeType} to node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()}), Node keys must never be re-used except by the static clone method.`);\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction $getNodeByKeyOrThrow(key) {\n  const node = $getNodeByKey(key);\n  if (node === null) {\n    {\n      throw Error(`Expected node with key ${key} to exist but it's not in the nodeMap.`);\n    }\n  }\n  return node;\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = normalizeClassNames(blockCursorTheme);\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (child !== null && needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\n\n/**\n * Returns the selection for the given window, or the global window if null.\n * Will return null if {@link CAN_USE_DOM} is false.\n *\n * @param targetWindow The window to get the selection from\n * @returns a Selection or null\n */\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\n\n/**\n * Returns the selection for the defaultView of the ownerDocument of given EventTarget.\n *\n * @param eventTarget The node to get the selection from\n * @returns a Selection or null\n */\nfunction getDOMSelectionFromTarget(eventTarget) {\n  const defaultView = getDefaultView(eventTarget);\n  return defaultView ? defaultView.getSelection() : null;\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {\n        throw Error(`Children of a root must be ElementNode`);\n      }\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML element, false otherwise.\n */\nfunction isHTMLElement(x) {\n  return isDOMNode(x) && x.nodeType === DOM_ELEMENT_TYPE;\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is a DOM Node, false otherwise.\n */\nfunction isDOMNode(x) {\n  return typeof x === 'object' && x !== null && 'nodeType' in x && typeof x.nodeType === 'number';\n}\n\n/**\n * @param x - The element being testing\n * @returns Returns true if x is a document fragment, false otherwise.\n */\nfunction isDocumentFragment(x) {\n  return isDOMNode(x) && x.nodeType === DOM_DOCUMENT_FRAGMENT_TYPE;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is an inline node\n */\nfunction isInlineDomNode(node) {\n  const inlineNodes = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, 'i');\n  return node.nodeName.match(inlineNodes) !== null;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is a block node\n */\nfunction isBlockDomNode(node) {\n  const blockNodes = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, 'i');\n  return node.nodeName.match(blockNodes) !== null;\n}\n\n/**\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isDecoratorNode(node) && !node.isInline()) {\n    return true;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Utility function for accessing current active editor instance.\n * @returns Current active editor\n */\nfunction $getEditor() {\n  return getActiveEditor();\n}\n\n/** @internal */\n\n/**\n * @internal\n * Compute a cached Map of node type to nodes for a frozen EditorState\n */\nconst cachedNodeMaps = new WeakMap();\nconst EMPTY_TYPE_TO_NODE_MAP = new Map();\nfunction getCachedTypeToNodeMap(editorState) {\n  // If this is a new Editor it may have a writable this._editorState\n  // with only a 'root' entry.\n  if (!editorState._readOnly && editorState.isEmpty()) {\n    return EMPTY_TYPE_TO_NODE_MAP;\n  }\n  if (!editorState._readOnly) {\n    throw Error(`getCachedTypeToNodeMap called with a writable EditorState`);\n  }\n  let typeToNodeMap = cachedNodeMaps.get(editorState);\n  if (!typeToNodeMap) {\n    typeToNodeMap = computeTypeToNodeMap(editorState);\n    cachedNodeMaps.set(editorState, typeToNodeMap);\n  }\n  return typeToNodeMap;\n}\n\n/**\n * @internal\n * Compute a Map of node type to nodes for an EditorState\n */\nfunction computeTypeToNodeMap(editorState) {\n  const typeToNodeMap = new Map();\n  for (const [nodeKey, node] of editorState._nodeMap) {\n    const nodeType = node.__type;\n    let nodeMap = typeToNodeMap.get(nodeType);\n    if (!nodeMap) {\n      nodeMap = new Map();\n      typeToNodeMap.set(nodeType, nodeMap);\n    }\n    nodeMap.set(nodeKey, node);\n  }\n  return typeToNodeMap;\n}\n\n/**\n * Returns a clone of a node using `node.constructor.clone()` followed by\n * `clone.afterCloneFrom(node)`. The resulting clone must have the same key,\n * parent/next/prev pointers, and other properties that are not set by\n * `node.constructor.clone` (format, style, etc.). This is primarily used by\n * {@link LexicalNode.getWritable} to create a writable version of an\n * existing node. The clone is the same logical node as the original node,\n * do not try and use this function to duplicate or copy an existing node.\n *\n * Does not mutate the EditorState.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\nfunction $cloneWithProperties(latestNode) {\n  const constructor = latestNode.constructor;\n  const mutableNode = constructor.clone(latestNode);\n  mutableNode.afterCloneFrom(latestNode);\n  {\n    if (!(mutableNode.__key === latestNode.__key)) {\n      throw Error(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') did not return a node with the same key, make sure to specify node.__key as the last argument to the constructor`);\n    }\n    if (!(mutableNode.__parent === latestNode.__parent && mutableNode.__next === latestNode.__next && mutableNode.__prev === latestNode.__prev)) {\n      throw Error(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') overrided afterCloneFrom but did not call super.afterCloneFrom(prevNode)`);\n    }\n  }\n  return mutableNode;\n}\nfunction setNodeIndentFromDOM(elementDom, elementNode) {\n  const indentSize = parseInt(elementDom.style.paddingInlineStart, 10) || 0;\n  const indent = indentSize / 40;\n  elementNode.setIndent(indent);\n}\n\n/**\n * @internal\n *\n * Mark this node as unmanaged by lexical's mutation observer like\n * decorator nodes\n */\nfunction setDOMUnmanaged(elementDom) {\n  const el = elementDom;\n  el.__lexicalUnmanaged = true;\n}\n\n/**\n * @internal\n *\n * True if this DOM node was marked with {@link setDOMUnmanaged}\n */\nfunction isDOMUnmanaged(elementDom) {\n  const el = elementDom;\n  return el.__lexicalUnmanaged === true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key;\n    // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMapDelete.push(childKey);\n    }\n    child = child.getNextSibling();\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n  const nodeMapDelete = [];\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        }\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet subTreeTextFormat = null;\nlet subTreeTextStyle = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '40px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction $createNode(key, slot) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      $createChildrenWithDirection(children, endIndex, node, dom);\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (slot !== null) {\n    slot.insertChild(dom);\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction $createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  $createChildren(children, element, 0, endIndex, element.getDOMSlot(dom));\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\nfunction $createChildren(children, element, _startIndex, endIndex, slot) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    $createNode(children[startIndex], slot);\n    const node = activeNextNodeMap.get(children[startIndex]);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  const dom = slot.element;\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(element, nodeMap) {\n  if (element) {\n    const lastKey = element.__last;\n    if (lastKey) {\n      const node = nodeMap.get(lastKey);\n      if (node) {\n        return $isLineBreakNode(node) ? 'line-break' : $isDecoratorNode(node) && node.isInline() ? 'decorator' : null;\n      }\n    }\n    return 'empty';\n  }\n  return null;\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = isLastChildLineBreakOrDecorator(prevElement, activePrevNodeMap);\n  const nextLineBreak = isLastChildLineBreakOrDecorator(nextElement, activeNextNodeMap);\n  if (prevLineBreak !== nextLineBreak) {\n    nextElement.getDOMSlot(dom).setManagedLineBreak(nextLineBreak);\n  }\n}\nfunction reconcileTextFormat(element) {\n  if (subTreeTextFormat != null && subTreeTextFormat !== element.__textFormat && !activeEditorStateReadOnly) {\n    element.setTextFormat(subTreeTextFormat);\n    element.setTextStyle(subTreeTextStyle);\n  }\n}\nfunction reconcileTextStyle(element) {\n  if (subTreeTextStyle !== '' && subTreeTextStyle !== element.__textStyle && !activeEditorStateReadOnly) {\n    element.setTextStyle(subTreeTextStyle);\n  }\n}\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent || '';\n  const previousDirection = dom.__lexicalDir || '';\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined;\n\n      // Remove the old theme classes if they exist\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = normalizeClassNames(previousDirectionTheme);\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        }\n\n        // @ts-ignore: intentional\n        classList.remove(...previousDirectionTheme);\n      }\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = normalizeClassNames(nextDirectionTheme);\n            // @ts-expect-error: intentional\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        }\n\n        // Update direction\n        dom.dir = direction;\n      }\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n    activeTextDirection = direction;\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;\n    dom.__lexicalDir = direction;\n  }\n}\nfunction $reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  subTreeTextFormat = null;\n  subTreeTextStyle = '';\n  $reconcileChildren(prevElement, nextElement, nextElement.getDOMSlot(dom));\n  reconcileBlockDirection(nextElement, dom);\n  reconcileTextFormat(nextElement);\n  reconcileTextStyle(nextElement);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction $reconcileChildren(prevElement, nextElement, slot) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  const dom = slot.element;\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFirstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFirstChildKey) {\n      $reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = $createNode(nextFirstChildKey, null);\n      try {\n        dom.replaceChild(replacementDOM, lastDOM);\n      } catch (error) {\n        if (typeof error === 'object' && error != null) {\n          const msg = `${error.toString()} Parent: ${dom.tagName}, new child: {tag: ${replacementDOM.tagName} key: ${nextFirstChildKey}}, old child: {tag: ${lastDOM.tagName}, key: ${prevFirstChildKey}}.`;\n          throw new Error(msg);\n        } else {\n          throw error;\n        }\n      }\n      destroyNode(prevFirstChildKey, null);\n    }\n    const nextChildNode = activeNextNodeMap.get(nextFirstChildKey);\n    if ($isTextNode(nextChildNode)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = nextChildNode.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = nextChildNode.getStyle();\n      }\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (!(prevChildren.length === prevChildrenSize)) {\n      throw Error(`$reconcileChildren: prevChildren.length !== prevChildrenSize`);\n    }\n    if (!(nextChildren.length === nextChildrenSize)) {\n      throw Error(`$reconcileChildren: nextChildren.length !== nextChildrenSize`);\n    }\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        $createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, slot);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        const canUseFastPath = slot.after == null && slot.before == null && slot.element.__lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, slot);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction $reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = $createNode(key, null);\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      $reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    const nextRootNode = nextNode.getWritable();\n    nextRootNode.__cachedText = editorTextContent;\n    nextNode = nextRootNode;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, slot) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = slot.getFirstChild();\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, slot.element);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        $createNode(nextKey, slot.withBefore(siblingDOM));\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));\n        } else {\n          slot.withBefore(siblingDOM).insertChild(childDOM);\n          $reconcileNode(nextKey, slot.element);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n    const node = activeNextNodeMap.get(nextKey);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    $createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, slot.withBefore(insertDOM));\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, slot.element);\n  }\n}\nfunction $reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  $reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor$1 = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap;\n  setNodeKeyOnDOMNode(dom, editor, key);\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = null;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nconst rootElementsRegistered = new WeakMap();\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\n\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return isDOMTextNode(domNode) && domNode.nodeValue !== null && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    const selection = $getSelection();\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range – then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        const root = $getRoot();\n        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === '';\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Point.getNode() must return TextNode when type is text`);\n            }\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element' && !isRootTextContentEmpty) {\n            if (!$isElementNode(anchorNode)) {\n              throw Error(`Point.getNode() must return ElementNode when type is element`);\n            }\n            const lastNode = anchor.getNode();\n            selection.style = '';\n            if (\n            // This previously applied to all ParagraphNode\n            lastNode.isEmpty()) {\n              selection.format = lastNode.getTextFormat();\n              selection.style = lastNode.getTextStyle();\n            } else {\n              selection.format = 0;\n            }\n          }\n        }\n      } else {\n        const anchorKey = anchor.key;\n        const focus = selection.focus;\n        const focusKey = focus.key;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        const isBackward = selection.isBackward();\n        const startOffset = isBackward ? focusOffset : anchorOffset;\n        const endOffset = isBackward ? anchorOffset : focusOffset;\n        const startKey = isBackward ? focusKey : anchorKey;\n        const endKey = isBackward ? anchorKey : focusKey;\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          const textContentSize = node.getTextContentSize();\n          if ($isTextNode(node) && textContentSize !== 0 &&\n          // Exclude empty text nodes at boundaries resulting from user's selection\n          !(i === 0 && node.__key === startKey && startOffset === textContentSize || i === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Triple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n          if (anchorNode !== focusNode) {\n            if ($isElementNode(anchorNode)) {\n              anchorNode.select(0);\n            } else {\n              anchorNode.getParentOrThrow().select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n        // If the user is attempting to click selection back onto text, then\n        // we should attempt create a range selection.\n        // When we click on an empty paragraph node or the end of a paragraph that ends\n        // with an image/poll, the nodeType will be ELEMENT_NODE\n        if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {\n          const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, editor, event);\n          $setSelection(newSelection);\n        }\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (isDOMNode(target) && pointerType !== 'touch' && event.button === 0) {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n  const targetRanges = event.getTargetRanges();\n  if (targetRanges.length === 0) {\n    return null;\n  }\n  return targetRanges[0];\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 'MediaLast' && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event);\n\n  // We let the browser do its own thing for composition.\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            if (!$isTextNode(anchorNode)) {\n              throw Error(`Anchor node must be a TextNode`);\n            }\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          $setCompositionKey(null);\n          event.preventDefault();\n          // Chromium Android at the moment seems to ignore the preventDefault\n          // on 'deleteContentBackward' and still deletes the content. Which leads\n          // to multiple deletions. So we let the browser handle the deletion in this case.\n          const selectedNode = selection.anchor.getNode();\n          const selectedNodeText = selectedNode.getTextContent();\n          // When the target node has `canInsertTextAfter` set to false, the first deletion\n          // doesn't have an effect, so we need to handle it with Lexical.\n          const selectedNodeCanInsertTextAfter = selectedNode.canInsertTextAfter();\n          const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;\n          const shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode && selectedNodeCanInsertTextAfter;\n          if (!shouldLetBrowserHandleDelete) {\n            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n          }\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n\n          // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n      // NO-OP\n    }\n  });\n}\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n      if (domSelection === null) {\n        return;\n      }\n      const isBackward = selection.isBackward();\n      const startOffset = isBackward ? selection.anchor.offset : selection.focus.offset;\n      const endOffset = isBackward ? selection.focus.offset : selection.anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, startOffset) + data + anchorNode.getTextContent().slice(startOffset + endOffset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction $onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      $onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.key;\n  if (editor.isComposing()) {\n    return;\n  }\n  const {\n    key,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (key == null) {\n    return;\n  }\n  if (isMoveForward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(key, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(key, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(key, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(key)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(key, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(key, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(key, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(key)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(key)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(key, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(key)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(key, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(key, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(key, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(key, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(key, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if (prevSelection !== null && !$isRangeSelection(prevSelection)) {\n      // Only RangeSelection can use the native cut/copy/select all\n      if (isCopy(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(key, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(key, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      }\n      // FF does it well (no need to override behavior)\n    } else if (!IS_FIREFOX && isSelectAll(key, metaKey, ctrlKey)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const domSelection = getDOMSelectionFromTarget(event.target);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {\n        // If the user is attempting to click selection back onto text, then\n        // we should attempt create a range selection.\n        // When we click on an empty paragraph node or the end of a paragraph that ends\n        // with an image/poll, the nodeType will be ELEMENT_NODE\n        const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);\n        $setSelection(newSelection);\n      }\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (documentRootElementsCount === undefined || documentRootElementsCount < 1) {\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered.set(doc, (documentRootElementsCount || 0) + 1);\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable() || eventName === 'click') {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      const isEditable = editor.isEditable();\n      switch (eventName) {\n        case 'cut':\n          return isEditable && dispatchCommand(editor, CUT_COMMAND, event);\n        case 'copy':\n          return dispatchCommand(editor, COPY_COMMAND, event);\n        case 'paste':\n          return isEditable && dispatchCommand(editor, PASTE_COMMAND, event);\n        case 'dragstart':\n          return isEditable && dispatchCommand(editor, DRAGSTART_COMMAND, event);\n        case 'dragover':\n          return isEditable && dispatchCommand(editor, DRAGOVER_COMMAND, event);\n        case 'dragend':\n          return isEditable && dispatchCommand(editor, DRAGEND_COMMAND, event);\n        case 'focus':\n          return isEditable && dispatchCommand(editor, FOCUS_COMMAND, event);\n        case 'blur':\n          {\n            return isEditable && dispatchCommand(editor, BLUR_COMMAND, event);\n          }\n        case 'drop':\n          return isEditable && dispatchCommand(editor, DROP_COMMAND, event);\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (!(documentRootElementsCount !== undefined)) {\n    throw Error(`Root element not registered`);\n  } // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const newCount = documentRootElementsCount - 1;\n  if (!(newCount >= 0)) {\n    throw Error(`Root element count less than 0`);\n  }\n  rootElementsRegistered.set(doc, newCount);\n  if (newCount === 0) {\n    doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  const editor = getEditorPropertyFromDOMNode(rootElement);\n  if (isLexicalEditor(editor)) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  } else if (editor) {\n    {\n      throw Error(`Attempted to remove event handlers from a node that does not belong to this build of Lexical`);\n    }\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * The base type for all serialized nodes\n */\n\n/**\n * Omit the children, type, and version properties from the given SerializedLexicalNode definition.\n */\n\n/** @internal */\n\nfunction $removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    $removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // Allow us to look up the type including static props\n\n  /** @internal */\n\n  /** @internal */\n  //@ts-ignore We set the key in the constructor.\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  /**\n   * Perform any state updates on the clone of prevNode that are not already\n   * handled by the constructor call in the static clone method. If you have\n   * state to update in your clone that is not handled directly by the\n   * constructor, it is advisable to override this method but it is required\n   * to include a call to `super.afterCloneFrom(prevNode)` in your\n   * implementation. This is only intended to be called by\n   * {@link $cloneWithProperties} function or via a super call.\n   *\n   * @example\n   * ```ts\n   * class ClassesTextNode extends TextNode {\n   *   // Not shown: static getType, static importJSON, exportJSON, createDOM, updateDOM\n   *   __classes = new Set<string>();\n   *   static clone(node: ClassesTextNode): ClassesTextNode {\n   *     // The inherited TextNode constructor is used here, so\n   *     // classes is not set by this method.\n   *     return new ClassesTextNode(node.__text, node.__key);\n   *   }\n   *   afterCloneFrom(node: this): void {\n   *     // This calls TextNode.afterCloneFrom and LexicalNode.afterCloneFrom\n   *     // for necessary state updates\n   *     super.afterCloneFrom(node);\n   *     this.__addClasses(node.__classes);\n   *   }\n   *   // This method is a private implementation detail, it is not\n   *   // suitable for the public API because it does not call getWritable\n   *   __addClasses(classNames: Iterable<string>): this {\n   *     for (const className of classNames) {\n   *       this.__classes.add(className);\n   *     }\n   *     return this;\n   *   }\n   *   addClass(...classNames: string[]): this {\n   *     return this.getWritable().__addClasses(classNames);\n   *   }\n   *   removeClass(...classNames: string[]): this {\n   *     const node = this.getWritable();\n   *     for (const className of classNames) {\n   *       this.__classes.delete(className);\n   *     }\n   *     return this;\n   *   }\n   *   getClasses(): Set<string> {\n   *     return this.getLatest().__classes;\n   *   }\n   * }\n   * ```\n   *\n   */\n  afterCloneFrom(prevNode) {\n    this.__parent = prevNode.__parent;\n    this.__next = prevNode.__next;\n    this.__prev = prevNode.__prev;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  constructor(key) {\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n  getType() {\n    return this.__type;\n  }\n  isInline() {\n    {\n      throw Error(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);\n    }\n  }\n\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    const isElementRangeSelection = $isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element';\n    if (isElementRangeSelection) {\n      if (targetSelection.isCollapsed()) {\n        return false;\n      }\n      const parentNode = this.getParent();\n      if ($isDecoratorNode(this) && this.isInline() && parentNode) {\n        const firstPoint = targetSelection.isBackward() ? targetSelection.focus : targetSelection.anchor;\n        const firstElement = firstPoint.getNode();\n        if (firstPoint.offset === firstElement.getChildrenSize() && firstElement.is(parentNode) && firstElement.getLastChildOrThrow().is(this)) {\n          return false;\n        }\n      }\n    }\n    return isSelected;\n  }\n\n  /**\n   * Returns this nodes key.\n   */\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        if (!($isElementNode(node) || node === this && $isDecoratorNode(node))) {\n          throw Error(`Children of root nodes must be elements or decorators`);\n        }\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n    const aLength = a.length;\n    const bLength = b.length;\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n    const bSet = new Set(b);\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n  isBefore(targetNode) {\n    if (this === targetNode) {\n      return false;\n    }\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    node = targetNode;\n    while (true) {\n      const parent = node.getParentOrThrow();\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n      node = parent;\n    }\n    return indexA < indexB;\n  }\n\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n  isParentOf(targetNode) {\n    const key = this.__key;\n    if (key === targetNode.__key) {\n      return false;\n    }\n    let node = targetNode;\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n      node = node.getParent();\n    }\n    return false;\n  }\n\n  // TO-DO: this function can be simplified a lot\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      if (node === null) {\n        break;\n      }\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        } else {\n          break;\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n\n  /**\n   * Returns a mutable version of the node using {@link $cloneWithProperties}\n   * if necessary. Will throw an error if called outside of a Lexical Editor\n   * {@link LexicalEditor.update} callback.\n   *\n   */\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection.setCachedNodes(null);\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const mutableNode = $cloneWithProperties(latestNode);\n    cloneNotNeeded.add(key);\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n  getTextContent() {\n    return '';\n  }\n\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n  getTextContentSize() {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  exportJSON() {\n    return {\n      type: this.__type,\n      version: 1\n    };\n  }\n\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n\n  /**\n   * Update this LexicalNode instance from serialized JSON. It's recommended\n   * to implement as much logic as possible in this method instead of the\n   * static importJSON method, so that the functionality can be inherited in subclasses.\n   *\n   * The LexicalUpdateJSON utility type should be used to ignore any type, version,\n   * or children properties in the JSON so that the extended JSON from subclasses\n   * are acceptable parameters for the super call.\n   *\n   * If overridden, this method must call super.\n   *\n   * @example\n   * ```ts\n   * class MyTextNode extends TextNode {\n   *   // ...\n   *   static importJSON(serializedNode: SerializedMyTextNode): MyTextNode {\n   *     return $createMyTextNode()\n   *       .updateFromJSON(serializedNode);\n   *   }\n   *   updateFromJSON(\n   *     serializedNode: LexicalUpdateJSON<SerializedMyTextNode>,\n   *   ): this {\n   *     return super.updateFromJSON(serializedNode)\n   *       .setMyProperty(serializedNode.myProperty);\n   *   }\n   * }\n   * ```\n   **/\n  updateFromJSON(serializedNode) {\n    return this;\n  }\n\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n  static transform() {\n    return null;\n  }\n\n  // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n  remove(preserveEmptyParent) {\n    $removeNode(this, true, preserveEmptyParent);\n  }\n\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) {\n      selection = selection.clone();\n    }\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    $removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert before this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n  isParentRequired() {\n    return false;\n  }\n\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  selectStart() {\n    return this.selectPrevious();\n  }\n  selectEnd() {\n    return this.selectNext(0, 0);\n  }\n\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n  markDirty() {\n    this.getWritable();\n  }\n\n  /**\n   * @internal\n   *\n   * When the reconciler detects that a node was mutated, this method\n   * may be called to restore the node to a known good state.\n   */\n  reconcileObservedMutation(dom, editor) {\n    this.markDirty();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Insert a series of nodes after this LexicalNode (as next siblings)\n *\n * @param firstToInsert - The first node to insert after this one.\n * @param lastToInsert - The last node to insert after this one. Must be a\n * later sibling of FirstNode. If not provided, it will be its last sibling.\n */\nfunction insertRangeAfter(node, firstToInsert, lastToInsert) {\n  const lastToInsert2 = firstToInsert.getParentOrThrow().getLastChild();\n  let current = firstToInsert;\n  const nodesToInsert = [firstToInsert];\n  while (current !== lastToInsert2) {\n    if (!current.getNextSibling()) {\n      {\n        throw Error(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);\n      }\n    }\n    current = current.getNextSibling();\n    nodesToInsert.push(current);\n  }\n  let currentNode = node;\n  for (const nodeToInsert of nodesToInsert) {\n    currentNode = currentNode.insertAfter(nodeToInsert);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        if (isOnlyChildInBlockNode(node) || isLastChildInBlockNode(node)) {\n          return null;\n        }\n        return {\n          conversion: $convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode().updateFromJSON(serializedLineBreakNode);\n  }\n}\nfunction $convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\nfunction isOnlyChildInBlockNode(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      const lastChild = parentElement.lastChild;\n      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isLastChildInBlockNode(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    // check if node is first child, because only childs dont count\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      return false;\n    }\n\n    // check if its last child\n    const lastChild = parentElement.lastChild;\n    if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isWhitespaceDomTextNode(node) {\n  return isDOMTextNode(node) && /^( |\\t|\\r?\\n)+$/.test(node.textContent || '');\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__text = prevNode.__text;\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__mode = prevNode.__mode;\n    this.__detail = prevNode.__detail;\n  }\n  constructor(text = '', key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  /**\n   *\n   * @returns true if the text node supports font styling, false otherwise.\n   */\n  canHaveFormat() {\n    return true;\n  }\n\n  // View\n\n  createDOM(config, editor) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: $convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTextNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setTextContent(serializedNode.text).setFormat(serializedNode.format).setDetail(serializedNode.detail).setMode(serializedNode.mode).setStyle(serializedNode.style);\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n    if (!isHTMLElement(element)) {\n      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);\n    }\n    element.style.whiteSpace = 'pre-wrap';\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'i');\n    }\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      // As an exception here we invoke super at the end for historical reasons.\n      // Namely, to preserve the order of the properties and not to break the tests\n      // that use the serialized string representation.\n      ...super.exportJSON()\n    };\n  }\n\n  // Mutators\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.toggleUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.\n   * The subscript and superscript formats are mutually exclusive.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n  toggleFormat(type) {\n    const format = this.getFormat();\n    const newFormat = toggleTextFormatType(format, type, null);\n    return this.setFormat(newFormat);\n  }\n\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  selectStart() {\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const size = this.getTextContentSize();\n    return this.select(size, size);\n  }\n\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n  canInsertTextBefore() {\n    return true;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n  canInsertTextAfter() {\n    return true;\n  }\n\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n      string += textContent[i];\n    }\n    if (string !== '') {\n      parts.push(string);\n    }\n    const partsLength = parts.length;\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParent();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    }\n\n    // Handle selection\n    const selection = $getSelection();\n\n    // Then handle all other parts\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    }\n\n    // Insert the nodes into the parent's children\n    if (parent !== null) {\n      internalMarkSiblingsAsDirty(this);\n      const writableParent = parent.getWritable();\n      const insertionIndex = this.getIndexWithinParent();\n      if (hasReplacedSelf) {\n        writableParent.splice(insertionIndex, 0, splitNodes);\n        this.remove();\n      } else {\n        writableParent.splice(insertionIndex, 1, splitNodes);\n      }\n      if ($isRangeSelection(selection)) {\n        $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n      }\n    }\n    return splitNodes;\n  }\n\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  const style = span.style;\n  return {\n    forChild: applyTextFormatFromStyle(style),\n    node: null\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: applyTextFormatFromStyle(b.style, hasNormalFontWeight ? undefined : 'bold'),\n    node: null\n  };\n}\nconst preParentCache = new WeakMap();\nfunction isNodePre(node) {\n  if (!isHTMLElement(node)) {\n    return false;\n  } else if (node.nodeName === 'PRE') {\n    return true;\n  }\n  const whiteSpace = node.style.whiteSpace;\n  return typeof whiteSpace === 'string' && whiteSpace.startsWith('pre');\n}\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n  const resultNode = cached === undefined ? parent : cached;\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n  return resultNode;\n}\nfunction $convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n  if (!(parentDom !== null)) {\n    throw Error(`Expected parentElement of Text not to be null`);\n  }\n  let textContent = domNode_.textContent || '';\n  // No collapse and preserve segment break for pre, pre-wrap and pre-line\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n    return {\n      node: nodes\n    };\n  }\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n        isStartOfLine = false;\n        break;\n      }\n    }\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nfunction findTextInLine(text, forward) {\n  let node = text;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let sibling;\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n      if (parentElement === null) {\n        return null;\n      }\n      node = parentElement;\n    }\n    node = sibling;\n    if (isHTMLElement(node)) {\n      const display = node.style.display;\n      if (display === '' && !isInlineDomNode(node) || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n    let descendant = node;\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n    if (isDOMTextNode(node)) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: applyTextFormatFromStyle(domNode.style, format),\n    node: null\n  };\n}\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\nfunction applyTextFormatFromStyle(style, shouldApply) {\n  const fontWeight = style.fontWeight;\n  const textDecoration = style.textDecoration.split(' ');\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = fontWeight === '700' || fontWeight === 'bold';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = style.verticalAlign;\n  return lexicalNode => {\n    if (!$isTextNode(lexicalNode)) {\n      return lexicalNode;\n    }\n    if (hasBoldFontWeight && !lexicalNode.hasFormat('bold')) {\n      lexicalNode.toggleFormat('bold');\n    }\n    if (hasLinethroughTextDecoration && !lexicalNode.hasFormat('strikethrough')) {\n      lexicalNode.toggleFormat('strikethrough');\n    }\n    if (hasItalicFontStyle && !lexicalNode.hasFormat('italic')) {\n      lexicalNode.toggleFormat('italic');\n    }\n    if (hasUnderlineTextDecoration && !lexicalNode.hasFormat('underline')) {\n      lexicalNode.toggleFormat('underline');\n    }\n    if (verticalAlign === 'sub' && !lexicalNode.hasFormat('subscript')) {\n      lexicalNode.toggleFormat('subscript');\n    }\n    if (verticalAlign === 'super' && !lexicalNode.hasFormat('superscript')) {\n      lexicalNode.toggleFormat('superscript');\n    }\n    if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {\n      lexicalNode.toggleFormat(shouldApply);\n    }\n    return lexicalNode;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n  static clone(node) {\n    return new TabNode(node.__key);\n  }\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n  static importDOM() {\n    return null;\n  }\n  createDOM(config) {\n    const dom = super.createDOM(config);\n    const classNames = getCachedClassNameArray(config.theme, 'tab');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  static importJSON(serializedTabNode) {\n    return $createTabNode().updateFromJSON(serializedTabNode);\n  }\n  setTextContent(text) {\n    if (!(text === '\\t' || text === '')) {\n      throw Error(`TabNode does not support setTextContent`);\n    }\n    return super.setTextContent(text);\n  }\n  setDetail(detail) {\n    if (!(detail === IS_UNMERGEABLE)) {\n      throw Error(`TabNode does not support setDetail`);\n    }\n    return this;\n  }\n  setMode(type) {\n    if (!(type === 'normal')) {\n      throw Error(`TabNode does not support setMode`);\n    }\n    return this;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nclass Point {\n  constructor(key, offset, type) {\n    {\n      // This prevents a circular reference error when serialized as JSON,\n      // which happens on unit test failures\n      Object.defineProperty(this, '_selection', {\n        enumerable: false,\n        writable: true\n      });\n    }\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n    return aNode.isBefore(bNode);\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection.setCachedNodes(null);\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\nclass NodeSelection {\n  constructor(objects) {\n    this._cachedNodes = null;\n    this._nodes = objects;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return false;\n  }\n  getStartEndPoints() {\n    return null;\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.format = format;\n    this.style = style;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const overselectedFirstNode = $isElementNode(firstNode) && firstPoint.offset > 0 && firstPoint.offset >= firstNode.getChildrenSize();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset);\n      // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n    let nodes;\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n      // Prevent over-selection due to the edge case of getDescendantByIndex always returning something #6974\n      if (overselectedFirstNode) {\n        const deleteCount = nodes.findIndex(node => !node.is(firstNode) && !node.isBefore(firstNode));\n        nodes.splice(0, deleteCount);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = $internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n    this.insertNodes(nodes);\n  }\n\n  /**\n   * Insert the provided text into the EditorState at the current Selection.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertText(text) {\n    // Now that \"removeText\" has been improved and does not depend on\n    // insertText, insertText can be greatly simplified. The next\n    // commented version is a WIP (about 5 tests fail).\n    //\n    // this.removeText();\n    // if (text === '') {\n    //   return;\n    // }\n    // const anchorNode = this.anchor.getNode();\n    // const textNode = $createTextNode(text);\n    // textNode.setFormat(this.format);\n    // textNode.setStyle(this.style);\n    // if ($isTextNode(anchorNode)) {\n    //   const parent = anchorNode.getParentOrThrow();\n    //   if (this.anchor.offset === 0) {\n    //     if (parent.isInline() && !anchorNode.__prev) {\n    //       parent.insertBefore(textNode);\n    //     } else {\n    //       anchorNode.insertBefore(textNode);\n    //     }\n    //   } else if (this.anchor.offset === anchorNode.getTextContentSize()) {\n    //     if (parent.isInline() && !anchorNode.__next) {\n    //       parent.insertAfter(textNode);\n    //     } else {\n    //       anchorNode.insertAfter(textNode);\n    //     }\n    //   } else {\n    //     const [before] = anchorNode.splitText(this.anchor.offset);\n    //     before.insertAfter(textNode);\n    //   }\n    // } else {\n    //   anchorNode.splice(this.anchor.offset, 0, [textNode]);\n    // }\n    // const nodeToSelect = textNode.isAttached() ? textNode : anchorNode;\n    // nodeToSelect.selectEnd();\n    // // When composing, we need to adjust the anchor offset so that\n    // // we correctly replace that right range.\n    // if (\n    //   textNode.isComposing() &&\n    //   this.anchor.type === 'text' &&\n    //   anchorNode.getTextContent() !== ''\n    // ) {\n    //   this.anchor.offset -= text.length;\n    // }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const format = this.format;\n    const style = this.style;\n    let firstPoint = anchor;\n    let endPoint = focus;\n    if (!this.isCollapsed() && focus.isBefore(anchor)) {\n      firstPoint = focus;\n      endPoint = anchor;\n    }\n    if (firstPoint.type === 'element') {\n      $transferStartingElementPointToTextPoint(firstPoint, endPoint, format, style);\n    }\n    const startOffset = firstPoint.offset;\n    let endOffset = endPoint.offset;\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (selectedNodesLength === 1 && endPoint.type === 'element') {\n      endOffset = firstNodeTextLength;\n      endPoint.set(firstPoint.key, endOffset, 'text');\n    }\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        nextSibling.setStyle(style);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      } else if ($isTabNode(firstNode)) {\n        // We don't need to check for delCount because there is only the entire selected node case\n        // that can hit here for content size 1 and with canInsertTextBeforeAfter false\n        const textNode = $createTextNode(text);\n        textNode.setFormat(format);\n        textNode.setStyle(style);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          // root node selections only select whole nodes, so no text splice is necessary\n          if (!$isRootNode(endPoint.getNode()) && endPoint.type === 'text') {\n            lastNode = lastNode.spliceText(0, endOffset, '');\n          }\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n  removeText() {\n    if (this.isCollapsed()) {\n      return;\n    }\n    const {\n      anchor,\n      focus\n    } = this;\n    const selectedNodes = this.getNodes();\n    const firstPoint = this.isBackward() ? focus : anchor;\n    const lastPoint = this.isBackward() ? anchor : focus;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const firstBlock = $getAncestor(firstNode, INTERNAL_$isBlock);\n    const lastBlock = $getAncestor(lastNode, INTERNAL_$isBlock);\n    // If a token is partially selected then move the selection to cover the whole selection\n    if ($isTextNode(firstNode) && firstNode.isToken() && firstPoint.offset < firstNode.getTextContentSize()) {\n      firstPoint.offset = 0;\n    }\n    if (lastPoint.offset > 0 && $isTextNode(lastNode) && lastNode.isToken()) {\n      lastPoint.offset = lastNode.getTextContentSize();\n    }\n    for (const node of selectedNodes) {\n      if (!$hasAncestor(firstNode, node) && !$hasAncestor(lastNode, node) && node.getKey() !== firstNode.getKey() && node.getKey() !== lastNode.getKey()) {\n        node.remove();\n      }\n    }\n    const fixText = (node, del) => {\n      if (node.getTextContent() === '') {\n        node.remove();\n      } else if (del !== 0 && $isTokenOrSegmented(node)) {\n        const textNode = $createTextNode(node.getTextContent());\n        textNode.setFormat(node.getFormat());\n        textNode.setStyle(node.getStyle());\n        return node.replace(textNode);\n      }\n    };\n    if (firstNode === lastNode && $isTextNode(firstNode)) {\n      const del = Math.abs(focus.offset - anchor.offset);\n      firstNode.spliceText(firstPoint.offset, del, '', true);\n      fixText(firstNode, del);\n      return;\n    }\n    if ($isTextNode(firstNode)) {\n      const del = firstNode.getTextContentSize() - firstPoint.offset;\n      firstNode.spliceText(firstPoint.offset, del, '');\n      firstNode = fixText(firstNode, del) || firstNode;\n    }\n    if ($isTextNode(lastNode)) {\n      lastNode.spliceText(0, lastPoint.offset, '');\n      lastNode = fixText(lastNode, lastPoint.offset) || lastNode;\n    }\n    if (firstNode.isAttached() && $isTextNode(firstNode)) {\n      firstNode.selectEnd();\n    } else if (lastNode.isAttached() && $isTextNode(lastNode)) {\n      lastNode.selectStart();\n    }\n\n    // Merge blocks\n    const bothElem = $isElementNode(firstBlock) && $isElementNode(lastBlock);\n    if (bothElem && firstBlock !== lastBlock) {\n      firstBlock.append(...lastBlock.getChildren());\n      lastBlock.remove();\n      lastPoint.set(firstPoint.key, firstPoint.offset, firstPoint.type);\n    }\n  }\n\n  // TO-DO: Migrate this method to the new utility function $forEachSelectedTextNode (share similar logic)\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   * @param alignWithFormat a 32-bit integer representing formatting flags to align with.\n   */\n  formatText(formatType, alignWithFormat = null) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const applyFormatToElements = alignWith => {\n      selectedNodes.forEach(node => {\n        if ($isElementNode(node)) {\n          const newFormat = node.getFormatFlags(formatType, alignWith);\n          node.setTextFormat(newFormat);\n        }\n      });\n    };\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      applyFormatToElements(alignWithFormat);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, alignWithFormat);\n    applyFormatToElements(firstNextFormat);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected or it is token, so just format it\n      if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize() && !$isTokenOrSegmented(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n      textNode.setFormat(nextFormat);\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accommodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   */\n  insertNodes(nodes) {\n    if (nodes.length === 0) {\n      return;\n    }\n    if (this.anchor.key === 'root') {\n      this.insertParagraph();\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        throw Error(`Expected RangeSelection after insertParagraph`);\n      }\n      return selection.insertNodes(nodes);\n    }\n    const firstPoint = this.isBackward() ? this.focus : this.anchor;\n    const firstNode = firstPoint.getNode();\n    const firstBlock = $getAncestor(firstNode, INTERNAL_$isBlock);\n    const last = nodes[nodes.length - 1];\n\n    // CASE 1: insert inside a code block\n    if ($isElementNode(firstBlock) && '__language' in firstBlock) {\n      if ('__language' in nodes[0]) {\n        this.insertText(nodes[0].getTextContent());\n      } else {\n        const index = $removeTextAndSplitBlock(this);\n        firstBlock.splice(index, 0, nodes);\n        last.selectEnd();\n      }\n      return;\n    }\n\n    // CASE 2: All elements of the array are inline\n    const notInline = node => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();\n    if (!nodes.some(notInline)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);\n      }\n      const index = $removeTextAndSplitBlock(this);\n      firstBlock.splice(index, 0, nodes);\n      last.selectEnd();\n      return;\n    }\n\n    // CASE 3: At least 1 element of the array is not inline\n    const blocksParent = $wrapInlineNodes(nodes);\n    const nodeToSelect = blocksParent.getLastDescendant();\n    const blocks = blocksParent.getChildren();\n    const isMergeable = node => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || firstBlock.canMergeWhenEmpty());\n    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();\n    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;\n    const lastToInsert = blocks[blocks.length - 1];\n    let firstToInsert = blocks[0];\n    if (isMergeable(firstToInsert)) {\n      if (!$isElementNode(firstBlock)) {\n        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);\n      }\n      firstBlock.append(...firstToInsert.getChildren());\n      firstToInsert = blocks[1];\n    }\n    if (firstToInsert) {\n      if (!(firstBlock !== null)) {\n        throw Error(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ancestor`);\n      }\n      insertRangeAfter(firstBlock, firstToInsert);\n    }\n    const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);\n    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (insertedParagraph.canMergeWhenEmpty() || INTERNAL_$isBlock(lastToInsert))) {\n      lastInsertedBlock.append(...insertedParagraph.getChildren());\n      insertedParagraph.remove();\n    }\n    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {\n      firstBlock.remove();\n    }\n    nodeToSelect.selectEnd();\n\n    // To understand this take a look at the test \"can wrap post-linebreak nodes into new element\"\n    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;\n    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {\n      lastChild.remove();\n    }\n  }\n\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   *\n   * @returns the newly inserted node.\n   */\n  insertParagraph() {\n    if (this.anchor.key === 'root') {\n      const paragraph = $createParagraphNode();\n      $getRoot().splice(this.anchor.offset, 0, [paragraph]);\n      paragraph.select();\n      return paragraph;\n    }\n    const index = $removeTextAndSplitBlock(this);\n    const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);\n    if (!$isElementNode(block)) {\n      throw Error(`Expected ancestor to be a block ElementNode`);\n    }\n    const firstToAppend = block.getChildAtIndex(index);\n    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];\n    const newBlock = block.insertNewAfter(this, false);\n    if (newBlock) {\n      newBlock.append(...nodesToInsert);\n      newBlock.selectStart();\n      return newBlock;\n    }\n    // if newBlock is null, it means that block is of type CodeNode.\n    return null;\n  }\n\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   */\n  insertLineBreak(selectStart) {\n    const lineBreak = $createLineBreakNode();\n    this.insertNodes([lineBreak]);\n    // this is used in MacOS with the command 'ctrl-O' (openLineBreak)\n    if (selectStart) {\n      const parent = lineBreak.getParentOrThrow();\n      const index = lineBreak.getIndexWithinParent();\n      parent.select(index, index);\n    }\n  }\n\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move';\n\n    // Handle the selection movement around decorators.\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n          if (!isBackward) {\n            offset++;\n          }\n        }\n        focus.set(elementKey, offset, 'element');\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n        return;\n      }\n    }\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Helper for handling forward character and word deletion that prevents element nodes\n   * like a table, columns layout being destroyed\n   *\n   * @param anchor the anchor\n   * @param anchorNode the anchor node in the selection\n   * @param isBackward whether or not selection is backwards\n   */\n  forwardDeletion(anchor, anchorNode, isBackward) {\n    if (!isBackward && (\n    // Delete forward handle case\n    anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n      const parent = anchorNode.getParent();\n      const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      let anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n\n      // Handle the deletion around decorators.\n      const focus = this.focus;\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n        return;\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      // Since `domSelection.modify('extend', ..., 'lineboundary')` works well for text selections\n      // but doesn't properly handle selections which end on elements, a space character is added\n      // for such selections transforming their anchor's type to 'text'\n      const anchorIsElement = this.anchor.type === 'element';\n      if (anchorIsElement) {\n        this.insertText(' ');\n      }\n      this.modify('extend', isBackward, 'lineboundary');\n\n      // If the selection starts at the beginning of a text node (offset 0),\n      // extend the selection by one character in the specified direction.\n      // This ensures that the parent element is deleted along with its content.\n      // Otherwise, only the text content will be deleted, leaving an empty parent node.\n      if (this.isCollapsed() && this.anchor.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n\n      // Adjusts selection to include an extra character added for element anchors to remove it\n      if (anchorIsElement) {\n        const startPoint = isBackward ? this.anchor : this.focus;\n        startPoint.set(startPoint.key, startPoint.offset + 1, startPoint.type);\n      }\n    }\n    this.removeText();\n  }\n\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction $getCharacterOffsets(selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return [0, 0];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction $internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (isHTMLElement(dom)) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    const blockCursorElement = editor._blockCursorElement;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (blockCursorElement !== null) {\n      const blockCursorElementParent = blockCursorElement.parentNode;\n      if (dom === blockCursorElementParent) {\n        const blockCursorOffset = Array.prototype.indexOf.call(blockCursorElementParent.children, blockCursorElement);\n        if (offset > blockCursorOffset) {\n          resolvedOffset--;\n        }\n      }\n    }\n    resolvedNode = $getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = $getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        const elementDOM = editor.getElementByKey(resolvedElement.getKey());\n        if (!(elementDOM !== null)) {\n          throw Error(`$internalResolveSelectionPoint: node in DOM but not keyToDOMMap`);\n        }\n        const slot = resolvedElement.getDOMSlot(elementDOM);\n        [resolvedElement, resolvedOffset] = slot.resolveChildIndex(resolvedElement, elementDOM, dom, offset);\n        // This is just a typescript workaround, it is true but lost due to mutability\n        if (!$isElementNode(resolvedElement)) {\n          throw Error(`$internalResolveSelectionPoint: resolvedElement is not an ElementNode`);\n        }\n        if (moveSelectionToEnd && resolvedOffset >= resolvedElement.getChildrenSize()) {\n          resolvedOffset = Math.max(0, resolvedElement.getChildrenSize() - 1);\n        }\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n          resolvedOffset = 0;\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          if (!$isElementNode(resolvedElement)) {\n            throw Error(`invariant`);\n          }\n          resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset + 1);\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && $getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = $getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize();\n        // @ts-expect-error: intentional\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0;\n      // @ts-expect-error: intentional\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\nfunction $normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\nfunction $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = $internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  {\n    $validatePoint(editor, 'anchor', resolvedAnchorPoint);\n  }\n  const resolvedFocusPoint = $internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  {\n    $validatePoint(editor, 'focus', resolvedAnchorPoint);\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = $getNodeFromDOM(anchorDOM);\n    const focusNode = $getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  $normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction $internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction $internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n  if ($isRangeSelection(lastSelection) || lastSelection == null) {\n    return $internalCreateRangeSelection(lastSelection, domSelection, editor, null);\n  }\n  return lastSelection.clone();\n}\nfunction $createRangeSelectionFromDom(domSelection, editor) {\n  return $internalCreateRangeSelection(null, domSelection, editor, null);\n}\nfunction $internalCreateRangeSelection(lastSelection, domSelection, editor, event) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = event || windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $validatePoint(editor, name, point) {\n  const node = $getNodeByKey(point.key);\n  if (!(node !== undefined)) {\n    throw Error(`$validatePoint: ${name} key ${point.key} not found in current editorState`);\n  }\n  if (point.type === 'text') {\n    if (!$isTextNode(node)) {\n      throw Error(`$validatePoint: ${name} key ${point.key} is not a TextNode`);\n    }\n    const size = node.getTextContentSize();\n    if (!(point.offset <= size)) {\n      throw Error(`$validatePoint: ${name} point.offset > node.getTextContentSize() (${String(point.offset)} > ${String(size)})`);\n    }\n  } else {\n    if (!$isElementNode(node)) {\n      throw Error(`$validatePoint: ${name} key ${point.key} is not an ElementNode`);\n    }\n    const size = node.getChildrenSize();\n    if (!(point.offset <= size)) {\n      throw Error(`$validatePoint: ${name} point.offset > node.getChildrenSize() (${String(point.offset)} > ${String(size)})`);\n    }\n  }\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n    {\n      console.warn(error);\n    }\n  }\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = $isRangeSelection(nextSelection) && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      let selectionRect;\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes) {\n  let selection = $getSelection() || $getPreviousSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  selection.insertNodes(nodes);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\nfunction $removeTextAndSplitBlock(selection) {\n  let selection_ = selection;\n  if (!selection.isCollapsed()) {\n    selection_.removeText();\n  }\n  // A new selection can originate as a result of node replacement, in which case is registered via\n  // $setSelection\n  const newSelection = $getSelection();\n  if ($isRangeSelection(newSelection)) {\n    selection_ = newSelection;\n  }\n  if (!$isRangeSelection(selection_)) {\n    throw Error(`Unexpected dirty selection to be null`);\n  }\n  const anchor = selection_.anchor;\n  let node = anchor.getNode();\n  let offset = anchor.offset;\n  while (!INTERNAL_$isBlock(node)) {\n    [node, offset] = $splitNodeAtPoint(node, offset);\n  }\n  return offset;\n}\nfunction $splitNodeAtPoint(node, offset) {\n  const parent = node.getParent();\n  if (!parent) {\n    const paragraph = $createParagraphNode();\n    $getRoot().append(paragraph);\n    paragraph.select();\n    return [$getRoot(), 0];\n  }\n  if ($isTextNode(node)) {\n    const split = node.splitText(offset);\n    if (split.length === 0) {\n      return [parent, node.getIndexWithinParent()];\n    }\n    const x = offset === 0 ? 0 : 1;\n    const index = split[0].getIndexWithinParent() + x;\n    return [parent, index];\n  }\n  if (!$isElementNode(node) || offset === 0) {\n    return [parent, node.getIndexWithinParent()];\n  }\n  const firstToAppend = node.getChildAtIndex(offset);\n  if (firstToAppend) {\n    const insertPoint = new RangeSelection($createPoint(node.__key, offset, 'element'), $createPoint(node.__key, offset, 'element'), 0, '');\n    const newElement = node.insertNewAfter(insertPoint);\n    if (newElement) {\n      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());\n    }\n  }\n  return [parent, node.getIndexWithinParent() + 1];\n}\nfunction $wrapInlineNodes(nodes) {\n  // We temporarily insert the topLevelNodes into an arbitrary ElementNode,\n  // since insertAfter does not work on nodes that have no parent (TO-DO: fix that).\n  const virtualRoot = $createParagraphNode();\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = $isLineBreakNode(node);\n    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        virtualRoot.append(currentBlock);\n        // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      virtualRoot.append(node);\n      currentBlock = null;\n    }\n  }\n  return virtualRoot;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update(), editor.read(), or editorState.read().${collectBuildInformation()}`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update() or editor.read().${collectBuildInformation()}`);\n    }\n  }\n  return activeEditor;\n}\nfunction collectBuildInformation() {\n  let compatibleEditors = 0;\n  const incompatibleEditors = new Set();\n  const thisVersion = LexicalEditor.version;\n  if (typeof window !== 'undefined') {\n    for (const node of document.querySelectorAll('[contenteditable]')) {\n      const editor = getEditorPropertyFromDOMNode(node);\n      if (isLexicalEditor(editor)) {\n        compatibleEditors++;\n      } else if (editor) {\n        let version = String(editor.constructor.version || '<0.17.1');\n        if (version === thisVersion) {\n          version += ' (separately built, likely a bundler configuration issue)';\n        }\n        incompatibleEditors.add(version);\n      }\n    }\n  }\n  let output = ` Detected on the page: ${compatibleEditors} compatible editor(s) with version ${thisVersion}`;\n  if (incompatibleEditors.size) {\n    output += ` and incompatible editors with versions ${Array.from(incompatibleEditors).join(', ')}`;\n  }\n  return output;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction internalGetActiveEditorState() {\n  return activeEditorState;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\nfunction addTags(editor, tags) {\n  if (!tags) {\n    return;\n  }\n  const updateTags = editor._updateTags;\n  let tags_ = tags;\n  if (!Array.isArray(tags)) {\n    tags_ = [tags];\n  }\n  for (const tag of tags_) {\n    updateTags.add(tag);\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editor, editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = editor;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction $commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = $reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        $commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty) && rootElement !== null && !tags.has('skip-dom-selection')) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n\n  // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  $triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags\n      });\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction $triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      $beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (options.discrete) {\n          const pendingEditorState = editor._pendingEditorState;\n          if (!(pendingEditorState !== null)) {\n            throw Error(`Unexpected empty pending editor state on discrete nested update`);\n          }\n          pendingEditorState._flushSync = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        addTags(editor, options.tag);\n      }\n      nextUpdateFn();\n    }\n  }\n  return skipTransforms;\n}\nfunction $beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    addTags(editor, options.tag);\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection !== null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = $internalCreateSelection(editor);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    $commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editor._deferred.length > 0 || editorStateHasDirtySelection(pendingEditorState, editor);\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      $commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        $commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    $beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n/**\n * A utility class for managing the DOM children of an ElementNode\n */\nclass ElementDOMSlot {\n  constructor(/** The element returned by createDOM */\n  element, /** All managed children will be inserted before this node, if defined */\n  before, /** All managed children will be inserted after this node, if defined */\n  after) {\n    this.element = element;\n    this.before = before || null;\n    this.after = after || null;\n  }\n  /**\n   * Return a new ElementDOMSlot where all managed children will be inserted before this node\n   */\n  withBefore(before) {\n    return new ElementDOMSlot(this.element, before, this.after);\n  }\n  /**\n   * Return a new ElementDOMSlot where all managed children will be inserted after this node\n   */\n  withAfter(after) {\n    return new ElementDOMSlot(this.element, this.before, after);\n  }\n  /**\n   * Return a new ElementDOMSlot with an updated root element\n   */\n  withElement(element) {\n    return new ElementDOMSlot(element, this.before, this.after);\n  }\n  /**\n   * Insert the given child before this.before and any reconciler managed line break node,\n   * or append it if this.before is not defined\n   */\n  insertChild(dom) {\n    const before = this.before || this.getManagedLineBreak();\n    if (!(before === null || before.parentElement === this.element)) {\n      throw Error(`ElementDOMSlot.insertChild: before is not in element`);\n    }\n    this.element.insertBefore(dom, before);\n    return this;\n  }\n  /**\n   * Remove the managed child from this container, will throw if it was not already there\n   */\n  removeChild(dom) {\n    if (!(dom.parentElement === this.element)) {\n      throw Error(`ElementDOMSlot.removeChild: dom is not in element`);\n    }\n    this.element.removeChild(dom);\n    return this;\n  }\n  /**\n   * Replace managed child prevDom with dom. Will throw if prevDom is not a child\n   *\n   * @param dom The new node to replace prevDom\n   * @param prevDom the node that will be replaced\n   */\n  replaceChild(dom, prevDom) {\n    if (!(prevDom.parentElement === this.element)) {\n      throw Error(`ElementDOMSlot.replaceChild: prevDom is not in element`);\n    }\n    this.element.replaceChild(dom, prevDom);\n    return this;\n  }\n  /**\n   * Returns the first managed child of this node,\n   * which will either be this.after.nextSibling or this.element.firstChild,\n   * and will never be this.before if it is defined.\n   */\n  getFirstChild() {\n    const firstChild = this.after ? this.after.nextSibling : this.element.firstChild;\n    return firstChild === this.before || firstChild === this.getManagedLineBreak() ? null : firstChild;\n  }\n  /**\n   * @internal\n   */\n  getManagedLineBreak() {\n    const element = this.element;\n    return element.__lexicalLineBreak || null;\n  }\n  /** @internal */\n  setManagedLineBreak(lineBreakType) {\n    if (lineBreakType === null) {\n      this.removeManagedLineBreak();\n    } else {\n      const webkitHack = lineBreakType === 'decorator' && (IS_IOS || IS_SAFARI);\n      this.insertManagedLineBreak(webkitHack);\n    }\n  }\n\n  /** @internal */\n  removeManagedLineBreak() {\n    const br = this.getManagedLineBreak();\n    if (br) {\n      const element = this.element;\n      const sibling = br.nodeName === 'IMG' ? br.nextSibling : null;\n      if (sibling) {\n        element.removeChild(sibling);\n      }\n      element.removeChild(br);\n      element.__lexicalLineBreak = undefined;\n    }\n  }\n  /** @internal */\n  insertManagedLineBreak(webkitHack) {\n    const prevBreak = this.getManagedLineBreak();\n    if (prevBreak) {\n      if (webkitHack === (prevBreak.nodeName === 'IMG')) {\n        return;\n      }\n      this.removeManagedLineBreak();\n    }\n    const element = this.element;\n    const before = this.before;\n    const br = document.createElement('br');\n    element.insertBefore(br, before);\n    if (webkitHack) {\n      const img = document.createElement('img');\n      img.setAttribute('data-lexical-linebreak', 'true');\n      img.style.cssText = 'display: inline !important; border: 0px !important; margin: 0px !important;';\n      img.alt = '';\n      element.insertBefore(img, br);\n      element.__lexicalLineBreak = img;\n    } else {\n      element.__lexicalLineBreak = br;\n    }\n  }\n\n  /**\n   * @internal\n   *\n   * Returns the offset of the first child\n   */\n  getFirstChildOffset() {\n    let i = 0;\n    for (let node = this.after; node !== null; node = node.previousSibling) {\n      i++;\n    }\n    return i;\n  }\n\n  /**\n   * @internal\n   */\n  resolveChildIndex(element, elementDOM, initialDOM, initialOffset) {\n    if (initialDOM === this.element) {\n      const firstChildOffset = this.getFirstChildOffset();\n      return [element, Math.min(firstChildOffset + element.getChildrenSize(), Math.max(firstChildOffset, initialOffset))];\n    }\n    // The resolved offset must be before or after the children\n    const initialPath = indexPath(elementDOM, initialDOM);\n    initialPath.push(initialOffset);\n    const elementPath = indexPath(elementDOM, this.element);\n    let offset = element.getIndexWithinParent();\n    for (let i = 0; i < elementPath.length; i++) {\n      const target = initialPath[i];\n      const source = elementPath[i];\n      if (target === undefined || target < source) {\n        break;\n      } else if (target > source) {\n        offset += 1;\n        break;\n      }\n    }\n    return [element.getParentOrThrow(), offset];\n  }\n}\nfunction indexPath(root, child) {\n  const path = [];\n  let node = child;\n  for (; node !== root && node !== null; node = child.parentNode) {\n    let i = 0;\n    for (let sibling = node.previousSibling; sibling !== null; sibling = node.previousSibling) {\n      i++;\n    }\n    path.push(i);\n  }\n  if (!(node === root)) {\n    throw Error(`indexPath: root is not a parent of child`);\n  }\n  return path.reverse();\n}\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__style = '';\n    this.__indent = 0;\n    this.__dir = null;\n    this.__textFormat = 0;\n    this.__textStyle = '';\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__first = prevNode.__first;\n    this.__last = prevNode.__last;\n    this.__size = prevNode.__size;\n    this.__indent = prevNode.__indent;\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__dir = prevNode.__dir;\n    this.__textFormat = prevNode.__textFormat;\n    this.__textStyle = prevNode.__textStyle;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while ($isElementNode(node)) {\n      const child = node.getLastChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n    return textContentSize;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  getTextFormat() {\n    const self = this.getLatest();\n    return self.__textFormat;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n  hasTextFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getTextFormat() & formatFlag) !== 0;\n  }\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__textFormat;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n  getTextStyle() {\n    const self = this.getLatest();\n    return self.__textStyle;\n  }\n\n  // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    return firstNode ? firstNode.selectStart() : this.select();\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    return lastNode ? lastNode.selectEnd() : this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style || '';\n    return this;\n  }\n  setTextFormat(type) {\n    const self = this.getWritable();\n    self.__textFormat = type;\n    return self;\n  }\n  setTextStyle(style) {\n    const self = this.getWritable();\n    self.__textStyle = style;\n    return self;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    if (!(start + deleteCount <= oldSize)) {\n      throw Error(`ElementNode.splice: start + deleteCount > oldSize (${String(start)} + ${String(deleteCount)} > ${String(oldSize)})`);\n    }\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  }\n  /**\n   * @internal\n   *\n   * An experimental API that an ElementNode can override to control where its\n   * children are inserted into the DOM, this is useful to add a wrapping node\n   * or accessory nodes before or after the children. The root of the node returned\n   * by createDOM must still be exactly one HTMLElement.\n   */\n  getDOMSlot(element) {\n    return new ElementDOMSlot(element);\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML\n        // (see https://www.caniemail.com/features/css-padding-inline-start-end/),\n        // If you want to use HTML output for email, consider overriding the serialization\n        // to use `padding-right` in RTL languages, `padding-left` in `LTR` languages, or\n        // `text-indent` if you are ok with first-line indents.\n        // We recommend keeping multiples of 40px to maintain consistency with list-items\n        // (see https://github.com/facebook/lexical/pull/4025)\n        element.style.paddingInlineStart = `${indent * 40}px`;\n      }\n    }\n    return {\n      element\n    };\n  }\n  // JSON serialization\n  exportJSON() {\n    const json = {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      // As an exception here we invoke super at the end for historical reasons.\n      // Namely, to preserve the order of the properties and not to break the tests\n      // that use the serialized string representation.\n      ...super.exportJSON()\n    };\n    const textFormat = this.getTextFormat();\n    const textStyle = this.getTextStyle();\n    if (textFormat !== 0) {\n      json.textFormat = textFormat;\n    }\n    if (textStyle !== '') {\n      json.textStyle = textStyle;\n    }\n    return json;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setFormat(serializedNode.format).setIndent(serializedNode.indent).setDirection(serializedNode.direction).setTextFormat(serializedNode.textFormat || 0).setTextStyle(serializedNode.textStyle || '');\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  }\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return true;\n  }\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot() {\n    return false;\n  }\n  /** @deprecated @internal */\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n\n  /**\n   * Determines whether this node, when empty, can merge with a first block\n   * of nodes being inserted.\n   *\n   * This method is specifically called in {@link RangeSelection.insertNodes}\n   * to determine merging behavior during nodes insertion.\n   *\n   * @example\n   * // In a ListItemNode or QuoteNode implementation:\n   * canMergeWhenEmpty(): true {\n   *  return true;\n   * }\n   */\n  canMergeWhenEmpty() {\n    return false;\n  }\n\n  /** @internal */\n  reconcileObservedMutation(dom, editor) {\n    const slot = this.getDOMSlot(dom);\n    let currentDOM = slot.getFirstChild();\n    for (let currentNode = this.getFirstChild(); currentNode; currentNode = currentNode.getNextSibling()) {\n      const correctDOM = editor.getElementByKey(currentNode.getKey());\n      if (correctDOM === null) {\n        continue;\n      }\n      if (currentDOM == null) {\n        slot.insertChild(correctDOM);\n        currentDOM = correctDOM;\n      } else if (currentDOM !== correctDOM) {\n        slot.replaceChild(correctDOM, currentDOM);\n      }\n      currentDOM = currentDOM.nextSibling;\n    }\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass DecoratorNode extends LexicalNode {\n  /**\n   * The returned value is added to the LexicalEditor._decorators\n   */\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  }\n\n  // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  // Mutate\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n    return super.append(...nodesToAppend);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    return $getRoot().updateFromJSON(serializedNode);\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn, options) {\n    return readEditorState(options && options.editor || null, this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(null, this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// TODO: Cleanup ArtificialNode__DO_NOT_USE #5966\nclass ArtificialNode__DO_NOT_USE extends ElementNode {\n  static getType() {\n    return 'artificial';\n  }\n  createDOM(config) {\n    // this isnt supposed to be used and is not used anywhere but defining it to appease the API\n    const dom = document.createElement('div');\n    return dom;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: $convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createParagraphNode().updateFromJSON(serializedNode);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      // These are included explicitly for backwards compatibility\n      textFormat: this.getTextFormat(),\n      textStyle: this.getTextStyle()\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(rangeSelection, restoreSelection) {\n    const newElement = $createParagraphNode();\n    newElement.setTextFormat(rangeSelection.format);\n    newElement.setTextStyle(rangeSelection.style);\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    newElement.setFormat(this.getFormatType());\n    newElement.setStyle(this.getTextStyle());\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction $convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    setNodeIndentFromDOM(element, node);\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// https://github.com/microsoft/TypeScript/issues/3841\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nconst DEFAULT_SKIP_INITIALIZATION = false;\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/**\n * Type helper for extracting the payload type from a command.\n *\n * @example\n * ```ts\n * const MY_COMMAND = createCommand<SomeType>();\n *\n * // ...\n *\n * editor.registerCommand(MY_COMMAND, payload => {\n *   // Type of `payload` is inferred here. But lets say we want to extract a function to delegate to\n *   $handleMyCommand(editor, payload);\n *   return true;\n * });\n *\n * function $handleMyCommand(editor: LexicalEditor, payload: CommandPayloadType<typeof MY_COMMAND>) {\n *   // `payload` is of type `SomeType`, extracted from the command.\n * }\n * ```\n */\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes, additionalConversions) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  const addConversionsToCache = map => {\n    Object.keys(map).forEach(key => {\n      let currentCache = conversionCache.get(key);\n      if (currentCache === undefined) {\n        currentCache = [];\n        conversionCache.set(key, currentCache);\n      }\n      currentCache.push(map[key]);\n    });\n  };\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM.call(node.klass);\n    if (map !== null) {\n      addConversionsToCache(map);\n    }\n  });\n  if (additionalConversions) {\n    addConversionsToCache(additionalConversions);\n  }\n  return conversionCache;\n}\n\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ArtificialNode__DO_NOT_USE, ...(config.nodes || [])];\n  const {\n    onError,\n    html\n  } = config;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replace = null;\n      let replaceWithKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replace = options.with;\n        replaceWithKlass = options.withKlass || null;\n      }\n      // Ensure custom nodes implement required methods and replaceWithKlass is instance of base klass.\n      {\n        // ArtificialNode__DO_NOT_USE can get renamed, so we use the type\n        const nodeType = Object.prototype.hasOwnProperty.call(klass, 'getType') && klass.getType();\n        const name = klass.name;\n        if (replaceWithKlass) {\n          if (!(replaceWithKlass.prototype instanceof klass)) {\n            throw Error(`${replaceWithKlass.name} doesn't extend the ${name}`);\n          }\n        }\n        if (name !== 'RootNode' && nodeType !== 'root' && nodeType !== 'artificial') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') &&\n          // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if ($isDecoratorNode(proto)) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n          if (\n          // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n      registeredNodes.set(type, {\n        exportDOM: html && html.export ? html.export.get(klass) : undefined,\n        klass,\n        replace,\n        replaceWithKlass,\n        transforms\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : undefined), isEditable);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  /** The version with build identifiers for this editor (since 0.17.1) */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched with {@link LexicalEditor.dispatch}, subject to priority.\n   * Listeners that run at a higher priority can \"intercept\" commands and\n   * prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners are always invoked in an {@link LexicalEditor.update} and can\n   * call dollar functions.\n   *\n   * Listeners registered at the same priority level will run\n   * deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   *   (or {@link COMMAND_PRIORITY_EDITOR} |\n   *     {@link COMMAND_PRIORITY_LOW} |\n   *     {@link COMMAND_PRIORITY_NORMAL} |\n   *     {@link COMMAND_PRIORITY_HIGH} |\n   *     {@link COMMAND_PRIORITY_CRITICAL})\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * If any existing nodes are in the DOM, and skipInitialization is not true, the listener\n   * will be called immediately with an updateTag of 'registerMutationListener' where all\n   * nodes have the 'created' NodeMutation. This can be controlled with the skipInitialization option\n   * (whose default was previously true for backwards compatibility with &lt;=0.16.1 but has been changed to false as of 0.21.0).\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @param options - see {@link MutationListenerOptions}\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerMutationListener(klass, listener, options) {\n    const klassToMutate = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(klass)).klass;\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klassToMutate);\n    const skipInitialization = options && options.skipInitialization;\n    if (!(skipInitialization === undefined ? DEFAULT_SKIP_INITIALIZATION : skipInitialization)) {\n      this.initializeMutationListener(listener, klassToMutate);\n    }\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n\n  /** @internal */\n  getRegisteredNode(klass) {\n    const registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  resolveRegisteredNodeAfterReplacements(registeredNode) {\n    while (registeredNode.replaceWithKlass) {\n      registeredNode = this.getRegisteredNode(registeredNode.replaceWithKlass);\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  initializeMutationListener(listener, klass) {\n    const prevEditorState = this._editorState;\n    const nodeMap = getCachedTypeToNodeMap(prevEditorState).get(klass.getType());\n    if (!nodeMap) {\n      return;\n    }\n    const nodeMutationMap = new Map();\n    for (const k of nodeMap.keys()) {\n      nodeMutationMap.set(k, 'created');\n    }\n    if (nodeMutationMap.size > 0) {\n      listener(nodeMutationMap, {\n        dirtyLeaves: new Set(),\n        prevEditorState,\n        updateTags: new Set(['registerMutationListener'])\n      });\n    }\n  }\n\n  /** @internal */\n  registerNodeTransformToKlass(klass, listener) {\n    const registeredNode = this.getRegisteredNode(klass);\n    registeredNode.transforms.add(listener);\n    return registeredNode;\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markNodesWithTypesAsDirty(this, registeredNodes.map(node => node.klass.getType()));\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload. The command listeners\n   * will be triggered in an implicit {@link LexicalEditor.update}, unless\n   * this was invoked from inside an update in which case that update context\n   * will be re-used (as if this was a dollar function itself).\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n  getDecorators() {\n    return this._decorators;\n  }\n\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n  getRootElement() {\n    return this._rootElement;\n  }\n\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add('history-merge');\n        $commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n        {\n          const nextRootElementParent = nextRootElement.parentElement;\n          if (nextRootElementParent != null && ['flex', 'inline-flex'].includes(getComputedStyle(nextRootElementParent).display)) {\n            console.warn(`When using \"display: flex\" or \"display: inline-flex\" on an element containing content editable, Chrome may have unwanted focusing behavior when clicking outside of it. Consider wrapping the content editable within a non-flex element.`);\n          }\n        }\n      } else {\n        // When the content editable is unmounted we will still trigger a\n        // reconciliation so that any pending updates are flushed,\n        // to match the previous state change when\n        // `_editorState = pendingEditorState` was used, but by\n        // using a commit we preserve the readOnly invariant\n        // for editor.getEditorState().\n        this._window = null;\n        this._updateTags.add('history-merge');\n        $commitPendingUpdates(this);\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n  getEditorState() {\n    return this._editorState;\n  }\n\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n\n    // Ensure that we have a writable EditorState so that transforms can run\n    // during a historic operation\n    let writableEditorState = editorState;\n    if (writableEditorState._readOnly) {\n      writableEditorState = cloneEditorState(editorState);\n      writableEditorState._selection = editorState._selection ? editorState._selection.clone() : null;\n    }\n    $flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      $commitPendingUpdates(this);\n    }\n    this._pendingEditorState = writableEditorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n\n    // Only commit pending updates if not already in an editor.update\n    // (e.g. dispatchCommand) otherwise this will cause a second commit\n    // with an already read-only state and selection\n    if (!this._updating) {\n      $commitPendingUpdates(this);\n    }\n  }\n\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserialization from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n\n  /**\n   * Executes a read of the editor's state, with the\n   * editor context available (useful for exporting and read-only DOM\n   * operations). Much like update, but prevents any mutation of the\n   * editor's state. Any pending updates will be flushed immediately before\n   * the read.\n   * @param callbackFn - A function that has access to read-only editor state.\n   */\n  read(callbackFn) {\n    $commitPendingUpdates(this);\n    return this.getEditorState().read(callbackFn, {\n      editor: this\n    });\n  }\n\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        },\n        tag: 'focus'\n      });\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n\n  /**\n   * Removes focus from the editor.\n   */\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\nLexicalEditor.version = \"0.23.1+dev.esm\";\n\nexport { $addUpdateTag, $applyNodeReplacement, $cloneWithProperties, $copyNode, $createLineBreakNode, $createNodeSelection, $createParagraphNode, $createPoint, $createRangeSelection, $createRangeSelectionFromDom, $createTabNode, $createTextNode, $getAdjacentNode, $getCharacterOffsets, $getEditor, $getNearestNodeFromDOMNode, $getNearestRootOrShadowRoot, $getNodeByKey, $getNodeByKeyOrThrow, $getPreviousSelection, $getRoot, $getSelection, $getTextContent, $hasAncestor, $hasUpdateTag, $insertNodes, $isBlockElementNode, $isDecoratorNode, $isElementNode, $isInlineElementOrDecoratorNode, $isLeafNode, $isLineBreakNode, $isNodeSelection, $isParagraphNode, $isRangeSelection, $isRootNode, $isRootOrShadowRoot, $isTabNode, $isTextNode, $isTokenOrSegmented, $nodesOfType, $normalizeSelection as $normalizeSelection__EXPERIMENTAL, $onUpdate, $parseSerializedNode, $selectAll, $setCompositionKey, $setSelection, $splitNode, ArtificialNode__DO_NOT_USE, BLUR_COMMAND, CAN_REDO_COMMAND, CAN_UNDO_COMMAND, CLEAR_EDITOR_COMMAND, CLEAR_HISTORY_COMMAND, CLICK_COMMAND, COMMAND_PRIORITY_CRITICAL, COMMAND_PRIORITY_EDITOR, COMMAND_PRIORITY_HIGH, COMMAND_PRIORITY_LOW, COMMAND_PRIORITY_NORMAL, CONTROLLED_TEXT_INSERTION_COMMAND, COPY_COMMAND, CUT_COMMAND, DELETE_CHARACTER_COMMAND, DELETE_LINE_COMMAND, DELETE_WORD_COMMAND, DRAGEND_COMMAND, DRAGOVER_COMMAND, DRAGSTART_COMMAND, DROP_COMMAND, DecoratorNode, ElementNode, FOCUS_COMMAND, FORMAT_ELEMENT_COMMAND, FORMAT_TEXT_COMMAND, INDENT_CONTENT_COMMAND, INSERT_LINE_BREAK_COMMAND, INSERT_PARAGRAPH_COMMAND, INSERT_TAB_COMMAND, IS_ALL_FORMATTING, IS_BOLD, IS_CODE, IS_HIGHLIGHT, IS_ITALIC, IS_STRIKETHROUGH, IS_SUBSCRIPT, IS_SUPERSCRIPT, IS_UNDERLINE, KEY_ARROW_DOWN_COMMAND, KEY_ARROW_LEFT_COMMAND, KEY_ARROW_RIGHT_COMMAND, KEY_ARROW_UP_COMMAND, KEY_BACKSPACE_COMMAND, KEY_DELETE_COMMAND, KEY_DOWN_COMMAND, KEY_ENTER_COMMAND, KEY_ESCAPE_COMMAND, KEY_MODIFIER_COMMAND, KEY_SPACE_COMMAND, KEY_TAB_COMMAND, LineBreakNode, MOVE_TO_END, MOVE_TO_START, OUTDENT_CONTENT_COMMAND, PASTE_COMMAND, ParagraphNode, REDO_COMMAND, REMOVE_TEXT_COMMAND, RootNode, SELECTION_CHANGE_COMMAND, SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, SELECT_ALL_COMMAND, TEXT_TYPE_TO_FORMAT, TabNode, TextNode, UNDO_COMMAND, createCommand, createEditor, getDOMOwnerDocument, getDOMSelection, getDOMSelectionFromTarget, getDOMTextNode, getEditorPropertyFromDOMNode, getNearestEditorFromDOMNode, isBlockDomNode, isCurrentlyReadOnlyMode, isDOMDocumentNode, isDOMNode, isDOMTextNode, isDOMUnmanaged, isDocumentFragment, isHTMLAnchorElement, isHTMLElement, isInlineDomNode, isLexicalEditor, isSelectionCapturedInDecoratorInput, isSelectionWithinEditor, resetRandomKey, setDOMUnmanaged, setNodeIndentFromDOM };\n"],"mappings":"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CrH,GAAG,CAAC1C,GAAG,EAAEgd,WAAW,CAAC;IAC7B,OAAOA,WAAW;EACpB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEtQ,cAAcA,CAAA,EAAG;IACf,OAAO,EAAE;EACX;;EAEA;AACF;AACA;AACA;EACE5G,kBAAkBA,CAAA,EAAG;IACnB,OAAO,IAAI,CAAC4G,cAAc,CAAC,CAAC,CAACpL,MAAM;EACrC;;EAEA;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEyf,SAASA,CAACxG,OAAO,EAAE8V,OAAO,EAAE;IAC1B;MACE,MAAM7pB,KAAK,CAAC,qCAAqC,CAAC;IACpD;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEqe,SAASA,CAACyL,SAAS,EAAEC,IAAI,EAAEhW,OAAO,EAAE;IAClC;MACE,MAAM/T,KAAK,CAAC,qCAAqC,CAAC;IACpD;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEgqB,SAASA,CAACvzB,MAAM,EAAE;IAChB,MAAMqL,OAAO,GAAG,IAAI,CAACyY,SAAS,CAAC9jB,MAAM,CAACsd,OAAO,EAAEtd,MAAM,CAAC;IACtD,OAAO;MACLqL;IACF,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEmoB,UAAUA,CAAA,EAAG;IACX,OAAO;MACL78B,IAAI,EAAE,IAAI,CAACogB,MAAM;MACjB0c,OAAO,EAAE;IACX,CAAC;EACH;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,UAAUA,CAACC,eAAe,EAAE;IACjC;MACE,MAAMpqB,KAAK,CAAC,qBAAqB,IAAI,CAACoD,IAAI,oCAAoC,CAAC;IACjF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEinB,cAAcA,CAACC,cAAc,EAAE;IAC7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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}