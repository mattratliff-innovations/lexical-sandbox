{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { isHTMLElement, $getSelection, $isRangeSelection, $isElementNode, getDOMTextNode, $getRoot, $cloneWithProperties, $setSelection, $getPreviousSelection, $isRootOrShadowRoot, $isTextNode, $splitNode, $createParagraphNode } from 'lexical';\nexport { $splitNode, isBlockDomNode, isHTMLAnchorElement, isHTMLElement, isInlineDomNode } from 'lexical';\nimport { createRectsFromDOMRange } from '@lexical/selection';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction prependDOMNode(parent, node) {\n  parent.insertBefore(node, parent.firstChild);\n}\n\n/**\n * Place one or multiple newly created Nodes at the passed Range's position.\n * Multiple nodes will only be created when the Range spans multiple lines (aka\n * client rects).\n *\n * This function can come particularly useful to highlight particular parts of\n * the text without interfering with the EditorState, that will often replicate\n * the state across collab and clipboard.\n *\n * This function accounts for DOM updates which can modify the passed Range.\n * Hence, the function return to remove the listener.\n */\nfunction mlcPositionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  wrapperNode.style.position = 'relative';\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: parentLeft,\n      top: parentTop\n    } = parentDOMNode.getBoundingClientRect();\n    const rects = createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      prependDOMNode(parentDOMNode, wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - parentLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - parentTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!isHTMLElement(currentParentDOMNode)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction rangeTargetFromPoint(point, node, dom) {\n  if (point.type === 'text' || !$isElementNode(node)) {\n    const textDOM = getDOMTextNode(dom) || dom;\n    return [textDOM, point.offset];\n  } else {\n    const slot = node.getDOMSlot(dom);\n    return [slot.element, slot.getFirstChildOffset() + point.offset];\n  }\n}\nfunction rangeFromPoints(editor, anchor, anchorNode, anchorDOM, focus, focusNode, focusDOM) {\n  const editorDocument = editor._window ? editor._window.document : document;\n  const range = editorDocument.createRange();\n  if (focusNode.isBefore(anchorNode)) {\n    range.setStart(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n    range.setEnd(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n  } else {\n    range.setStart(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n    range.setEnd(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n  }\n  return range;\n}\n/**\n * Place one or multiple newly created Nodes at the current selection. Multiple\n * nodes will only be created when the selection spans multiple lines (aka\n * client rects).\n *\n * This function can come useful when you want to show the selection but the\n * editor has been focused away.\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorNodeDOM = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusNodeDOM = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM !== previousAnchorNodeDOM || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey();\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM !== previousFocusNodeDOM || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey();\n      if ((differentAnchorDOM || differentFocusDOM) && currentAnchorNodeDOM !== null && currentFocusNodeDOM !== null) {\n        const range = rangeFromPoints(editor, anchor, currentAnchorNode, currentAnchorNodeDOM, focus, currentFocusNode, currentFocusNodeDOM);\n        removeRangeListener();\n        removeRangeListener = mlcPositionNodeOnRange(editor, range, domNodes => {\n          if (onReposition === undefined) {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n          } else {\n            onReposition(domNodes);\n          }\n        });\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorNodeDOM = currentAnchorNodeDOM;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusNodeDOM = currentFocusNodeDOM;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction selectionAlwaysOnDisplay(editor) {\n  let removeSelectionMark = null;\n  const onSelectionChange = () => {\n    const domSelection = getSelection();\n    const domAnchorNode = domSelection && domSelection.anchorNode;\n    const editorRootElement = editor.getRootElement();\n    const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);\n    if (isSelectionInsideEditor) {\n      if (removeSelectionMark !== null) {\n        removeSelectionMark();\n        removeSelectionMark = null;\n      }\n    } else {\n      if (removeSelectionMark === null) {\n        removeSelectionMark = markSelection(editor);\n      }\n    }\n  };\n  document.addEventListener('selectionchange', onSelectionChange);\n  return () => {\n    if (removeSelectionMark !== null) {\n      removeSelectionMark();\n    }\n    document.removeEventListener('selectionchange', onSelectionChange);\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\nconst iteratorDone = {\n  done: true,\n  value: undefined\n};\nconst iteratorNotDone = value => ({\n  done: false,\n  value\n});\n\n/**\n * $dfs iterator. Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  const start = (startNode || $getRoot()).getLatest();\n  const startDepth = $getDepth(start);\n  const end = endNode;\n  let node = start;\n  let depth = startDepth;\n  let isFirstNext = true;\n  const iterator = {\n    next() {\n      if (node === null) {\n        return iteratorDone;\n      }\n      if (isFirstNext) {\n        isFirstNext = false;\n        return iteratorNotDone({\n          depth,\n          node\n        });\n      }\n      if (node === end) {\n        return iteratorDone;\n      }\n      if ($isElementNode(node) && node.getChildrenSize() > 0) {\n        node = node.getFirstChild();\n        depth++;\n      } else {\n        let depthDiff;\n        [node, depthDiff] = $getNextSiblingOrParentSibling(node) || [null, 0];\n        depth += depthDiff;\n        if (end == null && depth <= startDepth) {\n          node = null;\n        }\n      }\n      if (node === null) {\n        return iteratorDone;\n      }\n      return iteratorNotDone({\n        depth,\n        node\n      });\n    },\n    [Symbol.iterator]() {\n      return iterator;\n    }\n  };\n  return iterator;\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  let node_ = node;\n  // Find immediate sibling or nearest parent sibling\n  let sibling = null;\n  let depthDiff = 0;\n  while (sibling === null && node_ !== null) {\n    sibling = node_.getNextSibling();\n    if (sibling === null) {\n      node_ = node_.getParent();\n      depthDiff--;\n    } else {\n      node_ = sibling;\n    }\n  }\n  if (node_ === null) {\n    return null;\n  }\n  return [node_, depthDiff];\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  let node = startingNode;\n  if ($isElementNode(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (!$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, $cloneWithProperties(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  $setSelection(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = $getSelection() || $getPreviousSelection();\n  if ($isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ($isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ($isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = $splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = $getRoot();\n      root.append(node);\n    }\n    const paragraphNode = $createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nlet NEEDS_MANUAL_ZOOM = IS_FIREFOX || !CAN_USE_DOM ? false : undefined;\nfunction needsManualZoom() {\n  if (NEEDS_MANUAL_ZOOM === undefined) {\n    // If the browser implements standardized CSS zoom, then the client rect\n    // will be wider after zoom is applied\n    // https://chromestatus.com/feature/5198254868529152\n    // https://github.com/facebook/lexical/issues/6863\n    const div = document.createElement('div');\n    div.style.cssText = 'position: absolute; opacity: 0; width: 100px; left: -1000px;';\n    document.body.appendChild(div);\n    const noZoom = div.getBoundingClientRect();\n    div.style.setProperty('zoom', '2');\n    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;\n    document.body.removeChild(div);\n  }\n  return NEEDS_MANUAL_ZOOM;\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property. For browsers that implement standardized CSS\n * zoom (Firefox, Chrome >= 128), this will always return 1.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  let zoom = 1;\n  if (needsManualZoom()) {\n    while (element) {\n      zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n      element = element.parentElement;\n    }\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n/**\n * A depth first last-to-first traversal of root that stops at each node that matches\n * $predicate and ensures that its parent is root. This is typically used to discard\n * invalid or unsupported wrapping nodes. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * @param root The root to start the traversal\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns true if this unwrapped or removed any nodes\n */\nfunction $unwrapAndFilterDescendants(root, $predicate) {\n  return $unwrapAndFilterDescendantsImpl(root, $predicate, null);\n}\nfunction $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {\n  let didMutate = false;\n  for (const node of $lastToFirstIterator(root)) {\n    if ($predicate(node)) {\n      if ($onSuccess !== null) {\n        $onSuccess(node);\n      }\n      continue;\n    }\n    didMutate = true;\n    if ($isElementNode(node)) {\n      $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess ? $onSuccess : child => node.insertAfter(child));\n    }\n    node.remove();\n  }\n  return didMutate;\n}\n\n/**\n * A depth first traversal of the children array that stops at and collects\n * each node that `$predicate` matches. This is typically used to discard\n * invalid or unsupported wrapping nodes on a children array in the `after`\n * of an {@link lexical!DOMConversionOutput}. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * This function is read-only and performs no mutation operations, which makes\n * it suitable for import and export purposes but likely not for any in-place\n * mutation. You should use {@link $unwrapAndFilterDescendants} for in-place\n * mutations such as node transforms.\n *\n * @param children The children to traverse\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns The children or their descendants that match $predicate\n */\n\nfunction $descendantsMatching(children, $predicate) {\n  const result = [];\n  const stack = [...children].reverse();\n  for (let child = stack.pop(); child !== undefined; child = stack.pop()) {\n    if ($predicate(child)) {\n      result.push(child);\n    } else if ($isElementNode(child)) {\n      for (const grandchild of $lastToFirstIterator(child)) {\n        stack.push(grandchild);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Return an iterator that yields each child of node from first to last, taking\n * care to preserve the next sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $firstToLastIterator(node) {\n  return {\n    [Symbol.iterator]: () => $childIterator(node.getFirstChild(), child => child.getNextSibling())\n  };\n}\n\n/**\n * Return an iterator that yields each child of node from last to first, taking\n * care to preserve the previous sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $lastToFirstIterator(node) {\n  return {\n    [Symbol.iterator]: () => $childIterator(node.getLastChild(), child => child.getPreviousSibling())\n  };\n}\nfunction $childIterator(initialNode, nextNode) {\n  let state = initialNode;\n  const seen = new Set();\n  return {\n    next() {\n      if (state === null) {\n        return iteratorDone;\n      }\n      const rval = iteratorNotDone(state);\n      if (seen !== null) {\n        const key = state.getKey();\n        if (!!seen.has(key)) {\n          throw Error(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);\n        }\n        seen.add(key);\n      }\n      state = nextNode(state);\n      return rval;\n    }\n  };\n}\n\n/**\n * Insert all children before this node, and then remove it.\n *\n * @param node The ElementNode to unwrap and remove\n */\nfunction $unwrapNode(node) {\n  for (const child of $firstToLastIterator(node)) {\n    node.insertBefore(child);\n  }\n  node.remove();\n}\nexport { $descendantsMatching, $dfs, $dfsIterator, $filter, $findMatchingParent, $firstToLastIterator, $getDepth, $getNearestBlockElementAncestorOrThrow, $getNearestNodeOfType, $getNextRightPreorderNode, $getNextSiblingOrParentSibling, $insertFirst, $insertNodeToNearestRoot, $isEditorIsNestedEditor, $lastToFirstIterator, $restoreEditorState, $unwrapAndFilterDescendants, $unwrapNode, $wrapNodeInElement, CAN_USE_BEFORE_INPUT, CAN_USE_DOM, IS_ANDROID, IS_ANDROID_CHROME, IS_APPLE, IS_APPLE_WEBKIT, IS_CHROME, IS_FIREFOX, IS_IOS, IS_SAFARI, addClassNamesToElement, calculateZoomLevel, isMimeType, markSelection, mediaFileReader, mergeRegister, objectKlassEquals, mlcPositionNodeOnRange as positionNodeOnRange, registerNestedElementResolver, removeClassNamesFromElement, selectionAlwaysOnDisplay };","map":{"version":3,"names":["isHTMLElement","$getSelection","$isRangeSelection","$isElementNode","getDOMTextNode","$getRoot","$cloneWithProperties","$setSelection","$getPreviousSelection","$isRootOrShadowRoot","$isTextNode","$splitNode","$createParagraphNode","isBlockDomNode","isHTMLAnchorElement","isInlineDomNode","createRectsFromDOMRange","CAN_USE_DOM$1","window","document","createElement","documentMode","IS_APPLE$1","test","navigator","platform","IS_FIREFOX$1","userAgent","CAN_USE_BEFORE_INPUT$1","InputEvent","IS_SAFARI$1","IS_IOS$1","MSStream","IS_ANDROID$1","IS_CHROME$1","IS_ANDROID_CHROME$1","IS_APPLE_WEBKIT$1","normalizeClassNames","classNames","rval","className","s","matchAll","push","mergeRegister","func","i","length","px","value","mutationObserverConfig","attributes","characterData","childList","subtree","prependDOMNode","parent","node","insertBefore","firstChild","mlcPositionNodeOnRange","editor","range","onReposition","rootDOMNode","parentDOMNode","observer","lastNodes","wrapperNode","style","position","Error","left","parentLeft","top","parentTop","getBoundingClientRect","rects","isConnected","hasRepositioned","rect","rectNode","rectNodeStyle","width","height","parentNode","append","pop","stop","disconnect","remove","restart","currentRootDOMNode","getRootElement","currentParentDOMNode","parentElement","MutationObserver","mutations","nextRootDOMNode","nextParentDOMNode","mutation","contains","target","observe","removeRootListener","registerRootListener","rangeTargetFromPoint","point","dom","type","textDOM","offset","slot","getDOMSlot","element","getFirstChildOffset","rangeFromPoints","anchor","anchorNode","anchorDOM","focus","focusNode","focusDOM","editorDocument","_window","createRange","isBefore","setStart","setEnd","markSelection","previousAnchorNode","previousAnchorNodeDOM","previousAnchorOffset","previousFocusNode","previousFocusNodeDOM","previousFocusOffset","removeRangeListener","compute","editorState","read","selection","currentAnchorNode","getNode","currentAnchorNodeKey","getKey","currentAnchorOffset","currentFocusNode","currentFocusNodeKey","currentFocusOffset","currentAnchorNodeDOM","getElementByKey","currentFocusNodeDOM","differentAnchorDOM","differentFocusDOM","domNodes","undefined","domNode","domNodeStyle","background","color","marginTop","paddingTop","paddingBottom","getEditorState","registerUpdateListener","selectionAlwaysOnDisplay","removeSelectionMark","onSelectionChange","domSelection","getSelection","domAnchorNode","editorRootElement","isSelectionInsideEditor","addEventListener","removeEventListener","CAN_USE_BEFORE_INPUT","CAN_USE_DOM","IS_ANDROID","IS_ANDROID_CHROME","IS_APPLE","IS_APPLE_WEBKIT","IS_CHROME","IS_FIREFOX","IS_IOS","IS_SAFARI","addClassNamesToElement","classesToAdd","classList","add","removeClassNamesFromElement","classesToRemove","isMimeType","file","acceptableMimeTypes","acceptableType","startsWith","mediaFileReader","files","filesIterator","Symbol","iterator","Promise","resolve","reject","processed","handleNextFile","done","next","fileReader","FileReader","result","readAsDataURL","$dfs","startNode","endNode","Array","from","$dfsIterator","iteratorDone","iteratorNotDone","start","getLatest","startDepth","$getDepth","end","depth","isFirstNext","getChildrenSize","getFirstChild","depthDiff","$getNextSiblingOrParentSibling","node_","sibling","getNextSibling","getParent","innerNode","$getNextRightPreorderNode","startingNode","getLastChild","getPreviousSibling","$getNearestNodeOfType","klass","$getNearestBlockElementAncestorOrThrow","blockNode","$findMatchingParent","isInline","__key","findFn","curr","registerNestedElementResolver","targetNode","cloneNode","handleOverlap","$isTargetNode","$findMatch","children","getChildren","child","childNode","$elementNodeTransform","match","is","nextSiblings","getNextSiblings","nextSiblingsLength","insertAfter","newParent","canBeEmpty","registerNodeTransform","$restoreEditorState","FULL_RECONCILE","nodeMap","Map","activeEditorState","_pendingEditorState","key","_nodeMap","set","_dirtyType","_selection","clone","$insertNodeToNearestRoot","focusOffset","focusChild","getChildAtIndex","selectNext","splitNode","splitOffset","getParentOrThrow","getIndexWithinParent","splitText","rightTree","selectStart","nodes","getNodes","getTopLevelElementOrThrow","root","paragraphNode","select","$wrapNodeInElement","createElementNode","elementNode","replace","objectKlassEquals","object","objectClass","Object","getPrototypeOf","constructor","name","$filter","filterFn","$insertFirst","NEEDS_MANUAL_ZOOM","needsManualZoom","div","cssText","body","appendChild","noZoom","setProperty","removeChild","calculateZoomLevel","zoom","Number","getComputedStyle","getPropertyValue","$isEditorIsNestedEditor","_parentEditor","$unwrapAndFilterDescendants","$predicate","$unwrapAndFilterDescendantsImpl","$onSuccess","didMutate","$lastToFirstIterator","$descendantsMatching","stack","reverse","grandchild","$firstToLastIterator","$childIterator","initialNode","nextNode","state","seen","Set","has","String","$unwrapNode","positionNodeOnRange"],"sources":["/Users/Matt.Ratliff/Development/lexical-sandbox/node_modules/@lexical/utils/LexicalUtils.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { isHTMLElement, $getSelection, $isRangeSelection, $isElementNode, getDOMTextNode, $getRoot, $cloneWithProperties, $setSelection, $getPreviousSelection, $isRootOrShadowRoot, $isTextNode, $splitNode, $createParagraphNode } from 'lexical';\nexport { $splitNode, isBlockDomNode, isHTMLAnchorElement, isHTMLElement, isInlineDomNode } from 'lexical';\nimport { createRectsFromDOMRange } from '@lexical/selection';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction prependDOMNode(parent, node) {\n  parent.insertBefore(node, parent.firstChild);\n}\n\n/**\n * Place one or multiple newly created Nodes at the passed Range's position.\n * Multiple nodes will only be created when the Range spans multiple lines (aka\n * client rects).\n *\n * This function can come particularly useful to highlight particular parts of\n * the text without interfering with the EditorState, that will often replicate\n * the state across collab and clipboard.\n *\n * This function accounts for DOM updates which can modify the passed Range.\n * Hence, the function return to remove the listener.\n */\nfunction mlcPositionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  wrapperNode.style.position = 'relative';\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      throw Error(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      throw Error(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: parentLeft,\n      top: parentTop\n    } = parentDOMNode.getBoundingClientRect();\n    const rects = createRectsFromDOMRange(editor, range);\n    if (!wrapperNode.isConnected) {\n      prependDOMNode(parentDOMNode, wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - parentLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - parentTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!isHTMLElement(currentParentDOMNode)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction rangeTargetFromPoint(point, node, dom) {\n  if (point.type === 'text' || !$isElementNode(node)) {\n    const textDOM = getDOMTextNode(dom) || dom;\n    return [textDOM, point.offset];\n  } else {\n    const slot = node.getDOMSlot(dom);\n    return [slot.element, slot.getFirstChildOffset() + point.offset];\n  }\n}\nfunction rangeFromPoints(editor, anchor, anchorNode, anchorDOM, focus, focusNode, focusDOM) {\n  const editorDocument = editor._window ? editor._window.document : document;\n  const range = editorDocument.createRange();\n  if (focusNode.isBefore(anchorNode)) {\n    range.setStart(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n    range.setEnd(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n  } else {\n    range.setStart(...rangeTargetFromPoint(anchor, anchorNode, anchorDOM));\n    range.setEnd(...rangeTargetFromPoint(focus, focusNode, focusDOM));\n  }\n  return range;\n}\n/**\n * Place one or multiple newly created Nodes at the current selection. Multiple\n * nodes will only be created when the selection spans multiple lines (aka\n * client rects).\n *\n * This function can come useful when you want to show the selection but the\n * editor has been focused away.\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorNodeDOM = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusNodeDOM = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const {\n        anchor,\n        focus\n      } = selection;\n      const currentAnchorNode = anchor.getNode();\n      const currentAnchorNodeKey = currentAnchorNode.getKey();\n      const currentAnchorOffset = anchor.offset;\n      const currentFocusNode = focus.getNode();\n      const currentFocusNodeKey = currentFocusNode.getKey();\n      const currentFocusOffset = focus.offset;\n      const currentAnchorNodeDOM = editor.getElementByKey(currentAnchorNodeKey);\n      const currentFocusNodeDOM = editor.getElementByKey(currentFocusNodeKey);\n      const differentAnchorDOM = previousAnchorNode === null || currentAnchorNodeDOM !== previousAnchorNodeDOM || currentAnchorOffset !== previousAnchorOffset || currentAnchorNodeKey !== previousAnchorNode.getKey();\n      const differentFocusDOM = previousFocusNode === null || currentFocusNodeDOM !== previousFocusNodeDOM || currentFocusOffset !== previousFocusOffset || currentFocusNodeKey !== previousFocusNode.getKey();\n      if ((differentAnchorDOM || differentFocusDOM) && currentAnchorNodeDOM !== null && currentFocusNodeDOM !== null) {\n        const range = rangeFromPoints(editor, anchor, currentAnchorNode, currentAnchorNodeDOM, focus, currentFocusNode, currentFocusNodeDOM);\n        removeRangeListener();\n        removeRangeListener = mlcPositionNodeOnRange(editor, range, domNodes => {\n          if (onReposition === undefined) {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n          } else {\n            onReposition(domNodes);\n          }\n        });\n      }\n      previousAnchorNode = currentAnchorNode;\n      previousAnchorNodeDOM = currentAnchorNodeDOM;\n      previousAnchorOffset = currentAnchorOffset;\n      previousFocusNode = currentFocusNode;\n      previousFocusNodeDOM = currentFocusNodeDOM;\n      previousFocusOffset = currentFocusOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction selectionAlwaysOnDisplay(editor) {\n  let removeSelectionMark = null;\n  const onSelectionChange = () => {\n    const domSelection = getSelection();\n    const domAnchorNode = domSelection && domSelection.anchorNode;\n    const editorRootElement = editor.getRootElement();\n    const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);\n    if (isSelectionInsideEditor) {\n      if (removeSelectionMark !== null) {\n        removeSelectionMark();\n        removeSelectionMark = null;\n      }\n    } else {\n      if (removeSelectionMark === null) {\n        removeSelectionMark = markSelection(editor);\n      }\n    }\n  };\n  document.addEventListener('selectionchange', onSelectionChange);\n  return () => {\n    if (removeSelectionMark !== null) {\n      removeSelectionMark();\n    }\n    document.removeEventListener('selectionchange', onSelectionChange);\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\nconst iteratorDone = {\n  done: true,\n  value: undefined\n};\nconst iteratorNotDone = value => ({\n  done: false,\n  value\n});\n\n/**\n * $dfs iterator. Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  const start = (startNode || $getRoot()).getLatest();\n  const startDepth = $getDepth(start);\n  const end = endNode;\n  let node = start;\n  let depth = startDepth;\n  let isFirstNext = true;\n  const iterator = {\n    next() {\n      if (node === null) {\n        return iteratorDone;\n      }\n      if (isFirstNext) {\n        isFirstNext = false;\n        return iteratorNotDone({\n          depth,\n          node\n        });\n      }\n      if (node === end) {\n        return iteratorDone;\n      }\n      if ($isElementNode(node) && node.getChildrenSize() > 0) {\n        node = node.getFirstChild();\n        depth++;\n      } else {\n        let depthDiff;\n        [node, depthDiff] = $getNextSiblingOrParentSibling(node) || [null, 0];\n        depth += depthDiff;\n        if (end == null && depth <= startDepth) {\n          node = null;\n        }\n      }\n      if (node === null) {\n        return iteratorDone;\n      }\n      return iteratorNotDone({\n        depth,\n        node\n      });\n    },\n    [Symbol.iterator]() {\n      return iterator;\n    }\n  };\n  return iterator;\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  let node_ = node;\n  // Find immediate sibling or nearest parent sibling\n  let sibling = null;\n  let depthDiff = 0;\n  while (sibling === null && node_ !== null) {\n    sibling = node_.getNextSibling();\n    if (sibling === null) {\n      node_ = node_.getParent();\n      depthDiff--;\n    } else {\n      node_ = sibling;\n    }\n  }\n  if (node_ === null) {\n    return null;\n  }\n  return [node_, depthDiff];\n}\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to paret and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  let node = startingNode;\n  if ($isElementNode(node) && node.getChildrenSize() > 0) {\n    node = node.getLastChild();\n  } else {\n    let sibling = null;\n    while (sibling === null && node !== null) {\n      sibling = node.getPreviousSibling();\n      if (sibling === null) {\n        node = node.getParent();\n      } else {\n        node = sibling;\n      }\n    }\n  }\n  return node;\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => $isElementNode(node) && !node.isInline());\n  if (!$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, $cloneWithProperties(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  $setSelection(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = $getSelection() || $getPreviousSelection();\n  if ($isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n    if ($isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n      if ($isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n      const [, rightTree] = $splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = $getRoot();\n      root.append(node);\n    }\n    const paragraphNode = $createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n  return node.getLatest();\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nlet NEEDS_MANUAL_ZOOM = IS_FIREFOX || !CAN_USE_DOM ? false : undefined;\nfunction needsManualZoom() {\n  if (NEEDS_MANUAL_ZOOM === undefined) {\n    // If the browser implements standardized CSS zoom, then the client rect\n    // will be wider after zoom is applied\n    // https://chromestatus.com/feature/5198254868529152\n    // https://github.com/facebook/lexical/issues/6863\n    const div = document.createElement('div');\n    div.style.cssText = 'position: absolute; opacity: 0; width: 100px; left: -1000px;';\n    document.body.appendChild(div);\n    const noZoom = div.getBoundingClientRect();\n    div.style.setProperty('zoom', '2');\n    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;\n    document.body.removeChild(div);\n  }\n  return NEEDS_MANUAL_ZOOM;\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property. For browsers that implement standardized CSS\n * zoom (Firefox, Chrome >= 128), this will always return 1.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  let zoom = 1;\n  if (needsManualZoom()) {\n    while (element) {\n      zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n      element = element.parentElement;\n    }\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n/**\n * A depth first last-to-first traversal of root that stops at each node that matches\n * $predicate and ensures that its parent is root. This is typically used to discard\n * invalid or unsupported wrapping nodes. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * @param root The root to start the traversal\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns true if this unwrapped or removed any nodes\n */\nfunction $unwrapAndFilterDescendants(root, $predicate) {\n  return $unwrapAndFilterDescendantsImpl(root, $predicate, null);\n}\nfunction $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {\n  let didMutate = false;\n  for (const node of $lastToFirstIterator(root)) {\n    if ($predicate(node)) {\n      if ($onSuccess !== null) {\n        $onSuccess(node);\n      }\n      continue;\n    }\n    didMutate = true;\n    if ($isElementNode(node)) {\n      $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess ? $onSuccess : child => node.insertAfter(child));\n    }\n    node.remove();\n  }\n  return didMutate;\n}\n\n/**\n * A depth first traversal of the children array that stops at and collects\n * each node that `$predicate` matches. This is typically used to discard\n * invalid or unsupported wrapping nodes on a children array in the `after`\n * of an {@link lexical!DOMConversionOutput}. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * This function is read-only and performs no mutation operations, which makes\n * it suitable for import and export purposes but likely not for any in-place\n * mutation. You should use {@link $unwrapAndFilterDescendants} for in-place\n * mutations such as node transforms.\n *\n * @param children The children to traverse\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns The children or their descendants that match $predicate\n */\n\nfunction $descendantsMatching(children, $predicate) {\n  const result = [];\n  const stack = [...children].reverse();\n  for (let child = stack.pop(); child !== undefined; child = stack.pop()) {\n    if ($predicate(child)) {\n      result.push(child);\n    } else if ($isElementNode(child)) {\n      for (const grandchild of $lastToFirstIterator(child)) {\n        stack.push(grandchild);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Return an iterator that yields each child of node from first to last, taking\n * care to preserve the next sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $firstToLastIterator(node) {\n  return {\n    [Symbol.iterator]: () => $childIterator(node.getFirstChild(), child => child.getNextSibling())\n  };\n}\n\n/**\n * Return an iterator that yields each child of node from last to first, taking\n * care to preserve the previous sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $lastToFirstIterator(node) {\n  return {\n    [Symbol.iterator]: () => $childIterator(node.getLastChild(), child => child.getPreviousSibling())\n  };\n}\nfunction $childIterator(initialNode, nextNode) {\n  let state = initialNode;\n  const seen = new Set() ;\n  return {\n    next() {\n      if (state === null) {\n        return iteratorDone;\n      }\n      const rval = iteratorNotDone(state);\n      if (seen !== null) {\n        const key = state.getKey();\n        if (!!seen.has(key)) {\n          throw Error(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);\n        }\n        seen.add(key);\n      }\n      state = nextNode(state);\n      return rval;\n    }\n  };\n}\n\n/**\n * Insert all children before this node, and then remove it.\n *\n * @param node The ElementNode to unwrap and remove\n */\nfunction $unwrapNode(node) {\n  for (const child of $firstToLastIterator(node)) {\n    node.insertBefore(child);\n  }\n  node.remove();\n}\n\nexport { $descendantsMatching, $dfs, $dfsIterator, $filter, $findMatchingParent, $firstToLastIterator, $getDepth, $getNearestBlockElementAncestorOrThrow, $getNearestNodeOfType, $getNextRightPreorderNode, $getNextSiblingOrParentSibling, $insertFirst, $insertNodeToNearestRoot, $isEditorIsNestedEditor, $lastToFirstIterator, $restoreEditorState, $unwrapAndFilterDescendants, $unwrapNode, $wrapNodeInElement, CAN_USE_BEFORE_INPUT, CAN_USE_DOM, IS_ANDROID, IS_ANDROID_CHROME, IS_APPLE, IS_APPLE_WEBKIT, IS_CHROME, IS_FIREFOX, IS_IOS, IS_SAFARI, addClassNamesToElement, calculateZoomLevel, isMimeType, markSelection, mediaFileReader, mergeRegister, objectKlassEquals, mlcPositionNodeOnRange as positionNodeOnRange, registerNestedElementResolver, removeClassNamesFromElement, selectionAlwaysOnDisplay };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}