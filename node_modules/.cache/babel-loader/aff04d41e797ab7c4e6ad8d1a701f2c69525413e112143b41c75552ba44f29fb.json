{"ast":null,"code":"import { $isTextNode, TextNode } from 'lexical';\nconst patchNodeAndStyleConversion = originalDOMConverter => domNode => {\n  const original = originalDOMConverter === null || originalDOMConverter === void 0 ? void 0 : originalDOMConverter(domNode);\n  if (!original) {\n    return null;\n  }\n  const originalOutput = original.conversion(domNode);\n  if (!originalOutput) {\n    return originalOutput;\n  }\n  const {\n    backgroundColor\n  } = domNode.style;\n  const {\n    color\n  } = domNode.style;\n  const {\n    fontFamily\n  } = domNode.style;\n  const {\n    fontWeight\n  } = domNode.style;\n  const {\n    fontSize\n  } = domNode.style;\n  const {\n    textDecoration\n  } = domNode.style;\n  return {\n    ...originalOutput,\n    forChild: (lexicalNode, parent) => {\n      var _originalOutput$forCh;\n      const originalForChild = (_originalOutput$forCh = originalOutput === null || originalOutput === void 0 ? void 0 : originalOutput.forChild) !== null && _originalOutput$forCh !== void 0 ? _originalOutput$forCh : x => x;\n      const result = originalForChild(lexicalNode, parent);\n      if ($isTextNode(result)) {\n        const style = [backgroundColor ? `background-color: ${backgroundColor}` : null, color ? `color: ${color}` : null, fontFamily ? `font-family: ${fontFamily}` : null, fontWeight ? `font-weight: ${fontWeight}` : null, fontSize ? `font-size: ${fontSize}` : null, textDecoration ? `text-decoration: ${textDecoration}` : null].filter(value => value != null).join('; ');\n        if (style.length) {\n          return result.setStyle(style);\n        }\n      }\n      return result;\n    }\n  };\n};\nexport class ExtendedTextNode extends TextNode {\n  static getType() {\n    return 'extended-text';\n  }\n  static clone(node) {\n    return new ExtendedTextNode(node.__text, node.__key);\n  }\n  static importDOM() {\n    const importers = TextNode.importDOM();\n    return {\n      ...importers,\n      code: () => ({\n        conversion: patchNodeAndStyleConversion(importers === null || importers === void 0 ? void 0 : importers.code),\n        priority: 1\n      }),\n      em: () => ({\n        conversion: patchNodeAndStyleConversion(importers === null || importers === void 0 ? void 0 : importers.em),\n        priority: 1\n      }),\n      span: () => ({\n        conversion: patchNodeAndStyleConversion(importers === null || importers === void 0 ? void 0 : importers.span),\n        priority: 1\n      }),\n      strong: () => ({\n        conversion: patchNodeAndStyleConversion(importers === null || importers === void 0 ? void 0 : importers.strong),\n        priority: 1\n      }),\n      sub: () => ({\n        conversion: patchNodeAndStyleConversion(importers === null || importers === void 0 ? void 0 : importers.sub),\n        priority: 1\n      }),\n      sup: () => ({\n        conversion: patchNodeAndStyleConversion(importers === null || importers === void 0 ? void 0 : importers.sup),\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return TextNode.importJSON(serializedNode);\n  }\n  isSimpleText() {\n    return (this.__type === 'text' || this.__type === 'extended-text') && this.__mode === 0;\n  }\n  static getDeepestNode(dom) {\n    const nodes = Array.prototype.slice.call(dom.getElementsByTagName('*'));\n    if (nodes.length === 0) {\n      return dom;\n    }\n    const leafNodes = nodes.filter(elem => {\n      if (elem.hasChildNodes()) {\n        // see if any of the child nodes are elements\n        for (let i = 0; i < elem.childNodes.length; i += 1) {\n          if (elem.childNodes[i].nodeType === Node.ELEMENT_NODE) {\n            // there is a child element, so return false to not include\n            // this parent element\n            return false;\n          }\n        }\n      }\n      return true;\n    });\n    return leafNodes[0];\n  }\n  exportDOM(editor) {\n    const exportDOMResult = super.exportDOM(editor);\n    if (this.isSimpleText()) return exportDOMResult;\n    const spanNode = ExtendedTextNode.getDeepestNode(exportDOMResult.element);\n    this.setHtmlForExport(spanNode);\n    return {\n      ...exportDOMResult\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'extended-text',\n      version: 1\n    };\n  }\n}\nexport function $createExtendedTextNode(text) {\n  return new ExtendedTextNode(text);\n}\nexport function $isExtendedTextNode(node) {\n  return node instanceof ExtendedTextNode;\n}\nexport function $applyCustomNodeConfiguration(node) {\n  node.setMode('token');\n  node.toggleUnmergeable();\n}","map":{"version":3,"names":["$isTextNode","TextNode","patchNodeAndStyleConversion","originalDOMConverter","domNode","original","originalOutput","conversion","backgroundColor","style","color","fontFamily","fontWeight","fontSize","textDecoration","forChild","lexicalNode","parent","_originalOutput$forCh","originalForChild","x","result","filter","value","join","length","setStyle","ExtendedTextNode","getType","clone","node","__text","__key","importDOM","importers","code","priority","em","span","strong","sub","sup","importJSON","serializedNode","isSimpleText","__type","__mode","getDeepestNode","dom","nodes","Array","prototype","slice","call","getElementsByTagName","leafNodes","elem","hasChildNodes","i","childNodes","nodeType","Node","ELEMENT_NODE","exportDOM","editor","exportDOMResult","spanNode","element","setHtmlForExport","exportJSON","type","version","$createExtendedTextNode","text","$isExtendedTextNode","$applyCustomNodeConfiguration","setMode","toggleUnmergeable"],"sources":["/Users/Matt.Ratliff/Development/lexical-sandbox/src/components/Editor/plugins/ExtendedTextNode.js"],"sourcesContent":["import {\n  $isTextNode,\n  TextNode,\n} from 'lexical';\n\nconst patchNodeAndStyleConversion = (originalDOMConverter) => (domNode) => {\n  const original = originalDOMConverter?.(domNode);\n  if (!original) {\n    return null;\n  }\n  const originalOutput = original.conversion(domNode);\n\n  if (!originalOutput) {\n    return originalOutput;\n  }\n\n  const { backgroundColor } = domNode.style;\n  const { color } = domNode.style;\n  const { fontFamily } = domNode.style;\n  const { fontWeight } = domNode.style;\n  const { fontSize } = domNode.style;\n  const { textDecoration } = domNode.style;\n\n  return {\n    ...originalOutput,\n    forChild: (lexicalNode, parent) => {\n      const originalForChild = originalOutput?.forChild ?? ((x) => x);\n      const result = originalForChild(lexicalNode, parent);\n      if ($isTextNode(result)) {\n        const style = [\n          backgroundColor ? `background-color: ${backgroundColor}` : null,\n          color ? `color: ${color}` : null,\n          fontFamily ? `font-family: ${fontFamily}` : null,\n          fontWeight ? `font-weight: ${fontWeight}` : null,\n          fontSize ? `font-size: ${fontSize}` : null,\n          textDecoration ? `text-decoration: ${textDecoration}` : null,\n        ]\n          .filter((value) => value != null)\n          .join('; ');\n        if (style.length) {\n          return result.setStyle(style);\n        }\n      }\n      return result;\n    },\n  };\n};\n\nexport class ExtendedTextNode extends TextNode {\n  static getType() {\n    return 'extended-text';\n  }\n\n  static clone(node) {\n    return new ExtendedTextNode(node.__text, node.__key);\n  }\n\n  static importDOM() {\n    const importers = TextNode.importDOM();\n    return {\n      ...importers,\n      code: () => ({\n        conversion: patchNodeAndStyleConversion(importers?.code),\n        priority: 1,\n      }),\n      em: () => ({\n        conversion: patchNodeAndStyleConversion(importers?.em),\n        priority: 1,\n      }),\n      span: () => ({\n        conversion: patchNodeAndStyleConversion(importers?.span),\n        priority: 1,\n      }),\n      strong: () => ({\n        conversion: patchNodeAndStyleConversion(importers?.strong),\n        priority: 1,\n      }),\n      sub: () => ({\n        conversion: patchNodeAndStyleConversion(importers?.sub),\n        priority: 1,\n      }),\n      sup: () => ({\n        conversion: patchNodeAndStyleConversion(importers?.sup),\n        priority: 1,\n      }),\n    };\n  }\n\n  static importJSON(serializedNode) {\n    return TextNode.importJSON(serializedNode);\n  }\n\n  isSimpleText() {\n    return ((this.__type === 'text' || this.__type === 'extended-text') && this.__mode === 0);\n  }\n\n  static getDeepestNode(dom) {\n    const nodes = Array.prototype.slice.call(dom.getElementsByTagName('*'));\n    if (nodes.length === 0) {\n      return dom;\n    }\n    const leafNodes = nodes.filter((elem) => {\n      if (elem.hasChildNodes()) {\n        // see if any of the child nodes are elements\n        for (let i = 0; i < elem.childNodes.length; i += 1) {\n          if (elem.childNodes[i].nodeType === Node.ELEMENT_NODE) {\n            // there is a child element, so return false to not include\n            // this parent element\n            return false;\n          }\n        }\n      }\n      return true;\n    });\n    return leafNodes[0];\n  }\n\n  exportDOM(editor) {\n    const exportDOMResult = super.exportDOM(editor);\n    if (this.isSimpleText()) return exportDOMResult;\n    const spanNode = ExtendedTextNode.getDeepestNode(exportDOMResult.element);\n    this.setHtmlForExport(spanNode);\n    return { ...exportDOMResult };\n  }\n\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      type: 'extended-text',\n      version: 1,\n    };\n  }\n}\n\nexport function $createExtendedTextNode(text) {\n  return new ExtendedTextNode(text);\n}\n\nexport function $isExtendedTextNode(node) {\n  return node instanceof ExtendedTextNode;\n}\n\nexport function $applyCustomNodeConfiguration(node) {\n  node.setMode('token');\n  node.toggleUnmergeable();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}