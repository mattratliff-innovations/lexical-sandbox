{"ast":null,"code":"/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getNearestNodeOfType, removeClassNamesFromElement, addClassNamesToElement, isHTMLElement, mergeRegister } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $isRootOrShadowRoot, $isElementNode, $isLeafNode, $createParagraphNode, ElementNode, $isParagraphNode, $applyNodeReplacement, $createTextNode, createCommand, COMMAND_PRIORITY_LOW, INSERT_PARAGRAPH_COMMAND } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if (selection !== null) {\n      const nodes = selection.getNodes();\n      if ($isRangeSelection(selection)) {\n        const anchorAndFocus = selection.getStartEndPoints();\n        if (!(anchorAndFocus !== null)) {\n          throw Error(`insertList: anchor should be defined`);\n        }\n        const [anchor] = anchorAndFocus;\n        const anchorNode = anchor.getNode();\n        const anchorNodeParent = anchorNode.getParent();\n        if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n          const list = $createListNode(listType);\n          if ($isRootOrShadowRoot(anchorNodeParent)) {\n            anchorNode.replace(list);\n            const listItem = $createListItemNode();\n            if ($isElementNode(anchorNode)) {\n              listItem.setFormat(anchorNode.getFormatType());\n              listItem.setIndent(anchorNode.getIndent());\n            }\n            list.append(listItem);\n          } else if ($isListItemNode(anchorNode)) {\n            const parent = anchorNode.getParentOrThrow();\n            append(list, parent.getChildren());\n            parent.replace(list);\n          }\n          return;\n        }\n      }\n      const handled = new Set();\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ($isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n          $createListOrMerge(node, listType);\n          continue;\n        }\n        if ($isLeafNode(node)) {\n          let parent = node.getParent();\n          while (parent != null) {\n            const parentKey = parent.getKey();\n            if ($isListNode(parent)) {\n              if (!handled.has(parentKey)) {\n                const newListNode = $createListNode(listType);\n                append(newListNode, parent.getChildren());\n                parent.replace(newListNode);\n                handled.add(parentKey);\n              }\n              break;\n            } else {\n              const nextParent = parent.getParent();\n              if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                handled.add(parentKey);\n                $createListOrMerge(parent, listType);\n                break;\n              }\n              parent = nextParent;\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  append(listItem, node.getChildren());\n  let targetList;\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    // if the same type of list is on both sides, merge them.\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    targetList = previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    targetList = nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    targetList = list;\n  }\n  // listItem needs to be attached to root prior to setting indent\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  node.remove();\n  return targetList;\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if ($isLeafNode(node)) {\n            const listItemNode = $getNearestNodeOfType(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = $createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph;\n\n          // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ($isRootOrShadowRoot(grandparent)) {\n    replacementNode = $createParagraphNode();\n    replacementNode.setTextStyle(selection.style);\n    replacementNode.setTextFormat(selection.format);\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isListItemNode(replacementNode)) {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    } else {\n      replacementNode.insertAfter(newList);\n    }\n    newList.append(...nextSiblings);\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    // @ts-expect-error - this is always HTMLListItemElement\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListItemNode(node)) {\n        throw Error(`node is not a ListItemNode`);\n      }\n      if (node.__checked == null) {\n        return;\n      }\n      const parent = node.getParent();\n      if ($isListNode(parent)) {\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n  static importDOM() {\n    return {\n      li: () => ({\n        conversion: $convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createListItemNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    element.style.textAlign = this.getFormatType();\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      value: this.getValue()\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!$isElementNode(replaceWithNode)) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : undefined);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n    return self;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n    return self;\n  }\n  toggleChecked() {\n    const self = this.getWritable();\n    return self.setChecked(!self.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      throw Error(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      throw Error(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isListItemNode(node) || $isParagraphNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return $applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType = 'number', start = 1, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n    return writable;\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  }\n  setStart(start) {\n    const self = this.getWritable();\n    self.__start = start;\n    return self;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListNode(node)) {\n        throw Error(`node is not a ListNode`);\n      }\n      mergeNextSiblingListIfSameType(node);\n      updateChildrenListItemValue(node);\n    };\n  }\n  static importDOM() {\n    return {\n      ol: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      }),\n      ul: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createListNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    if (isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag()\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if ($isElementNode(currentNode)) {\n          if (currentNode.isInline()) {\n            listItemNode.append(currentNode);\n          } else {\n            const textNode = $createTextNode(currentNode.getTextContent());\n            listItemNode.append(textNode);\n          }\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if (isHTMLElement(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType = 'number', start = 1) {\n  return $applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_UNORDERED_LIST_COMMAND = createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = createCommand('REMOVE_LIST_COMMAND');\nfunction registerList(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {\n    insertList(editor, 'number');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    insertList(editor, 'bullet');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {\n    removeList(editor);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const hasHandledInsertParagraph = $handleListInsertParagraph();\n    if (hasHandledInsertParagraph) {\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_LOW));\n  return removeListener;\n}\nexport { $createListItemNode, $createListNode, $getListDepth, $handleListInsertParagraph, $isListItemNode, $isListNode, INSERT_CHECK_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, ListItemNode, ListNode, REMOVE_LIST_COMMAND, insertList, registerList, removeList };","map":{"version":3,"names":["$getNearestNodeOfType","removeClassNamesFromElement","addClassNamesToElement","isHTMLElement","mergeRegister","$getSelection","$isRangeSelection","$isRootOrShadowRoot","$isElementNode","$isLeafNode","$createParagraphNode","ElementNode","$isParagraphNode","$applyNodeReplacement","$createTextNode","createCommand","COMMAND_PRIORITY_LOW","INSERT_PARAGRAPH_COMMAND","$getListDepth","listNode","depth","parent","getParent","$isListItemNode","parentList","$isListNode","Error","$getTopListNode","listItem","list","$getAllListItems","node","listItemNodes","listChildren","getChildren","filter","i","length","listItemNode","firstChild","getFirstChild","concat","push","isNestedListNode","$removeHighestEmptyListParent","sublist","emptyListPtr","getNextSibling","getPreviousSibling","remove","$wrapInListItem","listItemWrapper","$createListItemNode","append","$isSelectingEmptyListItem","anchorNode","nodes","is","getChildrenSize","insertList","editor","listType","update","selection","getNodes","anchorAndFocus","getStartEndPoints","anchor","getNode","anchorNodeParent","$createListNode","replace","setFormat","getFormatType","setIndent","getIndent","getParentOrThrow","handled","Set","isEmpty","has","getKey","$createListOrMerge","parentKey","newListNode","add","nextParent","nodesToAppend","splice","previousSibling","nextSibling","targetList","getListType","getFirstChildOrThrow","insertBefore","mergeLists","list1","list2","listItem1","getLastChild","listItem2","toMerge","removeList","listNodes","ListItemNode","insertionPoint","listItems","paragraph","insertAfter","__key","key","set","focus","updateChildrenListItemValue","isNotChecklist","value","getStart","child","getValue","setValue","getLatest","__checked","setChecked","undefined","mergeNextSiblingListIfSameType","$handleIndent","removed","innerList","nextInnerList","children","newListItem","newList","$handleOutdent","grandparentListItem","greatGrandparentList","lastChild","previousSiblingsListItem","previousSiblingsList","getPreviousSiblings","forEach","sibling","nextSiblingsListItem","nextSiblingsList","getNextSiblings","$handleListInsertParagraph","isCollapsed","topListNode","grandparent","replacementNode","setTextStyle","style","setTextFormat","format","select","nextSiblings","normalizeClassNames","classNames","rval","className","s","matchAll","getType","clone","__value","constructor","checked","createDOM","config","element","document","createElement","updateListItemChecked","$setListItemThemeClassNames","theme","updateDOM","prevNode","dom","transform","getChecked","importDOM","li","conversion","$convertListItemElement","priority","importJSON","serializedNode","updateFromJSON","exportDOM","_config","textAlign","exportJSON","canMergeWith","replaceWithNode","includeChildren","__first","__last","nodeToAppend","restoreSelection","siblings","preserveEmptyParent","prevSibling","insertNewAfter","_","newElement","collapseAtStart","listNodeParent","isIndented","type","offset","self","getWritable","Boolean","toggleChecked","__indent","indentLevel","indent","Math","floor","currentIndent","canInsertAfter","canReplaceWith","replacement","extractWithChild","focusNode","isParentOf","getTextContent","isParentRequired","createParentElementNode","canMergeWhenEmpty","editorThemeClasses","classesToAdd","classesToRemove","listTheme","listItemClassName","listitem","nestedListItemClassName","nested","parentNode","isCheckList","listitemUnchecked","listitemChecked","nestedListItemClasses","some","prevListItemNode","removeAttribute","setAttribute","domNode","isGitHubCheckList","classList","contains","tagName","$convertCheckboxInput","ariaCheckedAttr","getAttribute","isCheckboxInput","hasAttribute","ListNode","__listType","TAG_TO_LIST_TYPE","__tag","__start","start","_listType","getTag","setListType","writable","setStart","_editor","tag","String","__lexicalListType","$setListThemeClassNames","ol","$convertListNode","ul","canBeEmpty","canIndent","currentNode","isInline","textNode","listLevelsClassNames","listDepth","normalizedListDepth","listLevelClassName","listClassName","nestedListClassName","nestedListTheme","checklistClassName","checklist","$normalizeChildren","normalizedListItems","isDomChecklist","childNodes","nodeName","toLowerCase","after","INSERT_UNORDERED_LIST_COMMAND","INSERT_ORDERED_LIST_COMMAND","INSERT_CHECK_LIST_COMMAND","REMOVE_LIST_COMMAND","registerList","removeListener","registerCommand","hasHandledInsertParagraph"],"sources":["/Users/Matt.Ratliff/Development/lexical-sandbox/node_modules/@lexical/list/LexicalList.dev.mjs"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { $getNearestNodeOfType, removeClassNamesFromElement, addClassNamesToElement, isHTMLElement, mergeRegister } from '@lexical/utils';\nimport { $getSelection, $isRangeSelection, $isRootOrShadowRoot, $isElementNode, $isLeafNode, $createParagraphNode, ElementNode, $isParagraphNode, $applyNodeReplacement, $createTextNode, createCommand, COMMAND_PRIORITY_LOW, INSERT_PARAGRAPH_COMMAND } from 'lexical';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if (selection !== null) {\n      const nodes = selection.getNodes();\n      if ($isRangeSelection(selection)) {\n        const anchorAndFocus = selection.getStartEndPoints();\n        if (!(anchorAndFocus !== null)) {\n          throw Error(`insertList: anchor should be defined`);\n        }\n        const [anchor] = anchorAndFocus;\n        const anchorNode = anchor.getNode();\n        const anchorNodeParent = anchorNode.getParent();\n        if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n          const list = $createListNode(listType);\n          if ($isRootOrShadowRoot(anchorNodeParent)) {\n            anchorNode.replace(list);\n            const listItem = $createListItemNode();\n            if ($isElementNode(anchorNode)) {\n              listItem.setFormat(anchorNode.getFormatType());\n              listItem.setIndent(anchorNode.getIndent());\n            }\n            list.append(listItem);\n          } else if ($isListItemNode(anchorNode)) {\n            const parent = anchorNode.getParentOrThrow();\n            append(list, parent.getChildren());\n            parent.replace(list);\n          }\n          return;\n        }\n      }\n      const handled = new Set();\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ($isElementNode(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n          $createListOrMerge(node, listType);\n          continue;\n        }\n        if ($isLeafNode(node)) {\n          let parent = node.getParent();\n          while (parent != null) {\n            const parentKey = parent.getKey();\n            if ($isListNode(parent)) {\n              if (!handled.has(parentKey)) {\n                const newListNode = $createListNode(listType);\n                append(newListNode, parent.getChildren());\n                parent.replace(newListNode);\n                handled.add(parentKey);\n              }\n              break;\n            } else {\n              const nextParent = parent.getParent();\n              if ($isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                handled.add(parentKey);\n                $createListOrMerge(parent, listType);\n                break;\n              }\n              parent = nextParent;\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  append(listItem, node.getChildren());\n  let targetList;\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    // if the same type of list is on both sides, merge them.\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    targetList = previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    targetList = nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    targetList = list;\n  }\n  // listItem needs to be attached to root prior to setting indent\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  node.remove();\n  return targetList;\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n          if ($isLeafNode(node)) {\n            const listItemNode = $getNearestNodeOfType(node, ListItemNode);\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n        for (const listItemNode of listItems) {\n          const paragraph = $createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph;\n\n          // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n          listItemNode.remove();\n        }\n        listNode.remove();\n      }\n    }\n  });\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ($isRootOrShadowRoot(grandparent)) {\n    replacementNode = $createParagraphNode();\n    replacementNode.setTextStyle(selection.style);\n    replacementNode.setTextFormat(selection.format);\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isListItemNode(replacementNode)) {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    } else {\n      replacementNode.insertAfter(newList);\n    }\n    newList.append(...nextSiblings);\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'listitem';\n  }\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    // @ts-expect-error - this is always HTMLListItemElement\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListItemNode(node)) {\n        throw Error(`node is not a ListItemNode`);\n      }\n      if (node.__checked == null) {\n        return;\n      }\n      const parent = node.getParent();\n      if ($isListNode(parent)) {\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n  static importDOM() {\n    return {\n      li: () => ({\n        conversion: $convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createListItemNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    element.style.textAlign = this.getFormatType();\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      value: this.getValue()\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!$isElementNode(replaceWithNode)) {\n        throw Error(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : undefined);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = $createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n    return self;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n    return self;\n  }\n  toggleChecked() {\n    const self = this.getWritable();\n    return self.setChecked(!self.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      throw Error(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      throw Error(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isListItemNode(node) || $isParagraphNode(node);\n  }\n  extractWithChild(child, selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return $applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'list';\n  }\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n  constructor(listType = 'number', start = 1, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n    return writable;\n  }\n  getListType() {\n    return this.__listType;\n  }\n  getStart() {\n    return this.__start;\n  }\n  setStart(start) {\n    const self = this.getWritable();\n    self.__start = start;\n    return self;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  static transform() {\n    return node => {\n      if (!$isListNode(node)) {\n        throw Error(`node is not a ListNode`);\n      }\n      mergeNextSiblingListIfSameType(node);\n      updateChildrenListItemValue(node);\n    };\n  }\n  static importDOM() {\n    return {\n      ol: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      }),\n      ul: () => ({\n        conversion: $convertListNode,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createListNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    if (isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag()\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if ($isElementNode(currentNode)) {\n          if (currentNode.isInline()) {\n            listItemNode.append(currentNode);\n          } else {\n            const textNode = $createTextNode(currentNode.getTextContent());\n            listItemNode.append(textNode);\n          }\n        } else {\n          listItemNode.append(currentNode);\n        }\n        super.append(listItemNode);\n      }\n    }\n    return this;\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if (isHTMLElement(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType = 'number', start = 1) {\n  return $applyNodeReplacement(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_UNORDERED_LIST_COMMAND = createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = createCommand('REMOVE_LIST_COMMAND');\nfunction registerList(editor) {\n  const removeListener = mergeRegister(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {\n    insertList(editor, 'number');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    insertList(editor, 'bullet');\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {\n    removeList(editor);\n    return true;\n  }, COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_PARAGRAPH_COMMAND, () => {\n    const hasHandledInsertParagraph = $handleListInsertParagraph();\n    if (hasHandledInsertParagraph) {\n      return true;\n    }\n    return false;\n  }, COMMAND_PRIORITY_LOW));\n  return removeListener;\n}\n\nexport { $createListItemNode, $createListNode, $getListDepth, $handleListInsertParagraph, $isListItemNode, $isListNode, INSERT_CHECK_LIST_COMMAND, INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, ListItemNode, ListNode, REMOVE_LIST_COMMAND, insertList, registerList, removeList };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}