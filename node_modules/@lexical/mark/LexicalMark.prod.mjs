/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import{ElementNode as t,$isRangeSelection as e,$applyNodeReplacement as n,$isElementNode as r,$isTextNode as s}from"lexical";import{addClassNamesToElement as i,removeClassNamesFromElement as o}from"@lexical/utils";const l=[];class u extends t{static getType(){return"mark"}static clone(t){return new u(t.__ids,t.__key)}static importDOM(){return null}static importJSON(t){return c().updateFromJSON(t)}updateFromJSON(t){return super.updateFromJSON(t).setIDs(t.ids)}exportJSON(){return{...super.exportJSON(),ids:this.getIDs()}}constructor(t=l,e){super(e),this.__ids=t}createDOM(t){const e=document.createElement("mark");return i(e,t.theme.mark),this.__ids.length>1&&i(e,t.theme.markOverlap),e}updateDOM(t,e,n){const r=t.__ids,s=this.__ids,l=r.length,u=s.length,c=n.theme.markOverlap;return l!==u&&(1===l?2===u&&i(e,c):1===u&&o(e,c)),!1}hasID(t){return this.getIDs().includes(t)}getIDs(){return Array.from(this.getLatest().__ids)}setIDs(t){const e=this.getWritable();return e.__ids=t,e}addID(t){const e=this.getWritable();return e.__ids.includes(t)?e:e.setIDs([...e.__ids,t])}deleteID(t){const e=this.getWritable(),n=e.__ids.indexOf(t);if(-1===n)return e;const r=Array.from(e.__ids);return r.splice(n,1),e.setIDs(r)}insertNewAfter(t,e=!0){const n=c(this.__ids);return this.insertAfter(n,e),n}canInsertTextBefore(){return!1}canInsertTextAfter(){return!1}canBeEmpty(){return!1}isInline(){return!0}extractWithChild(t,n,r){if(!e(n)||"html"===r)return!1;const s=n.anchor,i=n.focus,o=s.getNode(),l=i.getNode(),u=n.isBackward()?s.offset-i.offset:i.offset-s.offset;return this.isParentOf(o)&&this.isParentOf(l)&&this.getTextContent().length===u}excludeFromCopy(t){return"clone"!==t}}function c(t=l){return n(new u(t))}function f(t){return t instanceof u}function a(t){const e=t.getChildren();let n=null;for(let r=0;r<e.length;r++){const s=e[r];null===n?t.insertBefore(s):n.insertAfter(s),n=s}t.remove()}function d(t,e,n,i){const o=t.getNodes(),l=t.anchor.offset,u=t.focus.offset,a=o.length,d=e?u:l,h=e?l:u;let g,_;for(let t=0;t<a;t++){const e=o[t];if(r(_)&&_.isParentOf(e))continue;const l=0===t,u=t===a-1;let m=null;if(s(e)){const t=e.getTextContentSize(),n=l?d:0,r=u?h:t;if(0===n&&0===r)continue;const s=e.splitText(n,r);m=s.length>1&&(3===s.length||l&&!u||r===t)?s[1]:s[0]}else{if(f(e))continue;r(e)&&e.isInline()&&(m=e)}if(null!==m){if(m&&m.is(g))continue;const t=m.getParent();if(null!=t&&t.is(g)||(_=void 0),g=t,void 0===_){_=(i||c)([n]),m.insertBefore(_)}_.append(m)}else g=void 0,_=void 0}r(_)&&(e?_.selectStart():_.selectEnd())}function h(t,e){let n=t;for(;null!==n;){if(f(n))return n.getIDs();if(s(n)&&e===n.getTextContentSize()){const t=n.getNextSibling();if(f(t))return t.getIDs()}n=n.getParent()}return null}export{c as $createMarkNode,h as $getMarkIDs,f as $isMarkNode,a as $unwrapMarkNode,d as $wrapSelectionInMarkNode,u as MarkNode};
